(self["webpackChunkdemo"] = self["webpackChunkdemo"] || []).push([[7580],{

/***/ 6550
/*!*****************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_weak_ref-chunk.mjs ***!
  \*****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setAlternateWeakRefImpl: () => (/* binding */ setAlternateWeakRefImpl)
/* harmony export */ });
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

function setAlternateWeakRefImpl(impl) {}


/***/ },

/***/ 11817
/*!******************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_untracked-chunk.mjs ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFTER_RENDER_SEQUENCES_TO_ADD: () => (/* binding */ AFTER_RENDER_SEQUENCES_TO_ADD),
/* harmony export */   ANIMATIONS: () => (/* binding */ ANIMATIONS),
/* harmony export */   CHILD_HEAD: () => (/* binding */ CHILD_HEAD),
/* harmony export */   CHILD_TAIL: () => (/* binding */ CHILD_TAIL),
/* harmony export */   CLEANUP: () => (/* binding */ CLEANUP),
/* harmony export */   CONTAINER_HEADER_OFFSET: () => (/* binding */ CONTAINER_HEADER_OFFSET),
/* harmony export */   CONTEXT: () => (/* binding */ CONTEXT),
/* harmony export */   ChangeDetectionScheduler: () => (/* binding */ ChangeDetectionScheduler),
/* harmony export */   CheckNoChangesMode: () => (/* binding */ CheckNoChangesMode),
/* harmony export */   DEBUG_TASK_TRACKER: () => (/* binding */ DEBUG_TASK_TRACKER),
/* harmony export */   DECLARATION_COMPONENT_VIEW: () => (/* binding */ DECLARATION_COMPONENT_VIEW),
/* harmony export */   DECLARATION_LCONTAINER: () => (/* binding */ DECLARATION_LCONTAINER),
/* harmony export */   DECLARATION_VIEW: () => (/* binding */ DECLARATION_VIEW),
/* harmony export */   DEHYDRATED_VIEWS: () => (/* binding */ DEHYDRATED_VIEWS),
/* harmony export */   DOCUMENT: () => (/* binding */ DOCUMENT),
/* harmony export */   DOC_PAGE_BASE_URL: () => (/* binding */ DOC_PAGE_BASE_URL),
/* harmony export */   DestroyRef: () => (/* binding */ DestroyRef),
/* harmony export */   EFFECTS: () => (/* binding */ EFFECTS),
/* harmony export */   EFFECTS_TO_SCHEDULE: () => (/* binding */ EFFECTS_TO_SCHEDULE),
/* harmony export */   EMBEDDED_VIEW_INJECTOR: () => (/* binding */ EMBEDDED_VIEW_INJECTOR),
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),
/* harmony export */   ENVIRONMENT: () => (/* binding */ ENVIRONMENT),
/* harmony export */   ENVIRONMENT_INITIALIZER: () => (/* binding */ ENVIRONMENT_INITIALIZER),
/* harmony export */   ERROR_DETAILS_PAGE_BASE_URL: () => (/* binding */ ERROR_DETAILS_PAGE_BASE_URL),
/* harmony export */   EffectRefImpl: () => (/* binding */ EffectRefImpl),
/* harmony export */   EffectScheduler: () => (/* binding */ EffectScheduler),
/* harmony export */   EnvironmentInjector: () => (/* binding */ EnvironmentInjector),
/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler),
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),
/* harmony export */   FLAGS: () => (/* binding */ FLAGS),
/* harmony export */   HEADER_OFFSET: () => (/* binding */ HEADER_OFFSET),
/* harmony export */   HOST: () => (/* binding */ HOST),
/* harmony export */   HYDRATION: () => (/* binding */ HYDRATION),
/* harmony export */   ID: () => (/* binding */ ID),
/* harmony export */   INJECTOR: () => (/* binding */ INJECTOR$1),
/* harmony export */   INJECTOR$1: () => (/* binding */ INJECTOR),
/* harmony export */   INJECTOR_DEF_TYPES: () => (/* binding */ INJECTOR_DEF_TYPES),
/* harmony export */   INJECTOR_SCOPE: () => (/* binding */ INJECTOR_SCOPE),
/* harmony export */   INTERNAL_APPLICATION_ERROR_HANDLER: () => (/* binding */ INTERNAL_APPLICATION_ERROR_HANDLER),
/* harmony export */   InjectionToken: () => (/* binding */ InjectionToken),
/* harmony export */   Injector: () => (/* binding */ Injector),
/* harmony export */   MATH_ML_NAMESPACE: () => (/* binding */ MATH_ML_NAMESPACE),
/* harmony export */   MOVED_VIEWS: () => (/* binding */ MOVED_VIEWS),
/* harmony export */   NATIVE: () => (/* binding */ NATIVE),
/* harmony export */   NEXT: () => (/* binding */ NEXT),
/* harmony export */   NG_COMP_DEF: () => (/* binding */ NG_COMP_DEF),
/* harmony export */   NG_DIR_DEF: () => (/* binding */ NG_DIR_DEF),
/* harmony export */   NG_ELEMENT_ID: () => (/* binding */ NG_ELEMENT_ID),
/* harmony export */   NG_FACTORY_DEF: () => (/* binding */ NG_FACTORY_DEF),
/* harmony export */   NG_INJ_DEF: () => (/* binding */ NG_INJ_DEF),
/* harmony export */   NG_MOD_DEF: () => (/* binding */ NG_MOD_DEF),
/* harmony export */   NG_PIPE_DEF: () => (/* binding */ NG_PIPE_DEF),
/* harmony export */   NG_PROV_DEF: () => (/* binding */ NG_PROV_DEF),
/* harmony export */   NgZone: () => (/* binding */ NgZone),
/* harmony export */   NoopNgZone: () => (/* binding */ NoopNgZone),
/* harmony export */   NullInjector: () => (/* binding */ NullInjector),
/* harmony export */   ON_DESTROY_HOOKS: () => (/* binding */ ON_DESTROY_HOOKS),
/* harmony export */   PARENT: () => (/* binding */ PARENT),
/* harmony export */   PREORDER_HOOK_FLAGS: () => (/* binding */ PREORDER_HOOK_FLAGS),
/* harmony export */   PROVIDED_ZONELESS: () => (/* binding */ PROVIDED_ZONELESS),
/* harmony export */   PendingTasks: () => (/* binding */ PendingTasks),
/* harmony export */   PendingTasksInternal: () => (/* binding */ PendingTasksInternal),
/* harmony export */   QUERIES: () => (/* binding */ QUERIES),
/* harmony export */   R3Injector: () => (/* binding */ R3Injector),
/* harmony export */   REACTIVE_TEMPLATE_CONSUMER: () => (/* binding */ REACTIVE_TEMPLATE_CONSUMER),
/* harmony export */   RENDERER: () => (/* binding */ RENDERER),
/* harmony export */   RuntimeError: () => (/* binding */ RuntimeError),
/* harmony export */   SCHEDULE_IN_ROOT_ZONE: () => (/* binding */ SCHEDULE_IN_ROOT_ZONE),
/* harmony export */   SCHEDULE_IN_ROOT_ZONE_DEFAULT: () => (/* binding */ SCHEDULE_IN_ROOT_ZONE_DEFAULT),
/* harmony export */   SVG_NAMESPACE: () => (/* binding */ SVG_NAMESPACE),
/* harmony export */   TVIEW: () => (/* binding */ TVIEW),
/* harmony export */   T_HOST: () => (/* binding */ T_HOST),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   VIEW_REFS: () => (/* binding */ VIEW_REFS),
/* harmony export */   Version: () => (/* binding */ Version),
/* harmony export */   ViewContext: () => (/* binding */ ViewContext),
/* harmony export */   XSS_SECURITY_URL: () => (/* binding */ XSS_SECURITY_URL),
/* harmony export */   ZONELESS_ENABLED: () => (/* binding */ ZONELESS_ENABLED),
/* harmony export */   _global: () => (/* binding */ _global),
/* harmony export */   addToArray: () => (/* binding */ addToArray),
/* harmony export */   angularZoneInstanceIdProperty: () => (/* binding */ angularZoneInstanceIdProperty),
/* harmony export */   arrayEquals: () => (/* binding */ arrayEquals),
/* harmony export */   arrayInsert2: () => (/* binding */ arrayInsert2),
/* harmony export */   arraySplice: () => (/* binding */ arraySplice),
/* harmony export */   assertComponentType: () => (/* binding */ assertComponentType),
/* harmony export */   assertDefined: () => (/* binding */ assertDefined),
/* harmony export */   assertDirectiveDef: () => (/* binding */ assertDirectiveDef),
/* harmony export */   assertDomNode: () => (/* binding */ assertDomNode),
/* harmony export */   assertElement: () => (/* binding */ assertElement),
/* harmony export */   assertEqual: () => (/* binding */ assertEqual),
/* harmony export */   assertFirstCreatePass: () => (/* binding */ assertFirstCreatePass),
/* harmony export */   assertFirstUpdatePass: () => (/* binding */ assertFirstUpdatePass),
/* harmony export */   assertFunction: () => (/* binding */ assertFunction),
/* harmony export */   assertGreaterThan: () => (/* binding */ assertGreaterThan),
/* harmony export */   assertGreaterThanOrEqual: () => (/* binding */ assertGreaterThanOrEqual),
/* harmony export */   assertHasParent: () => (/* binding */ assertHasParent),
/* harmony export */   assertInInjectionContext: () => (/* binding */ assertInInjectionContext),
/* harmony export */   assertIndexInDeclRange: () => (/* binding */ assertIndexInDeclRange),
/* harmony export */   assertIndexInExpandoRange: () => (/* binding */ assertIndexInExpandoRange),
/* harmony export */   assertIndexInRange: () => (/* binding */ assertIndexInRange),
/* harmony export */   assertInjectImplementationNotEqual: () => (/* binding */ assertInjectImplementationNotEqual),
/* harmony export */   assertLContainer: () => (/* binding */ assertLContainer),
/* harmony export */   assertLView: () => (/* binding */ assertLView),
/* harmony export */   assertLessThan: () => (/* binding */ assertLessThan),
/* harmony export */   assertNgModuleType: () => (/* binding */ assertNgModuleType),
/* harmony export */   assertNodeInjector: () => (/* binding */ assertNodeInjector),
/* harmony export */   assertNotDefined: () => (/* binding */ assertNotDefined),
/* harmony export */   assertNotEqual: () => (/* binding */ assertNotEqual),
/* harmony export */   assertNotInReactiveContext: () => (/* binding */ assertNotInReactiveContext),
/* harmony export */   assertNotReactive: () => (/* binding */ assertNotReactive),
/* harmony export */   assertNotSame: () => (/* binding */ assertNotSame),
/* harmony export */   assertNumber: () => (/* binding */ assertNumber),
/* harmony export */   assertNumberInRange: () => (/* binding */ assertNumberInRange),
/* harmony export */   assertOneOf: () => (/* binding */ assertOneOf),
/* harmony export */   assertParentView: () => (/* binding */ assertParentView),
/* harmony export */   assertProjectionSlots: () => (/* binding */ assertProjectionSlots),
/* harmony export */   assertSame: () => (/* binding */ assertSame),
/* harmony export */   assertString: () => (/* binding */ assertString),
/* harmony export */   assertTIcu: () => (/* binding */ assertTIcu),
/* harmony export */   assertTNode: () => (/* binding */ assertTNode),
/* harmony export */   assertTNodeCreationIndex: () => (/* binding */ assertTNodeCreationIndex),
/* harmony export */   assertTNodeForLView: () => (/* binding */ assertTNodeForLView),
/* harmony export */   assertTNodeForTView: () => (/* binding */ assertTNodeForTView),
/* harmony export */   attachInjectFlag: () => (/* binding */ attachInjectFlag),
/* harmony export */   concatStringsWithSpace: () => (/* binding */ concatStringsWithSpace),
/* harmony export */   convertToBitFlags: () => (/* binding */ convertToBitFlags),
/* harmony export */   createInjector: () => (/* binding */ createInjector),
/* harmony export */   createInjectorWithoutInjectorInstances: () => (/* binding */ createInjectorWithoutInjectorInstances),
/* harmony export */   cyclicDependencyError: () => (/* binding */ cyclicDependencyError),
/* harmony export */   cyclicDependencyErrorWithDetails: () => (/* binding */ cyclicDependencyErrorWithDetails),
/* harmony export */   debugStringifyTypeForError: () => (/* binding */ debugStringifyTypeForError),
/* harmony export */   decreaseElementDepthCount: () => (/* binding */ decreaseElementDepthCount),
/* harmony export */   deepForEach: () => (/* binding */ deepForEach),
/* harmony export */   effect: () => (/* binding */ effect),
/* harmony export */   emitAfterRenderEffectPhaseCreatedEvent: () => (/* binding */ emitAfterRenderEffectPhaseCreatedEvent),
/* harmony export */   emitInjectEvent: () => (/* binding */ emitInjectEvent),
/* harmony export */   emitInjectorToCreateInstanceEvent: () => (/* binding */ emitInjectorToCreateInstanceEvent),
/* harmony export */   emitInstanceCreatedByInjectorEvent: () => (/* binding */ emitInstanceCreatedByInjectorEvent),
/* harmony export */   emitProviderConfiguredEvent: () => (/* binding */ emitProviderConfiguredEvent),
/* harmony export */   enterDI: () => (/* binding */ enterDI),
/* harmony export */   enterSkipHydrationBlock: () => (/* binding */ enterSkipHydrationBlock),
/* harmony export */   enterView: () => (/* binding */ enterView),
/* harmony export */   errorHandlerEnvironmentInitializer: () => (/* binding */ errorHandlerEnvironmentInitializer),
/* harmony export */   fillProperties: () => (/* binding */ fillProperties),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   formatRuntimeError: () => (/* binding */ formatRuntimeError),
/* harmony export */   forwardRef: () => (/* binding */ forwardRef),
/* harmony export */   getBindingIndex: () => (/* binding */ getBindingIndex),
/* harmony export */   getBindingRoot: () => (/* binding */ getBindingRoot),
/* harmony export */   getBindingsEnabled: () => (/* binding */ getBindingsEnabled),
/* harmony export */   getClosureSafeProperty: () => (/* binding */ getClosureSafeProperty),
/* harmony export */   getComponentDef: () => (/* binding */ getComponentDef),
/* harmony export */   getComponentLViewByIndex: () => (/* binding */ getComponentLViewByIndex),
/* harmony export */   getConstant: () => (/* binding */ getConstant),
/* harmony export */   getContextLView: () => (/* binding */ getContextLView),
/* harmony export */   getCurrentDirectiveDef: () => (/* binding */ getCurrentDirectiveDef),
/* harmony export */   getCurrentDirectiveIndex: () => (/* binding */ getCurrentDirectiveIndex),
/* harmony export */   getCurrentParentTNode: () => (/* binding */ getCurrentParentTNode),
/* harmony export */   getCurrentQueryIndex: () => (/* binding */ getCurrentQueryIndex),
/* harmony export */   getCurrentTNode: () => (/* binding */ getCurrentTNode),
/* harmony export */   getCurrentTNodePlaceholderOk: () => (/* binding */ getCurrentTNodePlaceholderOk),
/* harmony export */   getDirectiveDef: () => (/* binding */ getDirectiveDef),
/* harmony export */   getDirectiveDefOrThrow: () => (/* binding */ getDirectiveDefOrThrow),
/* harmony export */   getElementDepthCount: () => (/* binding */ getElementDepthCount),
/* harmony export */   getFactoryDef: () => (/* binding */ getFactoryDef),
/* harmony export */   getInjectableDef: () => (/* binding */ getInjectableDef),
/* harmony export */   getInjectorDef: () => (/* binding */ getInjectorDef),
/* harmony export */   getLView: () => (/* binding */ getLView),
/* harmony export */   getLViewParent: () => (/* binding */ getLViewParent),
/* harmony export */   getNamespace: () => (/* binding */ getNamespace),
/* harmony export */   getNativeByIndex: () => (/* binding */ getNativeByIndex),
/* harmony export */   getNativeByTNode: () => (/* binding */ getNativeByTNode),
/* harmony export */   getNativeByTNodeOrNull: () => (/* binding */ getNativeByTNodeOrNull),
/* harmony export */   getNgModuleDef: () => (/* binding */ getNgModuleDef),
/* harmony export */   getNgModuleDefOrThrow: () => (/* binding */ getNgModuleDefOrThrow),
/* harmony export */   getNullInjector: () => (/* binding */ getNullInjector),
/* harmony export */   getOrCreateLViewCleanup: () => (/* binding */ getOrCreateLViewCleanup),
/* harmony export */   getOrCreateTViewCleanup: () => (/* binding */ getOrCreateTViewCleanup),
/* harmony export */   getPipeDef: () => (/* binding */ getPipeDef),
/* harmony export */   getSelectedIndex: () => (/* binding */ getSelectedIndex),
/* harmony export */   getSelectedTNode: () => (/* binding */ getSelectedTNode),
/* harmony export */   getTNode: () => (/* binding */ getTNode),
/* harmony export */   getTView: () => (/* binding */ getTView),
/* harmony export */   hasI18n: () => (/* binding */ hasI18n),
/* harmony export */   importProvidersFrom: () => (/* binding */ importProvidersFrom),
/* harmony export */   increaseElementDepthCount: () => (/* binding */ increaseElementDepthCount),
/* harmony export */   incrementBindingIndex: () => (/* binding */ incrementBindingIndex),
/* harmony export */   initNgDevMode: () => (/* binding */ initNgDevMode),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   injectRootLimpMode: () => (/* binding */ injectRootLimpMode),
/* harmony export */   internalImportProvidersFrom: () => (/* binding */ internalImportProvidersFrom),
/* harmony export */   isClassProvider: () => (/* binding */ isClassProvider),
/* harmony export */   isComponentDef: () => (/* binding */ isComponentDef),
/* harmony export */   isComponentHost: () => (/* binding */ isComponentHost),
/* harmony export */   isContentQueryHost: () => (/* binding */ isContentQueryHost),
/* harmony export */   isCreationMode: () => (/* binding */ isCreationMode),
/* harmony export */   isCurrentTNodeParent: () => (/* binding */ isCurrentTNodeParent),
/* harmony export */   isDestroyed: () => (/* binding */ isDestroyed),
/* harmony export */   isDirectiveHost: () => (/* binding */ isDirectiveHost),
/* harmony export */   isEnvironmentProviders: () => (/* binding */ isEnvironmentProviders),
/* harmony export */   isExhaustiveCheckNoChanges: () => (/* binding */ isExhaustiveCheckNoChanges),
/* harmony export */   isForwardRef: () => (/* binding */ isForwardRef),
/* harmony export */   isInCheckNoChangesMode: () => (/* binding */ isInCheckNoChangesMode),
/* harmony export */   isInI18nBlock: () => (/* binding */ isInI18nBlock),
/* harmony export */   isInInjectionContext: () => (/* binding */ isInInjectionContext),
/* harmony export */   isInSkipHydrationBlock: () => (/* binding */ isInSkipHydrationBlock),
/* harmony export */   isInjectable: () => (/* binding */ isInjectable),
/* harmony export */   isLContainer: () => (/* binding */ isLContainer),
/* harmony export */   isLView: () => (/* binding */ isLView),
/* harmony export */   isProjectionTNode: () => (/* binding */ isProjectionTNode),
/* harmony export */   isRefreshingViews: () => (/* binding */ isRefreshingViews),
/* harmony export */   isRootView: () => (/* binding */ isRootView),
/* harmony export */   isSkipHydrationRootTNode: () => (/* binding */ isSkipHydrationRootTNode),
/* harmony export */   isStandalone: () => (/* binding */ isStandalone),
/* harmony export */   isTypeProvider: () => (/* binding */ isTypeProvider),
/* harmony export */   keyValueArrayGet: () => (/* binding */ keyValueArrayGet),
/* harmony export */   keyValueArrayIndexOf: () => (/* binding */ keyValueArrayIndexOf),
/* harmony export */   keyValueArraySet: () => (/* binding */ keyValueArraySet),
/* harmony export */   lastNodeWasCreated: () => (/* binding */ lastNodeWasCreated),
/* harmony export */   leaveDI: () => (/* binding */ leaveDI),
/* harmony export */   leaveSkipHydrationBlock: () => (/* binding */ leaveSkipHydrationBlock),
/* harmony export */   leaveView: () => (/* binding */ leaveView),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   makeEnvironmentProviders: () => (/* binding */ makeEnvironmentProviders),
/* harmony export */   markAncestorsForTraversal: () => (/* binding */ markAncestorsForTraversal),
/* harmony export */   markViewForRefresh: () => (/* binding */ markViewForRefresh),
/* harmony export */   newArray: () => (/* binding */ newArray),
/* harmony export */   nextBindingIndex: () => (/* binding */ nextBindingIndex),
/* harmony export */   nextContextImpl: () => (/* binding */ nextContextImpl),
/* harmony export */   provideBrowserGlobalErrorListeners: () => (/* binding */ provideBrowserGlobalErrorListeners),
/* harmony export */   provideEnvironmentInitializer: () => (/* binding */ provideEnvironmentInitializer),
/* harmony export */   providerToFactory: () => (/* binding */ providerToFactory),
/* harmony export */   removeFromArray: () => (/* binding */ removeFromArray),
/* harmony export */   removeLViewOnDestroy: () => (/* binding */ removeLViewOnDestroy),
/* harmony export */   renderStringify: () => (/* binding */ renderStringify),
/* harmony export */   requiresRefreshOrTraversal: () => (/* binding */ requiresRefreshOrTraversal),
/* harmony export */   resetPreOrderHookFlags: () => (/* binding */ resetPreOrderHookFlags),
/* harmony export */   resolveForwardRef: () => (/* binding */ resolveForwardRef),
/* harmony export */   runInInjectionContext: () => (/* binding */ runInInjectionContext),
/* harmony export */   runInInjectorProfilerContext: () => (/* binding */ runInInjectorProfilerContext),
/* harmony export */   scheduleCallbackWithMicrotask: () => (/* binding */ scheduleCallbackWithMicrotask),
/* harmony export */   scheduleCallbackWithRafRace: () => (/* binding */ scheduleCallbackWithRafRace),
/* harmony export */   setBindingIndex: () => (/* binding */ setBindingIndex),
/* harmony export */   setBindingRootForHostBindings: () => (/* binding */ setBindingRootForHostBindings),
/* harmony export */   setCurrentDirectiveIndex: () => (/* binding */ setCurrentDirectiveIndex),
/* harmony export */   setCurrentQueryIndex: () => (/* binding */ setCurrentQueryIndex),
/* harmony export */   setCurrentTNode: () => (/* binding */ setCurrentTNode),
/* harmony export */   setCurrentTNodeAsNotParent: () => (/* binding */ setCurrentTNodeAsNotParent),
/* harmony export */   setInI18nBlock: () => (/* binding */ setInI18nBlock),
/* harmony export */   setInjectImplementation: () => (/* binding */ setInjectImplementation),
/* harmony export */   setInjectorProfiler: () => (/* binding */ setInjectorProfiler),
/* harmony export */   setInjectorProfilerContext: () => (/* binding */ setInjectorProfilerContext),
/* harmony export */   setIsInCheckNoChangesMode: () => (/* binding */ setIsInCheckNoChangesMode),
/* harmony export */   setIsRefreshingViews: () => (/* binding */ setIsRefreshingViews),
/* harmony export */   setSelectedIndex: () => (/* binding */ setSelectedIndex),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   signalAsReadonlyFn: () => (/* binding */ signalAsReadonlyFn),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   storeCleanupWithContext: () => (/* binding */ storeCleanupWithContext),
/* harmony export */   storeLViewOnDestroy: () => (/* binding */ storeLViewOnDestroy),
/* harmony export */   stringify: () => (/* binding */ stringify),
/* harmony export */   stringifyForError: () => (/* binding */ stringifyForError),
/* harmony export */   throwError: () => (/* binding */ throwError),
/* harmony export */   throwProviderNotFoundError: () => (/* binding */ throwProviderNotFoundError),
/* harmony export */   truncateMiddle: () => (/* binding */ truncateMiddle),
/* harmony export */   untracked: () => (/* binding */ untracked),
/* harmony export */   unwrapLView: () => (/* binding */ unwrapLView),
/* harmony export */   unwrapRNode: () => (/* binding */ unwrapRNode),
/* harmony export */   updateAncestorTraversalFlagsOnAttach: () => (/* binding */ updateAncestorTraversalFlagsOnAttach),
/* harmony export */   viewAttachedToChangeDetector: () => (/* binding */ viewAttachedToChangeDetector),
/* harmony export */   viewAttachedToContainer: () => (/* binding */ viewAttachedToContainer),
/* harmony export */   walkProviderTree: () => (/* binding */ walkProviderTree),
/* harmony export */   walkUpViews: () => (/* binding */ walkUpViews),
/* harmony export */   wasLastNodeCreated: () => (/* binding */ wasLastNodeCreated),
/* harmony export */   "ɵunwrapWritableSignal": () => (/* binding */ ɵunwrapWritableSignal),
/* harmony export */   "ɵɵdefineInjectable": () => (/* binding */ ɵɵdefineInjectable),
/* harmony export */   "ɵɵdefineInjector": () => (/* binding */ ɵɵdefineInjector),
/* harmony export */   "ɵɵdisableBindings": () => (/* binding */ ɵɵdisableBindings),
/* harmony export */   "ɵɵenableBindings": () => (/* binding */ ɵɵenableBindings),
/* harmony export */   "ɵɵinject": () => (/* binding */ ɵɵinject),
/* harmony export */   "ɵɵinvalidFactoryDep": () => (/* binding */ ɵɵinvalidFactoryDep),
/* harmony export */   "ɵɵnamespaceHTML": () => (/* binding */ ɵɵnamespaceHTML),
/* harmony export */   "ɵɵnamespaceMathML": () => (/* binding */ ɵɵnamespaceMathML),
/* harmony export */   "ɵɵnamespaceSVG": () => (/* binding */ ɵɵnamespaceSVG),
/* harmony export */   "ɵɵresetView": () => (/* binding */ ɵɵresetView),
/* harmony export */   "ɵɵrestoreView": () => (/* binding */ ɵɵrestoreView)
/* harmony export */ });
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 44866);
/* harmony import */ var _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_not_found-chunk.mjs */ 78330);
/* harmony import */ var _angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core/primitives/signals */ 95094);
/* harmony import */ var _angular_core_primitives_di__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core/primitives/di */ 20144);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */






class Version {
  full;
  major;
  minor;
  patch;
  constructor(full) {
    this.full = full;
    const parts = full.split('.');
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join('.');
  }
}
const VERSION = /* @__PURE__ */new Version('21.1.0');
const DOC_PAGE_BASE_URL = /*#__PURE__*/(() => {
  const full = VERSION.full;
  const isPreRelease = full.includes('-next') || full.includes('-rc') || full === '0.0.0' + '-PLACEHOLDER';
  const prefix = isPreRelease ? 'next' : `v${VERSION.major}`;
  return `https://${prefix}.angular.dev`;
})();
const ERROR_DETAILS_PAGE_BASE_URL = /*#__PURE__*/(() => {
  return `${DOC_PAGE_BASE_URL}/errors`;
})();
const XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';
class RuntimeError extends Error {
  code;
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
}
function formatRuntimeErrorCode(code) {
  return `NG0${Math.abs(code)}`;
}
function formatRuntimeError(code, message) {
  const fullCode = formatRuntimeErrorCode(code);
  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? '.' : '';
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
const _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== 'undefined' ? location.toString() : '';
  const newCounters = {
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0,
    deferBlocksWithIncrementalHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
  if (!allowNgDevModeTrue) {
    _global['ngDevMode'] = false;
  } else {
    if (typeof _global['ngDevMode'] !== 'object') {
      _global['ngDevMode'] = {};
    }
    Object.assign(_global['ngDevMode'], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== 'undefined' && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Could not find renamed property on target object.' : '');
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === 'string') {
    return token;
  }
  if (Array.isArray(token)) {
    return `[${token.map(stringify).join(', ')}]`;
  }
  if (token == null) {
    return '' + token;
  }
  const name = token.overriddenName || token.name;
  if (name) {
    return `${name}`;
  }
  const result = token.toString();
  if (result == null) {
    return '' + result;
  }
  const newLineIndex = result.indexOf('\n');
  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;
}
function concatStringsWithSpace(before, after) {
  if (!before) return after || '';
  if (!after) return before;
  return `${before} ${after}`;
}
function truncateMiddle(str, maxLength = 100) {
  if (!str || maxLength < 1 || str.length <= maxLength) return str;
  if (maxLength == 1) return str.substring(0, 1) + '...';
  const halfLimit = Math.round(maxLength / 2);
  return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);
}
const __forward_ref__ = /*#__PURE__*/getClosureSafeProperty({
  __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function () {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === 'number')) {
    throwError(msg, typeof actual, 'number', '===');
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, 'Expected a number');
  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');
  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');
}
function assertString(actual, msg) {
  if (!(typeof actual === 'string')) {
    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === 'function')) {
    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError(msg, actual, expected, '==');
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError(msg, actual, expected, '!=');
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError(msg, actual, expected, '===');
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError(msg, actual, expected, '!==');
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError(msg, actual, expected, '<');
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError(msg, actual, expected, '<=');
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError(msg, actual, expected, '>');
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError(msg, actual, expected, '>=');
  }
}
function assertNotDefined(actual, msg) {
  if (actual != null) {
    throwError(msg, actual, null, '==');
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError(msg, actual, null, '!=');
  }
}
function throwError(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, 'Array must be defined.');
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1) return true;
  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getActiveConsumer)() !== null) {
    throwError(`${fn}() should never be called in a reactive context.`);
  }
}
function ɵɵdefineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: undefined
  };
}
function ɵɵdefineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) && type[field] || null;
}
function getInheritedInjectableDef(type) {
  const def = type?.[NG_PROV_DEF] ?? null;
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;
}
const NG_PROV_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵprov: getClosureSafeProperty
});
const NG_INJ_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵinj: getClosureSafeProperty
});
class InjectionToken {
  _desc;
  ngMetadataName = 'InjectionToken';
  ɵprov;
  constructor(_desc, options) {
    this._desc = _desc;
    this.ɵprov = undefined;
    if (typeof options == 'number') {
      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== undefined) {
      this.ɵprov = ɵɵdefineInjectable({
        token: this,
        providedIn: options.providedIn || 'root',
        factory: options.factory
      });
    }
  }
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
}
let _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context) {
  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context;
  return previous;
}
const injectorProfilerCallbacks = [];
const NOOP_PROFILER_REMOVAL = () => {};
function removeProfiler(profiler) {
  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);
  if (profilerIdx !== -1) {
    injectorProfilerCallbacks.splice(profilerIdx, 1);
  }
}
function setInjectorProfiler(injectorProfiler) {
  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');
  if (injectorProfiler !== null) {
    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {
      injectorProfilerCallbacks.push(injectorProfiler);
    }
    return () => removeProfiler(injectorProfiler);
  } else {
    injectorProfilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
function injectorProfiler(event) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {
    const injectorProfilerCallback = injectorProfilerCallbacks[i];
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  let token;
  if (typeof eventProvider === 'function') {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.ɵprov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: {
      token,
      provider,
      isViewProvider
    }
  });
}
function emitInjectorToCreateInstanceEvent(token) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 5,
    context: getInjectorProfilerContext(),
    token: token
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: {
      value: instance
    }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: {
      token,
      value,
      flags
    }
  });
}
function emitEffectCreatedEvent(effect) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 3,
    context: getInjectorProfilerContext(),
    effect
  });
}
function emitAfterRenderEffectPhaseCreatedEvent(effectPhase) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 4,
    context: getInjectorProfilerContext(),
    effectPhase
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError('runInInjectorProfilerContext should never be called in production mode');
  const prevInjectContext = setInjectorProfilerContext({
    injector,
    token
  });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.ɵproviders;
}
const NG_COMP_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵcmp: getClosureSafeProperty
});
const NG_DIR_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵdir: getClosureSafeProperty
});
const NG_PIPE_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵpipe: getClosureSafeProperty
});
const NG_MOD_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵmod: getClosureSafeProperty
});
const NG_FACTORY_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵfac: getClosureSafeProperty
});
const NG_ELEMENT_ID = /*#__PURE__*/getClosureSafeProperty({
  __NG_ELEMENT_ID__: getClosureSafeProperty
});
const NG_ENV_ID = /*#__PURE__*/getClosureSafeProperty({
  __NG_ENV_ID__: getClosureSafeProperty
});
function getNgModuleDef(type) {
  assertTypeDefined(type, '@NgModule');
  return type[NG_MOD_DEF] || null;
}
function getNgModuleDefOrThrow(type) {
  const ngModuleDef = getNgModuleDef(type);
  if (!ngModuleDef) {
    throw new RuntimeError(915, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵmod' property.`);
  }
  return ngModuleDef;
}
function getComponentDef(type) {
  assertTypeDefined(type, '@Component');
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDefOrThrow(type) {
  const def = getDirectiveDef(type);
  if (!def) {
    throw new RuntimeError(916, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵdir' property.`);
  }
  return def;
}
function getDirectiveDef(type) {
  assertTypeDefined(type, '@Directive');
  return type[NG_DIR_DEF] || null;
}
function getPipeDef(type) {
  assertTypeDefined(type, '@Pipe');
  return type[NG_PIPE_DEF] || null;
}
function assertTypeDefined(type, symbolType) {
  if (type == null) {
    throw new RuntimeError(-919, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot read ${symbolType} metadata. This can indicate a runtime ` + `circular dependency in your app that needs to be resolved.`);
  }
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
  return def !== null && def.standalone;
}
function renderStringify(value) {
  if (typeof value === 'string') return value;
  if (value == null) return '';
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === 'function') return value.name || value.toString();
  if (typeof value === 'object' && value != null && typeof value.type === 'function') {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function debugStringifyTypeForError(type) {
  const componentDef = getComponentDef(type);
  if (componentDef !== null && componentDef.debugInfo) {
    return stringifyTypeFromDebugInfo(componentDef.debugInfo);
  }
  return stringifyForError(type);
}
function stringifyTypeFromDebugInfo(debugInfo) {
  if (!debugInfo.filePath || !debugInfo.lineNumber) {
    return debugInfo.className;
  } else {
    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;
  }
}
const NG_RUNTIME_ERROR_CODE = /*#__PURE__*/getClosureSafeProperty({
  'ngErrorCode': getClosureSafeProperty
});
const NG_RUNTIME_ERROR_MESSAGE = /*#__PURE__*/getClosureSafeProperty({
  'ngErrorMessage': getClosureSafeProperty
});
const NG_TOKEN_PATH = /*#__PURE__*/getClosureSafeProperty({
  'ngTokenPath': getClosureSafeProperty
});
function cyclicDependencyError(token, path) {
  const message = ngDevMode ? `Circular dependency detected for \`${token}\`.` : '';
  return createRuntimeError(message, -200, path);
}
function cyclicDependencyErrorWithDetails(token, path) {
  return augmentRuntimeError(cyclicDependencyError(token, path), null);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.ɵfromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error('Invalid provider');
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;
  throw new RuntimeError(-201, errorMessage);
}
function prependTokenToDependencyPath(error, token) {
  error[NG_TOKEN_PATH] ??= [];
  const currentPath = error[NG_TOKEN_PATH];
  let pathStr;
  if (typeof token === 'object' && 'multi' in token && token?.multi === true) {
    assertDefined(token.provide, 'Token with multi: true should have a provide property');
    pathStr = stringifyForError(token.provide);
  } else {
    pathStr = stringifyForError(token);
  }
  if (currentPath[0] !== pathStr) {
    error[NG_TOKEN_PATH].unshift(pathStr);
  }
}
function augmentRuntimeError(error, source) {
  const tokenPath = error[NG_TOKEN_PATH];
  const errorCode = error[NG_RUNTIME_ERROR_CODE];
  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;
  error.message = formatErrorMessage(message, errorCode, tokenPath, source);
  return error;
}
function createRuntimeError(message, code, path) {
  const error = new RuntimeError(code, message);
  error[NG_RUNTIME_ERROR_CODE] = code;
  error[NG_RUNTIME_ERROR_MESSAGE] = message;
  if (path) {
    error[NG_TOKEN_PATH] = path;
  }
  return error;
}
function getRuntimeErrorCode(error) {
  return error[NG_RUNTIME_ERROR_CODE];
}
function formatErrorMessage(text, code, path = [], source = null) {
  let pathDetails = '';
  if (path && path.length > 1) {
    pathDetails = ` Path: ${path.join(' -> ')}.`;
  }
  const sourceDetails = source ? ` Source: ${source}.` : '';
  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);
}
let _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == 'root') {
    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & 8) return null;
  if (notFoundValue !== undefined) return notFoundValue;
  throwProviderNotFoundError(token, typeof ngDevMode !== 'undefined' && ngDevMode ? 'Injector' : '');
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');
}
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const DI_DECORATOR_FLAG = '__NG_DI_FLAG__';
class RetrievingInjector {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  retrieve(token, options) {
    const flags = convertToBitFlags(options) || 0;
    try {
      return this.injector.get(token, flags & 8 ? null : THROW_IF_NOT_FOUND, flags);
    } catch (e) {
      if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isNotFound)(e)) {
        return e;
      }
      throw e;
    }
  }
}
function injectInjectorOnly(token, flags = 0) {
  const currentInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCurrentInjector)();
  if (currentInjector === undefined) {
    throw new RuntimeError(-203, ngDevMode && `The \`${stringify(token)}\` token injection failed. \`inject()\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (currentInjector === null) {
    return injectRootLimpMode(token, undefined, flags);
  } else {
    const options = convertToInjectOptions(flags);
    const value = currentInjector.retrieve(token, options);
    ngDevMode && emitInjectEvent(token, value, flags);
    if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isNotFound)(value)) {
      if (options.optional) {
        return null;
      }
      throw value;
    }
    return value;
  }
}
function ɵɵinject(token, flags = 0) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function ɵɵinvalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, options) {
  return ɵɵinject(token, convertToBitFlags(options));
}
function convertToBitFlags(flags) {
  if (typeof flags === 'undefined' || typeof flags === 'number') {
    return flags;
  }
  return 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function convertToInjectOptions(flags) {
  return {
    optional: !!(flags & 8),
    host: !!(flags & 1),
    self: !!(flags & 2),
    skipSelf: !!(flags & 4)
  };
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && 'Arguments array must have arguments.');
      }
      let type = undefined;
      let flags = 0;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === 'number') {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(ɵɵinject(type, flags));
    } else {
      args.push(ɵɵinject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input, fn) {
  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count) {
  const length = array.length - count;
  while (index < length) {
    array[index] = array[index + count];
    index++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return undefined;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
const EMPTY_OBJ = {};
const EMPTY_ARRAY = [];
if ((typeof ngDevMode === 'undefined' || ngDevMode) && /*#__PURE__*/initNgDevMode()) {
  /*#__PURE__*/Object.freeze(EMPTY_OBJ);
  /*#__PURE__*/Object.freeze(EMPTY_ARRAY);
}
const ENVIRONMENT_INITIALIZER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');
const INJECTOR$1 = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR' : '', -1);
const INJECTOR_DEF_TYPES = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR_DEF_TYPES' : '');
class NullInjector {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const message = ngDevMode ? `No provider found for \`${stringify(token)}\`.` : '';
      const error = createRuntimeError(message, -201);
      error.name = 'ɵNotFound';
      throw error;
    }
    return notFoundValue;
  }
}
function makeEnvironmentProviders(providers) {
  return {
    ɵproviders: providers
  };
}
function provideEnvironmentInitializer(initializerFn) {
  return makeEnvironmentProviders([{
    provide: ENVIRONMENT_INITIALIZER,
    multi: true,
    useValue: initializerFn
  }]);
}
function importProvidersFrom(...sources) {
  return {
    ɵproviders: internalImportProvidersFrom(true, sources),
    ɵfromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = new Set();
  let injectorTypesWithProviders;
  const collectProviders = provider => {
    providersOut.push(provider);
  };
  deepForEach(sources, source => {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== undefined) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers
    } = typesWithProviders[i];
    deepForEachProvider(providers, provider => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container) return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify).concat(defName);
    throw cyclicDependencyErrorWithDetails(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, imported => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== undefined) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({
        provide: defType,
        useFactory: factory,
        deps: EMPTY_ARRAY
      }, defType);
      visitor({
        provide: INJECTOR_DEF_TYPES,
        useValue: defType,
        multi: true
      }, defType);
      visitor({
        provide: ENVIRONMENT_INITIALIZER,
        useValue: () => ɵɵinject(defType),
        multi: true
      }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, provider => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== undefined;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.ɵproviders;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
const USE_VALUE = /*#__PURE__*/getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value) {
  return value !== null && typeof value == 'object' && USE_VALUE in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === 'function';
}
function isClassProvider(value) {
  return !!value.useClass;
}
const INJECTOR_SCOPE = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Set Injector scope.' : '');
const NOT_YET = {};
const CIRCULAR = {};
let NULL_INJECTOR = undefined;
function getNullInjector() {
  if (NULL_INJECTOR === undefined) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
class EnvironmentInjector {}
class R3Injector extends EnvironmentInjector {
  parent;
  source;
  scopes;
  records = /*#__PURE__*/new Map();
  _ngOnDestroyHooks = /*#__PURE__*/new Set();
  _onDestroyHooks = [];
  get destroyed() {
    return this._destroyed;
  }
  _destroyed = false;
  injectorDefTypes;
  constructor(providers, parent, source, scopes) {
    super();
    this.parent = parent;
    this.source = source;
    this.scopes = scopes;
    forEachSingleProvider(providers, provider => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(undefined, this));
    if (scopes.has('environment')) {
      this.records.set(EnvironmentInjector, makeRecord(undefined, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === 'string') {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, {
      self: true
    }));
  }
  retrieve(token, options) {
    const flags = convertToBitFlags(options) || 0;
    try {
      return this.get(token, THROW_IF_NOT_FOUND, flags);
    } catch (e) {
      if ((0,_angular_core_primitives_di__WEBPACK_IMPORTED_MODULE_4__.isNotFound)(e)) {
        return e;
      }
      throw e;
    }
  }
  destroy() {
    assertNotDestroyed(this);
    this._destroyed = true;
    const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(prevConsumer);
    }
  }
  onDestroy(callback) {
    assertNotDestroyed(this);
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    assertNotDestroyed(this);
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      return fn();
    } finally {
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {
    assertNotDestroyed(this);
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    const flags = convertToBitFlags(options);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: token
      });
    }
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    try {
      if (!(flags & 4)) {
        let record = this.records.get(token);
        if (record === undefined) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record, flags);
        }
      }
      const nextInjector = !(flags & 2) ? this.parent : getNullInjector();
      notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (error) {
      const errorCode = getRuntimeErrorCode(error);
      if (errorCode === -200 || errorCode === -201) {
        if (ngDevMode) {
          prependTokenToDependencyPath(error, token);
          if (previousInjector) {
            throw error;
          } else {
            throw augmentRuntimeError(error, this.source);
          }
        } else {
          throw new RuntimeError(errorCode, null);
        }
      } else {
        throw error;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  resolveInjectorInitializers() {
    const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(null);
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, {
        self: true
      });
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(', ')}]`;
  }
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInjectorToCreateInstanceEvent(token);
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === undefined) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(undefined, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== undefined) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record, flags) {
    const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(null);
    try {
      if (record.value === CIRCULAR) {
        throw cyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            emitInjectorToCreateInstanceEvent(token);
            record.value = record.factory(undefined, flags);
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory(undefined, flags);
        }
      }
      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === 'string') {
      return providedIn === 'any' || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
}
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && 'unreachable');
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(undefined, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = undefined;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(undefined, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 ? 8 : undefined);
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function assertNotDestroyed(injector) {
  if (injector.destroyed) {
    throw new RuntimeError(205, ngDevMode && 'Injector has already been destroyed.');
  }
}
function makeRecord(factory, value, multi = false) {
  return {
    factory: factory,
    value: value,
    multi: multi ? [] : undefined
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';
}
function couldBeInjectableType(value) {
  return typeof value === 'function' || typeof value === 'object' && value.ngMetadataName === 'InjectionToken';
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.ɵproviders, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  let internalInjector;
  if (injector instanceof R3Injector) {
    assertNotDestroyed(injector);
    internalInjector = injector;
  } else {
    internalInjector = new RetrievingInjector(injector);
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
  }
  const prevInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(internalInjector);
  const previousInjectImplementation = setInjectImplementation(undefined);
  try {
    return fn();
  } finally {
    (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== undefined || (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCurrentInjector)() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');
  }
}
const HOST = 0;
const TVIEW = 1;
const FLAGS = 2;
const PARENT = 3;
const NEXT = 4;
const T_HOST = 5;
const HYDRATION = 6;
const CLEANUP = 7;
const CONTEXT = 8;
const INJECTOR = 9;
const ENVIRONMENT = 10;
const RENDERER = 11;
const CHILD_HEAD = 12;
const CHILD_TAIL = 13;
const DECLARATION_VIEW = 14;
const DECLARATION_COMPONENT_VIEW = 15;
const DECLARATION_LCONTAINER = 16;
const PREORDER_HOOK_FLAGS = 17;
const QUERIES = 18;
const ID = 19;
const EMBEDDED_VIEW_INJECTOR = 20;
const ON_DESTROY_HOOKS = 21;
const EFFECTS_TO_SCHEDULE = 22;
const EFFECTS = 23;
const REACTIVE_TEMPLATE_CONSUMER = 24;
const AFTER_RENDER_SEQUENCES_TO_ADD = 25;
const ANIMATIONS = 26;
const HEADER_OFFSET = 27;
const TYPE = 1;
const DEHYDRATED_VIEWS = 6;
const NATIVE = 7;
const VIEW_REFS = 8;
const MOVED_VIEWS = 9;
const CONTAINER_HEADER_OFFSET = 10;
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === 'object';
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isProjectionTNode(tNode) {
  return (tNode.type & 16) === 16;
}
function hasI18n(lView) {
  return (lView[FLAGS] & 32) === 32;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeCreationIndex(lView, index) {
  const adjustedIndex = index + HEADER_OFFSET;
  assertIndexInRange(lView, adjustedIndex);
  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError('This TNode does not belong to this TView.');
}
function assertTNode(tNode) {
  assertDefined(tNode, 'TNode must be defined');
  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {
    throwError('Not of type TNode, got: ' + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, 'Expected TIcu to be defined');
  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {
    throwError('Object is not of TIcu type.');
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'ɵcmp' property.") {
  if (!getComponentDef(actual)) {
    throwError(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have 'ɵmod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, 'currentTNode should exist!');
  assertDefined(tNode.parent, 'currentTNode should have a parent');
}
function assertLContainer(value) {
  assertDefined(value, 'LContainer must be defined');
  assertEqual(isLContainer(value), true, 'Expecting LContainer');
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
}
function assertLView(value) {
  assertDefined(value, 'LView must be defined');
  assertEqual(isLView(value), true, 'Expecting LView');
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');
}
function assertDirectiveDef(obj) {
  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {
    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, "Component views should always have a parent view (component's host view)");
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(lView, injectorIndex + 8);
  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');
}
const SVG_NAMESPACE = 'svg';
const MATH_ML_NAMESPACE = 'math';
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === 'object') return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getNativeByTNodeOrNull(tNode, lView) {
  const index = tNode === null ? -1 : tNode.index;
  if (index !== -1) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    const node = unwrapRNode(lView[index]);
    return node;
  }
  return null;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === undefined) return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(8);
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(0);
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if (isDestroyed(lView)) {
    throw new RuntimeError(911, ngDevMode && 'View has already been destroyed.');
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null) return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function storeCleanupWithContext(tView, lView, context, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');
  lCleanup.push(context);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
const instructionState = {
  lFrame: /*#__PURE__*/createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode = /*#__PURE__*/function (CheckNoChangesMode) {
  CheckNoChangesMode[CheckNoChangesMode["Off"] = 0] = "Off";
  CheckNoChangesMode[CheckNoChangesMode["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode[CheckNoChangesMode["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
  return CheckNoChangesMode;
}(CheckNoChangesMode || {});
let _checkNoChangesMode = 0;
let _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function ɵɵenableBindings() {
  instructionState.bindingsEnabled = true;
}
function enterSkipHydrationBlock(tNode) {
  instructionState.skipHydrationRootTNode = tNode;
}
function ɵɵdisableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function ɵɵrestoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function ɵɵresetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError('Must never be called in production mode');
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError('Must never be called in production mode');
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError('Must never be called in production mode');
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  const prev = _isRefreshingViews;
  _isRefreshingViews = mode;
  return prev;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock) {
  instructionState.lFrame.inI18n = isInI18nBlock;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & 4) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & 1)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null) break;
        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], '????');
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');
    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');
    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');
    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');
    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');
    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent: parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
const leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function ɵɵnamespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function ɵɵnamespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function ɵɵnamespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace() {
  return instructionState.lFrame.currentNamespace;
}
let _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === 'object' ? undefined : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
class Injector {
  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  static NULL = /*#__PURE__*/new NullInjector();
  static create(options, parent) {
    if (Array.isArray(options)) {
      return createInjector({
        name: ''
      }, parent, options, '');
    } else {
      const name = options.name ?? '';
      return createInjector({
        name
      }, options.parent, options.providers, name);
    }
  }
  static ɵprov = /* @__PURE__ */
  ɵɵdefineInjectable({
    token: Injector,
    providedIn: 'any',
    factory: () => ɵɵinject(INJECTOR$1)
  });
  static __NG_ELEMENT_ID__ = -1;
}
const DOCUMENT = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DocumentToken' : '');
let DestroyRef = /*#__PURE__*/(() => {
  class DestroyRef {
    static __NG_ELEMENT_ID__ = injectDestroyRef;
    static __NG_ENV_ID__ = injector => injector;
  }
  return DestroyRef;
})();
class NodeInjectorDestroyRef extends DestroyRef {
  _lView;
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  get destroyed() {
    return isDestroyed(this._lView);
  }
  onDestroy(callback) {
    const lView = this._lView;
    storeLViewOnDestroy(lView, callback);
    return () => removeLViewOnDestroy(lView, callback);
  }
}
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
const SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
const DEBUG_TASK_TRACKER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEBUG_TASK_TRACKER' : '');
let PendingTasksInternal = /*#__PURE__*/(() => {
  class PendingTasksInternal {
    taskId = 0;
    pendingTasks = new Set();
    destroyed = false;
    pendingTask = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject(false);
    debugTaskTracker = inject(DEBUG_TASK_TRACKER, {
      optional: true
    });
    get hasPendingTasks() {
      return this.destroyed ? false : this.pendingTask.value;
    }
    get hasPendingTasksObservable() {
      if (this.destroyed) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(subscriber => {
          subscriber.next(false);
          subscriber.complete();
        });
      }
      return this.pendingTask;
    }
    add() {
      if (!this.hasPendingTasks && !this.destroyed) {
        this.pendingTask.next(true);
      }
      const taskId = this.taskId++;
      this.pendingTasks.add(taskId);
      this.debugTaskTracker?.add(taskId);
      return taskId;
    }
    has(taskId) {
      return this.pendingTasks.has(taskId);
    }
    remove(taskId) {
      this.pendingTasks.delete(taskId);
      this.debugTaskTracker?.remove(taskId);
      if (this.pendingTasks.size === 0 && this.hasPendingTasks) {
        this.pendingTask.next(false);
      }
    }
    ngOnDestroy() {
      this.pendingTasks.clear();
      if (this.hasPendingTasks) {
        this.pendingTask.next(false);
      }
      this.destroyed = true;
      this.pendingTask.unsubscribe();
    }
    static ɵprov = /* @__PURE__ */
    ɵɵdefineInjectable({
      token: PendingTasksInternal,
      providedIn: 'root',
      factory: () => new PendingTasksInternal()
    });
  }
  return PendingTasksInternal;
})();
class EventEmitter_ extends rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject {
  __isAsync;
  destroyRef = undefined;
  pendingTasks = undefined;
  constructor(isAsync = false) {
    super();
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, {
        optional: true
      }) ?? undefined;
      this.pendingTasks = inject(PendingTasksInternal, {
        optional: true
      }) ?? undefined;
    }
  }
  emit(value) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      super.next(value);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === 'object') {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({
      next: nextFn,
      error: errorFn,
      complete: completeFn
    });
    if (observerOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return value => {
      const taskId = this.pendingTasks?.add();
      setTimeout(() => {
        try {
          fn(value);
        } finally {
          if (taskId !== undefined) {
            this.pendingTasks?.remove(taskId);
          }
        }
      });
    };
  }
}
const EventEmitter = EventEmitter_;
function noop(...args) {}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop;
    try {
      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== undefined) {
        clearTimeout(timeoutId);
      }
    } catch {}
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === 'function') {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop;
  };
}
class AsyncStackTaggingZoneSpec {
  createTask;
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = 'asyncStackTagging for ' + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  name;
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
}
const isAngularZoneProperty = 'isAngularZone';
const angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';
let ngZoneInstanceId = 0;
class NgZone {
  hasPendingMacrotasks = false;
  hasPendingMicrotasks = false;
  isStable = true;
  onUnstable = /*#__PURE__*/new EventEmitter(false);
  onMicrotaskEmpty = /*#__PURE__*/new EventEmitter(false);
  onStable = /*#__PURE__*/new EventEmitter(false);
  onError = /*#__PURE__*/new EventEmitter(false);
  constructor(options) {
    const {
      enableLongStackTrace = false,
      shouldCoalesceEventChangeDetection = false,
      shouldCoalesceRunChangeDetection = false,
      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT
    } = options;
    if (typeof Zone == 'undefined') {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));
    }
    if (Zone['TaskTrackingZoneSpec']) {
      self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());
    }
    if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
      self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    self.scheduleInRootZone = scheduleInRootZone;
    forkInnerZoneWithAngularBehavior(self);
  }
  static isInAngularZone() {
    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;
  }
  static assertInAngularZone() {
    if (!NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && 'Expected to be in Angular Zone, but it is not!');
    }
  }
  static assertNotInAngularZone() {
    if (NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && 'Expected to not be in Angular Zone, but it is!');
    }
  }
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
}
const EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: 'angular',
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == 'microTask') {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == 'macroTask') {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
class NoopNgZone {
  hasPendingMicrotasks = false;
  hasPendingMacrotasks = false;
  isStable = true;
  onUnstable = /*#__PURE__*/new EventEmitter();
  onMicrotaskEmpty = /*#__PURE__*/new EventEmitter();
  onStable = /*#__PURE__*/new EventEmitter();
  onError = /*#__PURE__*/new EventEmitter();
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
}
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, '__scheduler_tick__');
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
class ErrorHandler {
  _console = console;
  handleError(error) {
    this._console.error('ERROR', error);
  }
}
const INTERNAL_APPLICATION_ERROR_HANDLER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {
  factory: () => {
    const zone = inject(NgZone);
    const injector = inject(EnvironmentInjector);
    let userErrorHandler;
    return e => {
      zone.runOutsideAngular(() => {
        if (injector.destroyed && !userErrorHandler) {
          setTimeout(() => {
            throw e;
          });
        } else {
          userErrorHandler ??= injector.get(ErrorHandler);
          userErrorHandler.handleError(e);
        }
      });
    };
  }
});
const errorHandlerEnvironmentInitializer = {
  provide: ENVIRONMENT_INITIALIZER,
  useValue: () => {
    const handler = inject(ErrorHandler, {
      optional: true
    });
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && handler === null) {
      throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');
    }
  },
  multi: true
};
const globalErrorListeners = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'GlobalErrorListeners' : '', {
  factory: () => {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      return;
    }
    const window = inject(DOCUMENT).defaultView;
    if (!window) {
      return;
    }
    const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    const rejectionListener = e => {
      errorHandler(e.reason);
      e.preventDefault();
    };
    const errorListener = e => {
      if (e.error) {
        errorHandler(e.error);
      } else {
        errorHandler(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}` : e.message, {
          cause: e
        }));
      }
      e.preventDefault();
    };
    const setupEventListeners = () => {
      window.addEventListener('unhandledrejection', rejectionListener);
      window.addEventListener('error', errorListener);
    };
    if (typeof Zone !== 'undefined') {
      Zone.root.run(setupEventListeners);
    } else {
      setupEventListeners();
    }
    inject(DestroyRef).onDestroy(() => {
      window.removeEventListener('error', errorListener);
      window.removeEventListener('unhandledrejection', rejectionListener);
    });
  }
});
function provideBrowserGlobalErrorListeners() {
  return makeEnvironmentProviders([provideEnvironmentInitializer(() => void inject(globalErrorListeners))]);
}
function ɵunwrapWritableSignal(value) {
  return null;
}
function signal(initialValue, options) {
  const [get, set, update] = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createSignal)(initialValue, options?.equal);
  const signalFn = get;
  const node = signalFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  signalFn.set = set;
  signalFn.update = update;
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
    node.debugName = options?.debugName;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  if (node.readonlyFn === undefined) {
    const readonlyFn = () => this();
    readonlyFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function assertNotInReactiveContext(debugFn, extraContext) {
  if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getActiveConsumer)() !== null) {
    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);
  }
}
let ViewContext = /*#__PURE__*/(() => {
  class ViewContext {
    view;
    node;
    constructor(view, node) {
      this.view = view;
      this.node = node;
    }
    static __NG_ELEMENT_ID__ = injectViewContext;
  }
  return ViewContext;
})();
function injectViewContext() {
  return new ViewContext(getLView(), getCurrentTNode());
}
class ChangeDetectionScheduler {}
const ZONELESS_ENABLED = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', {
  factory: () => true
});
const PROVIDED_ZONELESS = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', {
  factory: () => false
});
const SCHEDULE_IN_ROOT_ZONE = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');
let PendingTasks = /*#__PURE__*/(() => {
  class PendingTasks {
    internalPendingTasks = inject(PendingTasksInternal);
    scheduler = inject(ChangeDetectionScheduler);
    errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    add() {
      const taskId = this.internalPendingTasks.add();
      return () => {
        if (!this.internalPendingTasks.has(taskId)) {
          return;
        }
        this.scheduler.notify(11);
        this.internalPendingTasks.remove(taskId);
      };
    }
    run(fn) {
      const removeTask = this.add();
      fn().catch(this.errorHandler).finally(removeTask);
    }
    static ɵprov = /* @__PURE__ */
    ɵɵdefineInjectable({
      token: PendingTasks,
      providedIn: 'root',
      factory: () => new PendingTasks()
    });
  }
  return PendingTasks;
})();
let EffectScheduler = /*#__PURE__*/(() => {
  class EffectScheduler {
    static ɵprov = /* @__PURE__ */
    ɵɵdefineInjectable({
      token: EffectScheduler,
      providedIn: 'root',
      factory: () => new ZoneAwareEffectScheduler()
    });
  }
  return EffectScheduler;
})();
class ZoneAwareEffectScheduler {
  dirtyEffectCount = 0;
  queues = /*#__PURE__*/new Map();
  add(handle) {
    this.enqueue(handle);
    this.schedule(handle);
  }
  schedule(handle) {
    if (!handle.dirty) {
      return;
    }
    this.dirtyEffectCount++;
  }
  remove(handle) {
    const zone = handle.zone;
    const queue = this.queues.get(zone);
    if (!queue.has(handle)) {
      return;
    }
    queue.delete(handle);
    if (handle.dirty) {
      this.dirtyEffectCount--;
    }
  }
  enqueue(handle) {
    const zone = handle.zone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    queue.add(handle);
  }
  flush() {
    while (this.dirtyEffectCount > 0) {
      let ranOneEffect = false;
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          ranOneEffect ||= this.flushQueue(queue);
        } else {
          ranOneEffect ||= zone.run(() => this.flushQueue(queue));
        }
      }
      if (!ranOneEffect) {
        this.dirtyEffectCount = 0;
      }
    }
  }
  flushQueue(queue) {
    let ranOneEffect = false;
    for (const handle of queue) {
      if (!handle.dirty) {
        continue;
      }
      this.dirtyEffectCount--;
      ranOneEffect = true;
      handle.run();
    }
    return ranOneEffect;
  }
}
class EffectRefImpl {
  [_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  constructor(node) {
    this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
  }
  destroy() {
    this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL].destroy();
  }
}
function effect(effectFn, options) {
  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(effect);
  }
  if (ngDevMode && options?.allowSignalWrites !== undefined) {
    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);
  }
  const injector = options?.injector ?? inject(Injector);
  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  let node;
  const viewContext = injector.get(ViewContext, null, {
    optional: true
  });
  const notifier = injector.get(ChangeDetectionScheduler);
  if (viewContext !== null) {
    node = createViewEffect(viewContext.view, notifier, effectFn);
    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {
      destroyRef = null;
    }
  } else {
    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);
  }
  node.injector = injector;
  if (destroyRef !== null) {
    node.onDestroyFns = [destroyRef.onDestroy(() => node.destroy())];
  }
  const effectRef = new EffectRefImpl(node);
  if (ngDevMode) {
    node.debugName = options?.debugName ?? '';
    const prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
    try {
      emitEffectCreatedEvent(effectRef);
    } finally {
      setInjectorProfilerContext(prevInjectorProfilerContext);
    }
  }
  return effectRef;
}
const EFFECT_NODE = /* @__PURE__ */(() => ({
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BASE_EFFECT_NODE,
  cleanupFns: undefined,
  zone: null,
  onDestroyFns: null,
  run() {
    if (ngDevMode && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isInNotificationPhase)()) {
      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);
    }
    const prevRefreshingViews = setIsRefreshingViews(false);
    try {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runEffect)(this);
    } finally {
      setIsRefreshingViews(prevRefreshingViews);
    }
  },
  cleanup() {
    if (!this.cleanupFns?.length) {
      return;
    }
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      while (this.cleanupFns.length) {
        this.cleanupFns.pop()();
      }
    } finally {
      this.cleanupFns = [];
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
}))();
const ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...EFFECT_NODE,
  consumerMarkedDirty() {
    this.scheduler.schedule(this);
    this.notifier.notify(12);
  },
  destroy() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerDestroy)(this);
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    this.cleanup();
    this.scheduler.remove(this);
  }
}))();
const VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...EFFECT_NODE,
  consumerMarkedDirty() {
    this.view[FLAGS] |= 8192;
    markAncestorsForTraversal(this.view);
    this.notifier.notify(13);
  },
  destroy() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerDestroy)(this);
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    this.cleanup();
    this.view[EFFECTS]?.delete(this);
  }
}))();
function createViewEffect(view, notifier, fn) {
  const node = Object.create(VIEW_EFFECT_NODE);
  node.view = view;
  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;
  node.notifier = notifier;
  node.fn = createEffectFn(node, fn);
  view[EFFECTS] ??= new Set();
  view[EFFECTS].add(node);
  node.consumerMarkedDirty(node);
  return node;
}
function createRootEffect(fn, scheduler, notifier) {
  const node = Object.create(ROOT_EFFECT_NODE);
  node.fn = createEffectFn(node, fn);
  node.scheduler = scheduler;
  node.notifier = notifier;
  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;
  node.scheduler.add(node);
  node.notifier.notify(12);
  return node;
}
function createEffectFn(node, fn) {
  return () => {
    fn(cleanupFn => (node.cleanupFns ??= []).push(cleanupFn));
  };
}
function untracked(nonReactiveReadsFn) {
  return (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.untracked)(nonReactiveReadsFn);
}


/***/ },

/***/ 13807
/*!***************************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/primitives-event-dispatch.mjs ***!
  \***************************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* reexport safe */ _attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Attribute),
/* harmony export */   EventContract: () => (/* binding */ EventContract),
/* harmony export */   EventContractContainer: () => (/* binding */ EventContractContainer),
/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher),
/* harmony export */   EventInfoWrapper: () => (/* binding */ EventInfoWrapper),
/* harmony export */   EventPhase: () => (/* binding */ EventPhase),
/* harmony export */   bootstrapAppScopedEarlyEventContract: () => (/* binding */ bootstrapAppScopedEarlyEventContract),
/* harmony export */   clearAppScopedEarlyEventContract: () => (/* binding */ clearAppScopedEarlyEventContract),
/* harmony export */   getActionCache: () => (/* binding */ getDefaulted),
/* harmony export */   getAppScopedQueuedEventInfos: () => (/* binding */ getAppScopedQueuedEventInfos),
/* harmony export */   isCaptureEventType: () => (/* binding */ isCaptureEventType),
/* harmony export */   isEarlyEventType: () => (/* binding */ isEarlyEventType),
/* harmony export */   registerAppScopedDispatcher: () => (/* binding */ registerAppScopedDispatcher),
/* harmony export */   registerDispatcher: () => (/* binding */ registerDispatcher$1),
/* harmony export */   removeAllAppScopedEventListeners: () => (/* binding */ removeAllAppScopedEventListeners)
/* harmony export */ });
/* harmony import */ var _attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_attribute-chunk.mjs */ 66248);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */


const Property = {
  JSACTION: '__jsaction',
  OWNER: '__owner'
};
const parseCache = {};
function get(element) {
  return element[Property.JSACTION];
}
function getDefaulted(element) {
  const cache = get(element) ?? {};
  set(element, cache);
  return cache;
}
function set(element, actionMap) {
  element[Property.JSACTION] = actionMap;
}
function getParsed(text) {
  return parseCache[text];
}
function setParsed(text, parsed) {
  parseCache[text] = parsed;
}
const EventType = {
  AUXCLICK: 'auxclick',
  CHANGE: 'change',
  CLICK: 'click',
  CLICKMOD: 'clickmod',
  CLICKONLY: 'clickonly',
  DBLCLICK: 'dblclick',
  FOCUS: 'focus',
  FOCUSIN: 'focusin',
  BLUR: 'blur',
  FOCUSOUT: 'focusout',
  SUBMIT: 'submit',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  KEYUP: 'keyup',
  MOUSEUP: 'mouseup',
  MOUSEDOWN: 'mousedown',
  MOUSEOVER: 'mouseover',
  MOUSEOUT: 'mouseout',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',
  MOUSEMOVE: 'mousemove',
  POINTERUP: 'pointerup',
  POINTERDOWN: 'pointerdown',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERMOVE: 'pointermove',
  POINTERCANCEL: 'pointercancel',
  GOTPOINTERCAPTURE: 'gotpointercapture',
  LOSTPOINTERCAPTURE: 'lostpointercapture',
  ERROR: 'error',
  LOAD: 'load',
  UNLOAD: 'unload',
  TOUCHSTART: 'touchstart',
  TOUCHEND: 'touchend',
  TOUCHMOVE: 'touchmove',
  INPUT: 'input',
  SCROLL: 'scroll',
  TOGGLE: 'toggle',
  CUSTOM: '_custom'
};
const MOUSE_SPECIAL_EVENT_TYPES = [EventType.MOUSEENTER, EventType.MOUSELEAVE, 'pointerenter', 'pointerleave'];
const BUBBLE_EVENT_TYPES = [EventType.CLICK, EventType.DBLCLICK, EventType.FOCUSIN, EventType.FOCUSOUT, EventType.KEYDOWN, EventType.KEYUP, EventType.KEYPRESS, EventType.MOUSEOVER, EventType.MOUSEOUT, EventType.SUBMIT, EventType.TOUCHSTART, EventType.TOUCHEND, EventType.TOUCHMOVE, 'touchcancel', 'auxclick', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'beforeinput', 'input', 'select', 'copy', 'cut', 'paste', 'mousedown', 'mouseup', 'wheel', 'contextmenu', 'dragover', 'dragenter', 'dragleave', 'drop', 'dragstart', 'dragend', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'gotpointercapture', 'lostpointercapture', 'ended', 'loadedmetadata', 'pagehide', 'pageshow', 'visibilitychange', 'beforematch'];
const CAPTURE_EVENT_TYPES = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];
const isCaptureEventType = eventType => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;
const EARLY_EVENT_TYPES = /*#__PURE__*/BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);
const isEarlyEventType = eventType => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;
function getBrowserEventType(eventType) {
  if (eventType === EventType.MOUSEENTER) {
    return EventType.MOUSEOVER;
  } else if (eventType === EventType.MOUSELEAVE) {
    return EventType.MOUSEOUT;
  } else if (eventType === EventType.POINTERENTER) {
    return EventType.POINTEROVER;
  } else if (eventType === EventType.POINTERLEAVE) {
    return EventType.POINTEROUT;
  }
  return eventType;
}
function addEventListener(element, eventType, handler, passive) {
  let capture = false;
  if (isCaptureEventType(eventType)) {
    capture = true;
  }
  const options = typeof passive === 'boolean' ? {
    capture,
    passive
  } : capture;
  element.addEventListener(eventType, handler, options);
  return {
    eventType,
    handler,
    capture,
    passive
  };
}
function removeEventListener(element, info) {
  if (element.removeEventListener) {
    const options = typeof info.passive === 'boolean' ? {
      capture: info.capture
    } : info.capture;
    element.removeEventListener(info.eventType, info.handler, options);
  } else if (element.detachEvent) {
    element.detachEvent(`on${info.eventType}`, info.handler);
  }
}
function preventDefault(e) {
  e.preventDefault ? e.preventDefault() : e.returnValue = false;
}
let isMac = typeof navigator !== 'undefined' && /*#__PURE__*//Macintosh/.test(navigator.userAgent);
function isMiddleClick(e) {
  return e.which === 2 || e.which == null && e.button === 4;
}
function isModifiedClickEvent(e) {
  return isMac && e.metaKey || !isMac && e.ctrlKey || isMiddleClick(e) || e.shiftKey;
}
function isMouseSpecialEvent(e, type, element) {
  const related = e.relatedTarget;
  return (e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER || e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE || e.type === EventType.POINTEROVER && type === EventType.POINTERENTER || e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE) && (!related || related !== element && !element.contains(related));
}
function createMouseSpecialEvent(e, target) {
  const copy = {};
  for (const property in e) {
    if (property === 'srcElement' || property === 'target') {
      continue;
    }
    const key = property;
    const value = e[key];
    if (typeof value === 'function') {
      continue;
    }
    copy[key] = value;
  }
  if (e.type === EventType.MOUSEOVER) {
    copy['type'] = EventType.MOUSEENTER;
  } else if (e.type === EventType.MOUSEOUT) {
    copy['type'] = EventType.MOUSELEAVE;
  } else if (e.type === EventType.POINTEROVER) {
    copy['type'] = EventType.POINTERENTER;
  } else {
    copy['type'] = EventType.POINTERLEAVE;
  }
  copy['target'] = copy['srcElement'] = target;
  copy['bubbles'] = false;
  copy['_originalEvent'] = e;
  return copy;
}
const isIos = typeof navigator !== 'undefined' && /*#__PURE__*//iPhone|iPad|iPod/.test(navigator.userAgent);
class EventContractContainer {
  element;
  handlerInfos = [];
  constructor(element) {
    this.element = element;
  }
  addEventListener(eventType, getHandler, passive) {
    if (isIos) {
      this.element.style.cursor = 'pointer';
    }
    this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element), passive));
  }
  cleanUp() {
    for (let i = 0; i < this.handlerInfos.length; i++) {
      removeEventListener(this.element, this.handlerInfos[i]);
    }
    this.handlerInfos = [];
  }
}
const Char = {
  NAMESPACE_ACTION_SEPARATOR: '.',
  EVENT_ACTION_SEPARATOR: ':'
};
function getEventType(eventInfo) {
  return eventInfo.eventType;
}
function setEventType(eventInfo, eventType) {
  eventInfo.eventType = eventType;
}
function getEvent(eventInfo) {
  return eventInfo.event;
}
function setEvent(eventInfo, event) {
  eventInfo.event = event;
}
function getTargetElement(eventInfo) {
  return eventInfo.targetElement;
}
function setTargetElement(eventInfo, targetElement) {
  eventInfo.targetElement = targetElement;
}
function getContainer(eventInfo) {
  return eventInfo.eic;
}
function setContainer(eventInfo, container) {
  eventInfo.eic = container;
}
function getTimestamp(eventInfo) {
  return eventInfo.timeStamp;
}
function setTimestamp(eventInfo, timestamp) {
  eventInfo.timeStamp = timestamp;
}
function getAction(eventInfo) {
  return eventInfo.eia;
}
function setAction(eventInfo, actionName, actionElement) {
  eventInfo.eia = [actionName, actionElement];
}
function unsetAction(eventInfo) {
  eventInfo.eia = undefined;
}
function getActionElement(actionInfo) {
  return actionInfo[1];
}
function getIsReplay(eventInfo) {
  return eventInfo.eirp;
}
function setIsReplay(eventInfo, replay) {
  eventInfo.eirp = replay;
}
function getResolved(eventInfo) {
  return eventInfo.eir;
}
function setResolved(eventInfo, resolved) {
  eventInfo.eir = resolved;
}
function cloneEventInfo(eventInfo) {
  return {
    eventType: eventInfo.eventType,
    event: eventInfo.event,
    targetElement: eventInfo.targetElement,
    eic: eventInfo.eic,
    eia: eventInfo.eia,
    timeStamp: eventInfo.timeStamp,
    eirp: eventInfo.eirp,
    eiack: eventInfo.eiack,
    eir: eventInfo.eir
  };
}
function createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {
  return {
    eventType,
    event,
    targetElement,
    eic: container,
    timeStamp: timestamp,
    eia: action,
    eirp: isReplay,
    eiack: a11yClickKey
  };
}
class EventInfoWrapper {
  eventInfo;
  constructor(eventInfo) {
    this.eventInfo = eventInfo;
  }
  getEventType() {
    return getEventType(this.eventInfo);
  }
  setEventType(eventType) {
    setEventType(this.eventInfo, eventType);
  }
  getEvent() {
    return getEvent(this.eventInfo);
  }
  setEvent(event) {
    setEvent(this.eventInfo, event);
  }
  getTargetElement() {
    return getTargetElement(this.eventInfo);
  }
  setTargetElement(targetElement) {
    setTargetElement(this.eventInfo, targetElement);
  }
  getContainer() {
    return getContainer(this.eventInfo);
  }
  setContainer(container) {
    setContainer(this.eventInfo, container);
  }
  getTimestamp() {
    return getTimestamp(this.eventInfo);
  }
  setTimestamp(timestamp) {
    setTimestamp(this.eventInfo, timestamp);
  }
  getAction() {
    const action = getAction(this.eventInfo);
    if (!action) return undefined;
    return {
      name: action[0],
      element: action[1]
    };
  }
  setAction(action) {
    if (!action) {
      unsetAction(this.eventInfo);
      return;
    }
    setAction(this.eventInfo, action.name, action.element);
  }
  getIsReplay() {
    return getIsReplay(this.eventInfo);
  }
  setIsReplay(replay) {
    setIsReplay(this.eventInfo, replay);
  }
  getResolved() {
    return getResolved(this.eventInfo);
  }
  setResolved(resolved) {
    setResolved(this.eventInfo, resolved);
  }
  clone() {
    return new EventInfoWrapper(cloneEventInfo(this.eventInfo));
  }
}
const EMPTY_ACTION_MAP = {};
const REGEXP_SEMICOLON = /\s*;\s*/;
const DEFAULT_EVENT_TYPE = EventType.CLICK;
class ActionResolver {
  a11yClickSupport = false;
  clickModSupport = true;
  syntheticMouseEventSupport;
  updateEventInfoForA11yClick = undefined;
  preventDefaultForA11yClick = undefined;
  populateClickOnlyAction = undefined;
  constructor({
    syntheticMouseEventSupport = false,
    clickModSupport = true
  } = {}) {
    this.syntheticMouseEventSupport = syntheticMouseEventSupport;
    this.clickModSupport = clickModSupport;
  }
  resolveEventType(eventInfo) {
    if (this.clickModSupport && getEventType(eventInfo) === EventType.CLICK && isModifiedClickEvent(getEvent(eventInfo))) {
      setEventType(eventInfo, EventType.CLICKMOD);
    } else if (this.a11yClickSupport) {
      this.updateEventInfoForA11yClick(eventInfo);
    }
  }
  resolveAction(eventInfo) {
    if (getResolved(eventInfo)) {
      return;
    }
    this.populateAction(eventInfo, getTargetElement(eventInfo));
    setResolved(eventInfo, true);
  }
  resolveParentAction(eventInfo) {
    const action = getAction(eventInfo);
    const actionElement = action && getActionElement(action);
    unsetAction(eventInfo);
    const parentNode = actionElement && this.getParentNode(actionElement);
    if (!parentNode) {
      return;
    }
    this.populateAction(eventInfo, parentNode);
  }
  populateAction(eventInfo, currentTarget) {
    let actionElement = currentTarget;
    while (actionElement && actionElement !== getContainer(eventInfo)) {
      if (actionElement.nodeType === Node.ELEMENT_NODE) {
        this.populateActionOnElement(actionElement, eventInfo);
      }
      if (getAction(eventInfo)) {
        break;
      }
      actionElement = this.getParentNode(actionElement);
    }
    const action = getAction(eventInfo);
    if (!action) {
      return;
    }
    if (this.a11yClickSupport) {
      this.preventDefaultForA11yClick(eventInfo);
    }
    if (this.syntheticMouseEventSupport) {
      if (getEventType(eventInfo) === EventType.MOUSEENTER || getEventType(eventInfo) === EventType.MOUSELEAVE || getEventType(eventInfo) === EventType.POINTERENTER || getEventType(eventInfo) === EventType.POINTERLEAVE) {
        if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {
          const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));
          setEvent(eventInfo, copiedEvent);
          setTargetElement(eventInfo, getActionElement(action));
        } else {
          unsetAction(eventInfo);
        }
      }
    }
  }
  getParentNode(element) {
    const owner = element[Property.OWNER];
    if (owner) {
      return owner;
    }
    const parentNode = element.parentNode;
    if (parentNode?.nodeName === '#document-fragment') {
      return parentNode?.host ?? null;
    }
    return parentNode;
  }
  populateActionOnElement(actionElement, eventInfo) {
    const actionMap = this.parseActions(actionElement);
    const actionName = actionMap[getEventType(eventInfo)];
    if (actionName !== undefined) {
      setAction(eventInfo, actionName, actionElement);
    }
    if (this.a11yClickSupport) {
      this.populateClickOnlyAction(actionElement, eventInfo, actionMap);
    }
  }
  parseActions(actionElement) {
    let actionMap = get(actionElement);
    if (!actionMap) {
      const jsactionAttribute = actionElement.getAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Attribute.JSACTION);
      if (!jsactionAttribute) {
        actionMap = EMPTY_ACTION_MAP;
        set(actionElement, actionMap);
      } else {
        actionMap = getParsed(jsactionAttribute);
        if (!actionMap) {
          actionMap = {};
          const values = jsactionAttribute.split(REGEXP_SEMICOLON);
          for (let idx = 0; idx < values.length; idx++) {
            const value = values[idx];
            if (!value) {
              continue;
            }
            const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);
            const hasColon = colon !== -1;
            const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;
            const action = hasColon ? value.substr(colon + 1).trim() : value;
            actionMap[type] = action;
          }
          setParsed(jsactionAttribute, actionMap);
        }
        set(actionElement, actionMap);
      }
    }
    return actionMap;
  }
  addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {
    this.a11yClickSupport = true;
    this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;
    this.preventDefaultForA11yClick = preventDefaultForA11yClick;
    this.populateClickOnlyAction = populateClickOnlyAction;
  }
}
var Restriction = /*#__PURE__*/function (Restriction) {
  Restriction[Restriction["I_AM_THE_JSACTION_FRAMEWORK"] = 0] = "I_AM_THE_JSACTION_FRAMEWORK";
  return Restriction;
}(Restriction || {});
class Dispatcher {
  dispatchDelegate;
  actionResolver;
  eventReplayer;
  eventReplayScheduled = false;
  replayEventInfoWrappers = [];
  constructor(dispatchDelegate, {
    actionResolver,
    eventReplayer
  } = {}) {
    this.dispatchDelegate = dispatchDelegate;
    this.actionResolver = actionResolver;
    this.eventReplayer = eventReplayer;
  }
  dispatch(eventInfo) {
    const eventInfoWrapper = new EventInfoWrapper(eventInfo);
    this.actionResolver?.resolveEventType(eventInfo);
    this.actionResolver?.resolveAction(eventInfo);
    const action = eventInfoWrapper.getAction();
    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {
      preventDefault(eventInfoWrapper.getEvent());
    }
    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {
      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);
      return;
    }
    this.dispatchDelegate(eventInfoWrapper);
  }
  scheduleEventInfoWrapperReplay(eventInfoWrapper) {
    this.replayEventInfoWrappers.push(eventInfoWrapper);
    if (this.eventReplayScheduled) {
      return;
    }
    this.eventReplayScheduled = true;
    Promise.resolve().then(() => {
      this.eventReplayScheduled = false;
      this.eventReplayer(this.replayEventInfoWrappers);
    });
  }
}
function shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {
  return actionElement.tagName === 'A' && (eventInfoWrapper.getEventType() === EventType.CLICK || eventInfoWrapper.getEventType() === EventType.CLICKMOD);
}
const PROPAGATION_STOPPED_SYMBOL = /* @__PURE__ */Symbol.for('propagationStopped');
const EventPhase = {
  REPLAY: 101
};
const PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' + 'effect. You can check whether an event is being replayed by accessing the event phase: ' + '`event.eventPhase === EventPhase.REPLAY`.';
const PREVENT_DEFAULT_ERROR_MESSAGE = `\`preventDefault\` called during event replay.`;
const COMPOSED_PATH_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser ' + 'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' + '`event.currentTarget` if you need to check elements in the event path.';
const COMPOSED_PATH_ERROR_MESSAGE = `\`composedPath\` called during event replay.`;
class EventDispatcher {
  dispatchDelegate;
  clickModSupport;
  actionResolver;
  dispatcher;
  constructor(dispatchDelegate, clickModSupport = true) {
    this.dispatchDelegate = dispatchDelegate;
    this.clickModSupport = clickModSupport;
    this.actionResolver = new ActionResolver({
      clickModSupport
    });
    this.dispatcher = new Dispatcher(eventInfoWrapper => {
      this.dispatchToDelegate(eventInfoWrapper);
    }, {
      actionResolver: this.actionResolver
    });
  }
  dispatch(eventInfo) {
    this.dispatcher.dispatch(eventInfo);
  }
  dispatchToDelegate(eventInfoWrapper) {
    if (eventInfoWrapper.getIsReplay()) {
      prepareEventForReplay(eventInfoWrapper);
    }
    prepareEventForBubbling(eventInfoWrapper);
    while (eventInfoWrapper.getAction()) {
      prepareEventForDispatch(eventInfoWrapper);
      if (isCaptureEventType(eventInfoWrapper.getEventType()) && eventInfoWrapper.getAction().element !== eventInfoWrapper.getTargetElement()) {
        return;
      }
      this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);
      if (propagationStopped(eventInfoWrapper)) {
        return;
      }
      this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);
    }
  }
}
function prepareEventForBubbling(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);
  const stopPropagation = () => {
    event[PROPAGATION_STOPPED_SYMBOL] = true;
    originalStopPropagation();
  };
  patchEventInstance(event, 'stopPropagation', stopPropagation);
  patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);
}
function propagationStopped(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  return !!event[PROPAGATION_STOPPED_SYMBOL];
}
function prepareEventForReplay(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const target = eventInfoWrapper.getTargetElement();
  const originalPreventDefault = event.preventDefault.bind(event);
  patchEventInstance(event, 'target', target);
  patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);
  patchEventInstance(event, 'preventDefault', () => {
    originalPreventDefault();
    throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));
  });
  patchEventInstance(event, 'composedPath', () => {
    throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));
  });
}
function prepareEventForDispatch(eventInfoWrapper) {
  const event = eventInfoWrapper.getEvent();
  const currentTarget = eventInfoWrapper.getAction()?.element;
  if (currentTarget) {
    patchEventInstance(event, 'currentTarget', currentTarget, {
      configurable: true
    });
  }
}
function patchEventInstance(event, property, value, {
  configurable = false
} = {}) {
  Object.defineProperty(event, property, {
    value,
    configurable
  });
}
function registerDispatcher$1(eventContract, dispatcher) {
  eventContract.ecrd(eventInfo => {
    dispatcher.dispatch(eventInfo);
  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);
}
function createEarlyJsactionData(container) {
  const q = [];
  const d = eventInfo => {
    q.push(eventInfo);
  };
  const h = event => {
    d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));
  };
  return {
    c: container,
    q,
    et: [],
    etc: [],
    d,
    h
  };
}
function addEvents(earlyJsactionData, types, capture) {
  for (let i = 0; i < types.length; i++) {
    const eventType = types[i];
    const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;
    eventTypes.push(eventType);
    earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);
  }
}
function getQueuedEventInfos(earlyJsactionData) {
  return earlyJsactionData?.q ?? [];
}
function registerDispatcher(earlyJsactionData, dispatcher) {
  if (!earlyJsactionData) {
    return;
  }
  earlyJsactionData.d = dispatcher;
}
function removeAllEventListeners(earlyJsactionData) {
  if (!earlyJsactionData) {
    return;
  }
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);
  removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);
}
function removeEventListeners(container, eventTypes, earlyEventHandler, capture) {
  for (let i = 0; i < eventTypes.length; i++) {
    container.removeEventListener(eventTypes[i], earlyEventHandler, capture);
  }
}
const MOUSE_SPECIAL_SUPPORT = false;
let EventContract = /*#__PURE__*/(() => {
  class EventContract {
    static MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;
    containerManager;
    eventHandlers = {};
    browserEventTypeToExtraEventTypes = {};
    dispatcher = null;
    queuedEventInfos = [];
    constructor(containerManager) {
      this.containerManager = containerManager;
    }
    handleEvent(eventType, event, container) {
      const eventInfo = createEventInfoFromParameters(eventType, event, event.target, container, Date.now());
      this.handleEventInfo(eventInfo);
    }
    handleEventInfo(eventInfo) {
      if (!this.dispatcher) {
        setIsReplay(eventInfo, true);
        this.queuedEventInfos?.push(eventInfo);
        return;
      }
      this.dispatcher(eventInfo);
    }
    addEvent(eventType, prefixedEventType, passive) {
      if (eventType in this.eventHandlers || !this.containerManager) {
        return;
      }
      if (!EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {
        return;
      }
      const eventHandler = (eventType, event, container) => {
        this.handleEvent(eventType, event, container);
      };
      this.eventHandlers[eventType] = eventHandler;
      const browserEventType = getBrowserEventType(prefixedEventType || eventType);
      if (browserEventType !== eventType) {
        const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];
        eventTypes.push(eventType);
        this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;
      }
      this.containerManager.addEventListener(browserEventType, element => {
        return event => {
          eventHandler(eventType, event, element);
        };
      }, passive);
    }
    replayEarlyEvents(earlyJsactionData = window._ejsa) {
      if (!earlyJsactionData) {
        return;
      }
      this.replayEarlyEventInfos(earlyJsactionData.q);
      removeAllEventListeners(earlyJsactionData);
      delete window._ejsa;
    }
    replayEarlyEventInfos(earlyEventInfos) {
      for (let i = 0; i < earlyEventInfos.length; i++) {
        const earlyEventInfo = earlyEventInfos[i];
        const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);
        for (let j = 0; j < eventTypes.length; j++) {
          const eventInfo = cloneEventInfo(earlyEventInfo);
          setEventType(eventInfo, eventTypes[j]);
          this.handleEventInfo(eventInfo);
        }
      }
    }
    getEventTypesForBrowserEventType(browserEventType) {
      const eventTypes = [];
      if (this.eventHandlers[browserEventType]) {
        eventTypes.push(browserEventType);
      }
      if (this.browserEventTypeToExtraEventTypes[browserEventType]) {
        eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);
      }
      return eventTypes;
    }
    handler(eventType) {
      return this.eventHandlers[eventType];
    }
    cleanUp() {
      this.containerManager?.cleanUp();
      this.containerManager = null;
      this.eventHandlers = {};
      this.browserEventTypeToExtraEventTypes = {};
      this.dispatcher = null;
      this.queuedEventInfos = [];
    }
    registerDispatcher(dispatcher, restriction) {
      this.ecrd(dispatcher, restriction);
    }
    ecrd(dispatcher, restriction) {
      this.dispatcher = dispatcher;
      if (this.queuedEventInfos?.length) {
        for (let i = 0; i < this.queuedEventInfos.length; i++) {
          this.handleEventInfo(this.queuedEventInfos[i]);
        }
        this.queuedEventInfos = null;
      }
    }
  }
  return EventContract;
})();
function bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {
  const earlyJsactionData = createEarlyJsactionData(container);
  if (!dataContainer._ejsas) {
    dataContainer._ejsas = {};
  }
  dataContainer._ejsas[appId] = earlyJsactionData;
  addEvents(earlyJsactionData, bubbleEventTypes);
  addEvents(earlyJsactionData, captureEventTypes, true);
}
function getAppScopedQueuedEventInfos(appId, dataContainer = window) {
  return getQueuedEventInfos(dataContainer._ejsas?.[appId]);
}
function registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {
  registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);
}
function removeAllAppScopedEventListeners(appId, dataContainer = window) {
  removeAllEventListeners(dataContainer._ejsas?.[appId]);
}
function clearAppScopedEarlyEventContract(appId, dataContainer = window) {
  if (!dataContainer._ejsas) {
    return;
  }
  dataContainer._ejsas[appId] = undefined;
}


/***/ },

/***/ 29843
/*!***************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_effect-chunk.mjs ***!
  \***************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_EFFECT_NODE: () => (/* binding */ BASE_EFFECT_NODE),
/* harmony export */   COMPUTING: () => (/* binding */ COMPUTING),
/* harmony export */   ERRORED: () => (/* binding */ ERRORED),
/* harmony export */   REACTIVE_NODE: () => (/* binding */ REACTIVE_NODE),
/* harmony export */   SIGNAL: () => (/* binding */ SIGNAL),
/* harmony export */   SIGNAL_NODE: () => (/* binding */ SIGNAL_NODE),
/* harmony export */   UNSET: () => (/* binding */ UNSET),
/* harmony export */   consumerAfterComputation: () => (/* binding */ consumerAfterComputation),
/* harmony export */   consumerBeforeComputation: () => (/* binding */ consumerBeforeComputation),
/* harmony export */   consumerDestroy: () => (/* binding */ consumerDestroy),
/* harmony export */   consumerMarkDirty: () => (/* binding */ consumerMarkDirty),
/* harmony export */   consumerPollProducersForChange: () => (/* binding */ consumerPollProducersForChange),
/* harmony export */   createComputed: () => (/* binding */ createComputed),
/* harmony export */   createSignal: () => (/* binding */ createSignal),
/* harmony export */   defaultEquals: () => (/* binding */ defaultEquals),
/* harmony export */   finalizeConsumerAfterComputation: () => (/* binding */ finalizeConsumerAfterComputation),
/* harmony export */   getActiveConsumer: () => (/* binding */ getActiveConsumer),
/* harmony export */   isInNotificationPhase: () => (/* binding */ isInNotificationPhase),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   producerAccessed: () => (/* binding */ producerAccessed),
/* harmony export */   producerIncrementEpoch: () => (/* binding */ producerIncrementEpoch),
/* harmony export */   producerMarkClean: () => (/* binding */ producerMarkClean),
/* harmony export */   producerNotifyConsumers: () => (/* binding */ producerNotifyConsumers),
/* harmony export */   producerUpdateValueVersion: () => (/* binding */ producerUpdateValueVersion),
/* harmony export */   producerUpdatesAllowed: () => (/* binding */ producerUpdatesAllowed),
/* harmony export */   resetConsumerBeforeComputation: () => (/* binding */ resetConsumerBeforeComputation),
/* harmony export */   runEffect: () => (/* binding */ runEffect),
/* harmony export */   runPostProducerCreatedFn: () => (/* binding */ runPostProducerCreatedFn),
/* harmony export */   runPostSignalSetFn: () => (/* binding */ runPostSignalSetFn),
/* harmony export */   setActiveConsumer: () => (/* binding */ setActiveConsumer),
/* harmony export */   setPostProducerCreatedFn: () => (/* binding */ setPostProducerCreatedFn),
/* harmony export */   setPostSignalSetFn: () => (/* binding */ setPostSignalSetFn),
/* harmony export */   setThrowInvalidWriteToSignalError: () => (/* binding */ setThrowInvalidWriteToSignalError),
/* harmony export */   signalGetFn: () => (/* binding */ signalGetFn),
/* harmony export */   signalSetFn: () => (/* binding */ signalSetFn),
/* harmony export */   signalUpdateFn: () => (/* binding */ signalUpdateFn),
/* harmony export */   untracked: () => (/* binding */ untracked)
/* harmony export */ });
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

let activeConsumer = null;
let inNotificationPhase = false;
let epoch = 1;
let postProducerCreatedFn = null;
const SIGNAL = /* @__PURE__ */Symbol('SIGNAL');
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
function isReactive(value) {
  return value[SIGNAL] !== undefined;
}
const REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producers: undefined,
  producersTail: undefined,
  consumers: undefined,
  consumersTail: undefined,
  recomputing: false,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  kind: 'unknown',
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {},
  consumerMarkedDirty: () => {},
  consumerOnSignalRead: () => {}
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const prevProducerLink = activeConsumer.producersTail;
  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {
    return;
  }
  let nextProducerLink = undefined;
  const isRecomputing = activeConsumer.recomputing;
  if (isRecomputing) {
    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;
    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {
      activeConsumer.producersTail = nextProducerLink;
      nextProducerLink.lastReadVersion = node.version;
      return;
    }
  }
  const prevConsumerLink = node.consumersTail;
  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {
    return;
  }
  const isLive = consumerIsLive(activeConsumer);
  const newLink = {
    producer: node,
    consumer: activeConsumer,
    nextProducer: nextProducerLink,
    prevConsumer: prevConsumerLink,
    lastReadVersion: node.version,
    nextConsumer: undefined
  };
  activeConsumer.producersTail = newLink;
  if (prevProducerLink !== undefined) {
    prevProducerLink.nextProducer = newLink;
  } else {
    activeConsumer.producers = newLink;
  }
  if (isLive) {
    producerAddLiveConsumer(node, newLink);
  }
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    producerMarkClean(node);
    return;
  }
  node.producerRecomputeValue(node);
  producerMarkClean(node);
}
function producerNotifyConsumers(node) {
  if (node.consumers === undefined) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {
      const consumer = link.consumer;
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function producerMarkClean(node) {
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function consumerBeforeComputation(node) {
  if (node) resetConsumerBeforeComputation(node);
  return setActiveConsumer(node);
}
function resetConsumerBeforeComputation(node) {
  node.producersTail = undefined;
  node.recomputing = true;
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (node) finalizeConsumerAfterComputation(node);
}
function finalizeConsumerAfterComputation(node) {
  node.recomputing = false;
  const producersTail = node.producersTail;
  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;
  if (toRemove !== undefined) {
    if (consumerIsLive(node)) {
      do {
        toRemove = producerRemoveLiveConsumerLink(toRemove);
      } while (toRemove !== undefined);
    }
    if (producersTail !== undefined) {
      producersTail.nextProducer = undefined;
    } else {
      node.producers = undefined;
    }
  }
}
function consumerPollProducersForChange(node) {
  for (let link = node.producers; link !== undefined; link = link.nextProducer) {
    const producer = link.producer;
    const seenVersion = link.lastReadVersion;
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  if (consumerIsLive(node)) {
    let link = node.producers;
    while (link !== undefined) {
      link = producerRemoveLiveConsumerLink(link);
    }
  }
  node.producers = undefined;
  node.producersTail = undefined;
  node.consumers = undefined;
  node.consumersTail = undefined;
}
function producerAddLiveConsumer(node, link) {
  const consumersTail = node.consumersTail;
  const wasLive = consumerIsLive(node);
  if (consumersTail !== undefined) {
    link.nextConsumer = consumersTail.nextConsumer;
    consumersTail.nextConsumer = link;
  } else {
    link.nextConsumer = undefined;
    node.consumers = link;
  }
  link.prevConsumer = consumersTail;
  node.consumersTail = link;
  if (!wasLive) {
    for (let link = node.producers; link !== undefined; link = link.nextProducer) {
      producerAddLiveConsumer(link.producer, link);
    }
  }
}
function producerRemoveLiveConsumerLink(link) {
  const producer = link.producer;
  const nextProducer = link.nextProducer;
  const nextConsumer = link.nextConsumer;
  const prevConsumer = link.prevConsumer;
  link.nextConsumer = undefined;
  link.prevConsumer = undefined;
  if (nextConsumer !== undefined) {
    nextConsumer.prevConsumer = prevConsumer;
  } else {
    producer.consumersTail = prevConsumer;
  }
  if (prevConsumer !== undefined) {
    prevConsumer.nextConsumer = nextConsumer;
  } else {
    producer.consumers = nextConsumer;
    if (!consumerIsLive(producer)) {
      let producerLink = producer.producers;
      while (producerLink !== undefined) {
        producerLink = producerRemoveLiveConsumerLink(producerLink);
      }
    }
  }
  return nextProducer;
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || node.consumers !== undefined;
}
function runPostProducerCreatedFn(node) {
  postProducerCreatedFn?.(node);
}
function setPostProducerCreatedFn(fn) {
  const prev = postProducerCreatedFn;
  postProducerCreatedFn = fn;
  return prev;
}
function isValidLink(checkLink, consumer) {
  const producersTail = consumer.producersTail;
  if (producersTail !== undefined) {
    let link = consumer.producers;
    do {
      if (link === checkLink) {
        return true;
      }
      if (link === producersTail) {
        break;
      }
      link = link.nextProducer;
    } while (link !== undefined);
  }
  return false;
}
function defaultEquals(a, b) {
  return Object.is(a, b);
}
function createComputed(computation, equal) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  if (equal !== undefined) {
    node.equal = equal;
  }
  const computed = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed[SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    computed.toString = () => `[Computed${debugName}: ${String(node.value)}]`;
  }
  runPostProducerCreatedFn(node);
  return computed;
}
const UNSET = /* @__PURE__ */Symbol('UNSET');
const COMPUTING = /* @__PURE__ */Symbol('COMPUTING');
const ERRORED = /* @__PURE__ */Symbol('ERRORED');
const COMPUTED_NODE = /* @__PURE__ */(() => {
  return {
    ...REACTIVE_NODE,
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    kind: 'computed',
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      let wasEqual = false;
      try {
        newValue = node.computation();
        setActiveConsumer(null);
        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (wasEqual) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();
function defaultThrowError() {
  throw new Error();
}
let throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError(node) {
  throwInvalidWriteToSignalErrorFn(node);
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
let postSignalSetFn = null;
function createSignal(initialValue, equal) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  if (equal !== undefined) {
    node.equal = equal;
  }
  const getter = () => signalGetFn(node);
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    getter.toString = () => `[Signal${debugName}: ${String(node.value)}]`;
  }
  runPostProducerCreatedFn(node);
  const set = newValue => signalSetFn(node, newValue);
  const update = updateFn => signalUpdateFn(node, updateFn);
  return [getter, set, update];
}
function setPostSignalSetFn(fn) {
  const prev = postSignalSetFn;
  postSignalSetFn = fn;
  return prev;
}
function signalGetFn(node) {
  producerAccessed(node);
  return node.value;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  signalSetFn(node, updater(node.value));
}
function runPostSignalSetFn(node) {
  postSignalSetFn?.(node);
}
const SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ...REACTIVE_NODE,
    equal: defaultEquals,
    value: undefined,
    kind: 'signal'
  };
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.(node);
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
const BASE_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  consumerAllowSignalWrites: true,
  dirty: true,
  kind: 'effect'
}))();
function runEffect(node) {
  node.dirty = false;
  if (node.version > 0 && !consumerPollProducersForChange(node)) {
    return;
  }
  node.version++;
  const prevNode = consumerBeforeComputation(node);
  try {
    node.cleanup();
    node.fn();
  } finally {
    consumerAfterComputation(node, prevNode);
  }
}


/***/ },

/***/ 36124
/*!*******************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_debug_node-chunk.mjs ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFTER_RENDER_PHASES: () => (/* binding */ AFTER_RENDER_PHASES),
/* harmony export */   ANIMATIONS_DISABLED: () => (/* binding */ ANIMATIONS_DISABLED),
/* harmony export */   ANIMATION_MODULE_TYPE: () => (/* binding */ ANIMATION_MODULE_TYPE),
/* harmony export */   APP_BOOTSTRAP_LISTENER: () => (/* binding */ APP_BOOTSTRAP_LISTENER),
/* harmony export */   APP_ID: () => (/* binding */ APP_ID),
/* harmony export */   APP_INITIALIZER: () => (/* binding */ APP_INITIALIZER),
/* harmony export */   AcxChangeDetectionStrategy: () => (/* binding */ AcxChangeDetectionStrategy),
/* harmony export */   AcxViewEncapsulation: () => (/* binding */ AcxViewEncapsulation),
/* harmony export */   AfterRenderImpl: () => (/* binding */ AfterRenderImpl),
/* harmony export */   AfterRenderManager: () => (/* binding */ AfterRenderManager),
/* harmony export */   AfterRenderSequence: () => (/* binding */ AfterRenderSequence),
/* harmony export */   ApplicationInitStatus: () => (/* binding */ ApplicationInitStatus),
/* harmony export */   ApplicationRef: () => (/* binding */ ApplicationRef),
/* harmony export */   Attribute: () => (/* binding */ Attribute),
/* harmony export */   COMPILER_OPTIONS: () => (/* binding */ COMPILER_OPTIONS),
/* harmony export */   CONTAINERS: () => (/* binding */ CONTAINERS),
/* harmony export */   CSP_NONCE: () => (/* binding */ CSP_NONCE),
/* harmony export */   CUSTOM_ELEMENTS_SCHEMA: () => (/* binding */ CUSTOM_ELEMENTS_SCHEMA),
/* harmony export */   ChangeDetectionSchedulerImpl: () => (/* binding */ ChangeDetectionSchedulerImpl),
/* harmony export */   ChangeDetectionStrategy: () => (/* binding */ ChangeDetectionStrategy),
/* harmony export */   Compiler: () => (/* binding */ Compiler),
/* harmony export */   CompilerFactory: () => (/* binding */ CompilerFactory),
/* harmony export */   Component: () => (/* binding */ Component),
/* harmony export */   ComponentFactory: () => (/* binding */ ComponentFactory),
/* harmony export */   ComponentFactory$1: () => (/* binding */ ComponentFactory$1),
/* harmony export */   ComponentFactoryResolver: () => (/* binding */ ComponentFactoryResolver$1),
/* harmony export */   ComponentRef: () => (/* binding */ ComponentRef$1),
/* harmony export */   ComponentRef$1: () => (/* binding */ ComponentRef),
/* harmony export */   Console: () => (/* binding */ Console),
/* harmony export */   DEFAULT_CURRENCY_CODE: () => (/* binding */ DEFAULT_CURRENCY_CODE),
/* harmony export */   DEFAULT_LOCALE_ID: () => (/* binding */ DEFAULT_LOCALE_ID),
/* harmony export */   DEFER_BLOCK_CONFIG: () => (/* binding */ DEFER_BLOCK_CONFIG),
/* harmony export */   DEFER_BLOCK_DEPENDENCY_INTERCEPTOR: () => (/* binding */ DEFER_BLOCK_DEPENDENCY_INTERCEPTOR),
/* harmony export */   DEFER_BLOCK_ID: () => (/* binding */ DEFER_BLOCK_ID),
/* harmony export */   DEFER_BLOCK_SSR_ID_ATTRIBUTE: () => (/* binding */ DEFER_BLOCK_SSR_ID_ATTRIBUTE),
/* harmony export */   DEFER_BLOCK_STATE: () => (/* binding */ DEFER_BLOCK_STATE$1),
/* harmony export */   DEFER_BLOCK_STATE$1: () => (/* binding */ DEFER_BLOCK_STATE),
/* harmony export */   DEFER_HYDRATE_TRIGGERS: () => (/* binding */ DEFER_HYDRATE_TRIGGERS),
/* harmony export */   DEFER_PARENT_BLOCK_ID: () => (/* binding */ DEFER_PARENT_BLOCK_ID),
/* harmony export */   DEHYDRATED_BLOCK_REGISTRY: () => (/* binding */ DEHYDRATED_BLOCK_REGISTRY),
/* harmony export */   DISCONNECTED_NODES: () => (/* binding */ DISCONNECTED_NODES),
/* harmony export */   DebugElement: () => (/* binding */ DebugElement),
/* harmony export */   DebugEventListener: () => (/* binding */ DebugEventListener),
/* harmony export */   DebugNode: () => (/* binding */ DebugNode),
/* harmony export */   DeferBlockBehavior: () => (/* binding */ DeferBlockBehavior),
/* harmony export */   DeferBlockState: () => (/* binding */ DeferBlockState),
/* harmony export */   DehydratedBlockRegistry: () => (/* binding */ DehydratedBlockRegistry),
/* harmony export */   Directive: () => (/* binding */ Directive),
/* harmony export */   ELEMENT_CONTAINERS: () => (/* binding */ ELEMENT_CONTAINERS),
/* harmony export */   EVENT_REPLAY_ENABLED_DEFAULT: () => (/* binding */ EVENT_REPLAY_ENABLED_DEFAULT),
/* harmony export */   EVENT_REPLAY_QUEUE: () => (/* binding */ EVENT_REPLAY_QUEUE),
/* harmony export */   ElementRef: () => (/* binding */ ElementRef),
/* harmony export */   EnvironmentNgModuleRefAdapter: () => (/* binding */ EnvironmentNgModuleRefAdapter),
/* harmony export */   Host: () => (/* binding */ Host),
/* harmony export */   HostBinding: () => (/* binding */ HostBinding),
/* harmony export */   HostListener: () => (/* binding */ HostListener),
/* harmony export */   HydrationStatus: () => (/* binding */ HydrationStatus),
/* harmony export */   I18N_DATA: () => (/* binding */ I18N_DATA),
/* harmony export */   IMAGE_CONFIG: () => (/* binding */ IMAGE_CONFIG),
/* harmony export */   IMAGE_CONFIG_DEFAULTS: () => (/* binding */ IMAGE_CONFIG_DEFAULTS),
/* harmony export */   IS_ENABLED_BLOCKING_INITIAL_NAVIGATION: () => (/* binding */ IS_ENABLED_BLOCKING_INITIAL_NAVIGATION),
/* harmony export */   IS_EVENT_REPLAY_ENABLED: () => (/* binding */ IS_EVENT_REPLAY_ENABLED),
/* harmony export */   IS_HYDRATION_DOM_REUSE_ENABLED: () => (/* binding */ IS_HYDRATION_DOM_REUSE_ENABLED),
/* harmony export */   IS_I18N_HYDRATION_ENABLED: () => (/* binding */ IS_I18N_HYDRATION_ENABLED),
/* harmony export */   IS_INCREMENTAL_HYDRATION_ENABLED: () => (/* binding */ IS_INCREMENTAL_HYDRATION_ENABLED),
/* harmony export */   Inject: () => (/* binding */ Inject),
/* harmony export */   Injectable: () => (/* binding */ Injectable),
/* harmony export */   Input: () => (/* binding */ Input),
/* harmony export */   JSACTION_BLOCK_ELEMENT_MAP: () => (/* binding */ JSACTION_BLOCK_ELEMENT_MAP),
/* harmony export */   JSACTION_EVENT_CONTRACT: () => (/* binding */ JSACTION_EVENT_CONTRACT),
/* harmony export */   LContext: () => (/* binding */ LContext),
/* harmony export */   LOCALE_ID: () => (/* binding */ LOCALE_ID),
/* harmony export */   LocaleDataIndex: () => (/* binding */ LocaleDataIndex),
/* harmony export */   MAX_ANIMATION_TIMEOUT: () => (/* binding */ MAX_ANIMATION_TIMEOUT),
/* harmony export */   MULTIPLIER: () => (/* binding */ MULTIPLIER),
/* harmony export */   MissingTranslationStrategy: () => (/* binding */ MissingTranslationStrategy),
/* harmony export */   ModuleWithComponentFactories: () => (/* binding */ ModuleWithComponentFactories),
/* harmony export */   NGH_ATTR_NAME: () => (/* binding */ NGH_ATTR_NAME),
/* harmony export */   NGH_DATA_KEY: () => (/* binding */ NGH_DATA_KEY),
/* harmony export */   NGH_DEFER_BLOCKS_KEY: () => (/* binding */ NGH_DEFER_BLOCKS_KEY),
/* harmony export */   NODES: () => (/* binding */ NODES),
/* harmony export */   NOOP_AFTER_RENDER_REF: () => (/* binding */ NOOP_AFTER_RENDER_REF),
/* harmony export */   NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: () => (/* binding */ NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR),
/* harmony export */   NO_CHANGE: () => (/* binding */ NO_CHANGE),
/* harmony export */   NO_ERRORS_SCHEMA: () => (/* binding */ NO_ERRORS_SCHEMA),
/* harmony export */   NUM_ROOT_NODES: () => (/* binding */ NUM_ROOT_NODES),
/* harmony export */   NgModule: () => (/* binding */ NgModule),
/* harmony export */   NgModuleFactory: () => (/* binding */ NgModuleFactory),
/* harmony export */   NgModuleFactory$1: () => (/* binding */ NgModuleFactory$1),
/* harmony export */   NgModuleRef: () => (/* binding */ NgModuleRef),
/* harmony export */   NgModuleRef$1: () => (/* binding */ NgModuleRef$1),
/* harmony export */   Optional: () => (/* binding */ Optional),
/* harmony export */   Output: () => (/* binding */ Output),
/* harmony export */   PLATFORM_ID: () => (/* binding */ PLATFORM_ID),
/* harmony export */   PLATFORM_INITIALIZER: () => (/* binding */ PLATFORM_INITIALIZER),
/* harmony export */   PRESERVE_HOST_CONTENT: () => (/* binding */ PRESERVE_HOST_CONTENT),
/* harmony export */   Pipe: () => (/* binding */ Pipe),
/* harmony export */   ProfilerEvent: () => (/* binding */ ProfilerEvent),
/* harmony export */   QueryList: () => (/* binding */ QueryList),
/* harmony export */   ReflectionCapabilities: () => (/* binding */ ReflectionCapabilities),
/* harmony export */   Renderer2: () => (/* binding */ Renderer2),
/* harmony export */   RendererFactory2: () => (/* binding */ RendererFactory2),
/* harmony export */   RendererStyleFlags2: () => (/* binding */ RendererStyleFlags2),
/* harmony export */   SKIP_HYDRATION_ATTR_NAME: () => (/* binding */ SKIP_HYDRATION_ATTR_NAME),
/* harmony export */   SSR_CONTENT_INTEGRITY_MARKER: () => (/* binding */ SSR_CONTENT_INTEGRITY_MARKER),
/* harmony export */   Sanitizer: () => (/* binding */ Sanitizer),
/* harmony export */   SecurityContext: () => (/* binding */ SecurityContext),
/* harmony export */   Self: () => (/* binding */ Self),
/* harmony export */   SimpleChange: () => (/* binding */ SimpleChange),
/* harmony export */   SkipSelf: () => (/* binding */ SkipSelf),
/* harmony export */   TEMPLATES: () => (/* binding */ TEMPLATES),
/* harmony export */   TEMPLATE_ID: () => (/* binding */ TEMPLATE_ID),
/* harmony export */   TESTABILITY: () => (/* binding */ TESTABILITY),
/* harmony export */   TESTABILITY_GETTER: () => (/* binding */ TESTABILITY_GETTER),
/* harmony export */   TRANSLATIONS: () => (/* binding */ TRANSLATIONS),
/* harmony export */   TRANSLATIONS_FORMAT: () => (/* binding */ TRANSLATIONS_FORMAT),
/* harmony export */   TemplateRef: () => (/* binding */ TemplateRef),
/* harmony export */   Testability: () => (/* binding */ Testability),
/* harmony export */   TestabilityRegistry: () => (/* binding */ TestabilityRegistry),
/* harmony export */   TimerScheduler: () => (/* binding */ TimerScheduler),
/* harmony export */   TracingAction: () => (/* binding */ TracingAction),
/* harmony export */   TracingService: () => (/* binding */ TracingService),
/* harmony export */   TransferState: () => (/* binding */ TransferState),
/* harmony export */   Type: () => (/* binding */ Type),
/* harmony export */   UseExhaustiveCheckNoChanges: () => (/* binding */ UseExhaustiveCheckNoChanges),
/* harmony export */   ViewContainerRef: () => (/* binding */ ViewContainerRef),
/* harmony export */   ViewEncapsulation: () => (/* binding */ ViewEncapsulation),
/* harmony export */   ViewRef: () => (/* binding */ ViewRef),
/* harmony export */   _sanitizeHtml: () => (/* binding */ _sanitizeHtml),
/* harmony export */   _sanitizeUrl: () => (/* binding */ _sanitizeUrl),
/* harmony export */   afterEveryRender: () => (/* binding */ afterEveryRender),
/* harmony export */   afterNextRender: () => (/* binding */ afterNextRender),
/* harmony export */   allLeavingAnimations: () => (/* binding */ allLeavingAnimations),
/* harmony export */   allowSanitizationBypassAndThrow: () => (/* binding */ allowSanitizationBypassAndThrow),
/* harmony export */   angularCoreEnv: () => (/* binding */ angularCoreEnv),
/* harmony export */   appendDeferBlocksToJSActionMap: () => (/* binding */ appendDeferBlocksToJSActionMap),
/* harmony export */   asNativeElements: () => (/* binding */ asNativeElements),
/* harmony export */   assertComponentDef: () => (/* binding */ assertComponentDef),
/* harmony export */   assertStandaloneComponentType: () => (/* binding */ assertStandaloneComponentType),
/* harmony export */   bypassSanitizationTrustHtml: () => (/* binding */ bypassSanitizationTrustHtml),
/* harmony export */   bypassSanitizationTrustResourceUrl: () => (/* binding */ bypassSanitizationTrustResourceUrl),
/* harmony export */   bypassSanitizationTrustScript: () => (/* binding */ bypassSanitizationTrustScript),
/* harmony export */   bypassSanitizationTrustStyle: () => (/* binding */ bypassSanitizationTrustStyle),
/* harmony export */   bypassSanitizationTrustUrl: () => (/* binding */ bypassSanitizationTrustUrl),
/* harmony export */   calcPathForNode: () => (/* binding */ calcPathForNode),
/* harmony export */   checkNoChangesInternal: () => (/* binding */ checkNoChangesInternal),
/* harmony export */   cleanupDehydratedViews: () => (/* binding */ cleanupDehydratedViews),
/* harmony export */   clearResolutionOfComponentResourcesQueue: () => (/* binding */ clearResolutionOfComponentResourcesQueue),
/* harmony export */   collectNativeNodes: () => (/* binding */ collectNativeNodes),
/* harmony export */   collectNativeNodesInLContainer: () => (/* binding */ collectNativeNodesInLContainer),
/* harmony export */   compileComponent: () => (/* binding */ compileComponent),
/* harmony export */   compileDirective: () => (/* binding */ compileDirective),
/* harmony export */   compileNgModule: () => (/* binding */ compileNgModule),
/* harmony export */   compileNgModuleDefs: () => (/* binding */ compileNgModuleDefs),
/* harmony export */   compilePipe: () => (/* binding */ compilePipe),
/* harmony export */   convertHydrateTriggersToJsAction: () => (/* binding */ convertHydrateTriggersToJsAction),
/* harmony export */   countBlocksSkippedByHydration: () => (/* binding */ countBlocksSkippedByHydration),
/* harmony export */   createEnvironmentInjector: () => (/* binding */ createEnvironmentInjector),
/* harmony export */   createMultiResultQuerySignalFn: () => (/* binding */ createMultiResultQuerySignalFn),
/* harmony export */   createNgModule: () => (/* binding */ createNgModule),
/* harmony export */   createNgModuleRef: () => (/* binding */ createNgModuleRef),
/* harmony export */   createNgModuleRefWithProviders: () => (/* binding */ createNgModuleRefWithProviders),
/* harmony export */   createSingleResultOptionalQuerySignalFn: () => (/* binding */ createSingleResultOptionalQuerySignalFn),
/* harmony export */   createSingleResultRequiredQuerySignalFn: () => (/* binding */ createSingleResultRequiredQuerySignalFn),
/* harmony export */   depsTracker: () => (/* binding */ depsTracker),
/* harmony export */   devModeEqual: () => (/* binding */ devModeEqual),
/* harmony export */   enableApplyRootElementTransformImpl: () => (/* binding */ enableApplyRootElementTransformImpl),
/* harmony export */   enableClaimDehydratedIcuCaseImpl: () => (/* binding */ enableClaimDehydratedIcuCaseImpl),
/* harmony export */   enableFindMatchingDehydratedViewImpl: () => (/* binding */ enableFindMatchingDehydratedViewImpl),
/* harmony export */   enableLocateOrCreateContainerAnchorImpl: () => (/* binding */ enableLocateOrCreateContainerAnchorImpl),
/* harmony export */   enableLocateOrCreateContainerRefImpl: () => (/* binding */ enableLocateOrCreateContainerRefImpl),
/* harmony export */   enableLocateOrCreateElementContainerNodeImpl: () => (/* binding */ enableLocateOrCreateElementContainerNodeImpl),
/* harmony export */   enableLocateOrCreateElementNodeImpl: () => (/* binding */ enableLocateOrCreateElementNodeImpl),
/* harmony export */   enableLocateOrCreateI18nNodeImpl: () => (/* binding */ enableLocateOrCreateI18nNodeImpl),
/* harmony export */   enableLocateOrCreateTextNodeImpl: () => (/* binding */ enableLocateOrCreateTextNodeImpl),
/* harmony export */   enablePrepareI18nBlockForHydrationImpl: () => (/* binding */ enablePrepareI18nBlockForHydrationImpl),
/* harmony export */   enableProfiling: () => (/* binding */ enableProfiling),
/* harmony export */   enableRetrieveDeferBlockDataImpl: () => (/* binding */ enableRetrieveDeferBlockDataImpl),
/* harmony export */   enableRetrieveHydrationInfoImpl: () => (/* binding */ enableRetrieveHydrationInfoImpl),
/* harmony export */   enableStashEventListenerImpl: () => (/* binding */ enableStashEventListenerImpl),
/* harmony export */   findLocaleData: () => (/* binding */ findLocaleData),
/* harmony export */   flushModuleScopingQueueAsMuchAsPossible: () => (/* binding */ flushModuleScopingQueueAsMuchAsPossible),
/* harmony export */   gatherDeferBlocksCommentNodes: () => (/* binding */ gatherDeferBlocksCommentNodes),
/* harmony export */   generateStandaloneInDeclarationsError: () => (/* binding */ generateStandaloneInDeclarationsError),
/* harmony export */   getAsyncClassMetadataFn: () => (/* binding */ getAsyncClassMetadataFn),
/* harmony export */   getCompilerFacade: () => (/* binding */ getCompilerFacade),
/* harmony export */   getDebugNode: () => (/* binding */ getDebugNode),
/* harmony export */   getDeferBlocks: () => (/* binding */ getDeferBlocks$1),
/* harmony export */   getDirectives: () => (/* binding */ getDirectives),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   getHostElement: () => (/* binding */ getHostElement),
/* harmony export */   getLContext: () => (/* binding */ getLContext),
/* harmony export */   getLDeferBlockDetails: () => (/* binding */ getLDeferBlockDetails),
/* harmony export */   getLNodeForHydration: () => (/* binding */ getLNodeForHydration),
/* harmony export */   getLocaleCurrencyCode: () => (/* binding */ getLocaleCurrencyCode),
/* harmony export */   getLocalePluralCase: () => (/* binding */ getLocalePluralCase),
/* harmony export */   getOrComputeI18nChildren: () => (/* binding */ getOrComputeI18nChildren),
/* harmony export */   getRegisteredNgModuleType: () => (/* binding */ getRegisteredNgModuleType),
/* harmony export */   getSanitizationBypassType: () => (/* binding */ getSanitizationBypassType),
/* harmony export */   getTDeferBlockDetails: () => (/* binding */ getTDeferBlockDetails),
/* harmony export */   getTransferState: () => (/* binding */ getTransferState),
/* harmony export */   inferTagNameFromDefinition: () => (/* binding */ inferTagNameFromDefinition),
/* harmony export */   inputBinding: () => (/* binding */ inputBinding),
/* harmony export */   invokeListeners: () => (/* binding */ invokeListeners),
/* harmony export */   isBoundToModule: () => (/* binding */ isBoundToModule),
/* harmony export */   isComponentDefPendingResolution: () => (/* binding */ isComponentDefPendingResolution),
/* harmony export */   isComponentResourceResolutionQueueEmpty: () => (/* binding */ isComponentResourceResolutionQueueEmpty),
/* harmony export */   isDeferBlock: () => (/* binding */ isDeferBlock),
/* harmony export */   isDetachedByI18n: () => (/* binding */ isDetachedByI18n),
/* harmony export */   isDisconnectedNode: () => (/* binding */ isDisconnectedNode),
/* harmony export */   isI18nHydrationEnabled: () => (/* binding */ isI18nHydrationEnabled),
/* harmony export */   isI18nHydrationSupportEnabled: () => (/* binding */ isI18nHydrationSupportEnabled),
/* harmony export */   isInSkipHydrationBlock: () => (/* binding */ isInSkipHydrationBlock),
/* harmony export */   isIncrementalHydrationEnabled: () => (/* binding */ isIncrementalHydrationEnabled),
/* harmony export */   isJsObject: () => (/* binding */ isJsObject),
/* harmony export */   isLetDeclaration: () => (/* binding */ isLetDeclaration),
/* harmony export */   isListLikeIterable: () => (/* binding */ isListLikeIterable),
/* harmony export */   isNgModule: () => (/* binding */ isNgModule),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isSignal: () => (/* binding */ isSignal),
/* harmony export */   isSubscribable: () => (/* binding */ isSubscribable),
/* harmony export */   isTNodeShape: () => (/* binding */ isTNodeShape),
/* harmony export */   isViewDirty: () => (/* binding */ isViewDirty),
/* harmony export */   isWritableSignal: () => (/* binding */ isWritableSignal),
/* harmony export */   iterateListLike: () => (/* binding */ iterateListLike),
/* harmony export */   makePropDecorator: () => (/* binding */ makePropDecorator),
/* harmony export */   makeStateKey: () => (/* binding */ makeStateKey),
/* harmony export */   markForRefresh: () => (/* binding */ markForRefresh),
/* harmony export */   noSideEffects: () => (/* binding */ noSideEffects),
/* harmony export */   optionsReducer: () => (/* binding */ optionsReducer),
/* harmony export */   outputBinding: () => (/* binding */ outputBinding),
/* harmony export */   patchComponentDefWithScope: () => (/* binding */ patchComponentDefWithScope),
/* harmony export */   performanceMarkFeature: () => (/* binding */ performanceMarkFeature),
/* harmony export */   processAndInitTriggers: () => (/* binding */ processAndInitTriggers),
/* harmony export */   processBlockData: () => (/* binding */ processBlockData),
/* harmony export */   processTextNodeBeforeSerialization: () => (/* binding */ processTextNodeBeforeSerialization),
/* harmony export */   profiler: () => (/* binding */ profiler),
/* harmony export */   promiseWithResolvers: () => (/* binding */ promiseWithResolvers),
/* harmony export */   provideAppInitializer: () => (/* binding */ provideAppInitializer),
/* harmony export */   provideNgReflectAttributes: () => (/* binding */ provideNgReflectAttributes),
/* harmony export */   provideZonelessChangeDetection: () => (/* binding */ provideZonelessChangeDetection),
/* harmony export */   provideZonelessChangeDetectionInternal: () => (/* binding */ provideZonelessChangeDetectionInternal),
/* harmony export */   publishDefaultGlobalUtils: () => (/* binding */ publishDefaultGlobalUtils),
/* harmony export */   publishExternalGlobalUtil: () => (/* binding */ publishExternalGlobalUtil),
/* harmony export */   publishSignalConfiguration: () => (/* binding */ publishSignalConfiguration),
/* harmony export */   readHydrationInfo: () => (/* binding */ readHydrationInfo),
/* harmony export */   readPatchedLView: () => (/* binding */ readPatchedLView),
/* harmony export */   registerLocaleData: () => (/* binding */ registerLocaleData),
/* harmony export */   registerNgModuleType: () => (/* binding */ registerNgModuleType),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeListeners: () => (/* binding */ removeListeners),
/* harmony export */   renderDeferBlockState: () => (/* binding */ renderDeferBlockState),
/* harmony export */   resetCompiledComponents: () => (/* binding */ resetCompiledComponents),
/* harmony export */   resetIncrementalHydrationEnabledWarnedForTests: () => (/* binding */ resetIncrementalHydrationEnabledWarnedForTests),
/* harmony export */   resetJitOptions: () => (/* binding */ resetJitOptions),
/* harmony export */   resolveComponentResources: () => (/* binding */ resolveComponentResources),
/* harmony export */   restoreComponentResolutionQueue: () => (/* binding */ restoreComponentResolutionQueue),
/* harmony export */   setAllowDuplicateNgModuleIdsForTest: () => (/* binding */ setAllowDuplicateNgModuleIdsForTest),
/* harmony export */   setClassMetadata: () => (/* binding */ setClassMetadata),
/* harmony export */   setClassMetadataAsync: () => (/* binding */ setClassMetadataAsync),
/* harmony export */   setDocument: () => (/* binding */ setDocument),
/* harmony export */   setIsI18nHydrationSupportEnabled: () => (/* binding */ setIsI18nHydrationSupportEnabled),
/* harmony export */   setJSActionAttributes: () => (/* binding */ setJSActionAttributes),
/* harmony export */   setJitOptions: () => (/* binding */ setJitOptions),
/* harmony export */   setLocaleId: () => (/* binding */ setLocaleId),
/* harmony export */   setStashFn: () => (/* binding */ setStashFn),
/* harmony export */   setTestabilityGetter: () => (/* binding */ setTestabilityGetter),
/* harmony export */   sharedMapFunction: () => (/* binding */ sharedMapFunction),
/* harmony export */   sharedStashFunction: () => (/* binding */ sharedStashFunction),
/* harmony export */   transitiveScopesFor: () => (/* binding */ transitiveScopesFor),
/* harmony export */   triggerHydrationFromBlockName: () => (/* binding */ triggerHydrationFromBlockName),
/* harmony export */   triggerResourceLoading: () => (/* binding */ triggerResourceLoading),
/* harmony export */   trySerializeI18nBlock: () => (/* binding */ trySerializeI18nBlock),
/* harmony export */   twoWayBinding: () => (/* binding */ twoWayBinding),
/* harmony export */   unregisterAllLocaleData: () => (/* binding */ unregisterAllLocaleData),
/* harmony export */   unsupportedProjectionOfDomNodes: () => (/* binding */ unsupportedProjectionOfDomNodes),
/* harmony export */   unwrapSafeValue: () => (/* binding */ unwrapSafeValue),
/* harmony export */   validAppIdInitializer: () => (/* binding */ validAppIdInitializer),
/* harmony export */   validateMatchingNode: () => (/* binding */ validateMatchingNode),
/* harmony export */   validateNodeExists: () => (/* binding */ validateNodeExists),
/* harmony export */   verifySsrContentsIntegrity: () => (/* binding */ verifySsrContentsIntegrity),
/* harmony export */   "ɵCONTROL": () => (/* binding */ ɵCONTROL),
/* harmony export */   "ɵcontrolUpdate": () => (/* binding */ ɵcontrolUpdate),
/* harmony export */   "ɵgetUnknownElementStrictMode": () => (/* binding */ ɵgetUnknownElementStrictMode),
/* harmony export */   "ɵgetUnknownPropertyStrictMode": () => (/* binding */ ɵgetUnknownPropertyStrictMode),
/* harmony export */   "ɵsetClassDebugInfo": () => (/* binding */ ɵsetClassDebugInfo),
/* harmony export */   "ɵsetUnknownElementStrictMode": () => (/* binding */ ɵsetUnknownElementStrictMode),
/* harmony export */   "ɵsetUnknownPropertyStrictMode": () => (/* binding */ ɵsetUnknownPropertyStrictMode),
/* harmony export */   "ɵɵExternalStylesFeature": () => (/* binding */ ɵɵExternalStylesFeature),
/* harmony export */   "ɵɵHostDirectivesFeature": () => (/* binding */ ɵɵHostDirectivesFeature),
/* harmony export */   "ɵɵInheritDefinitionFeature": () => (/* binding */ ɵɵInheritDefinitionFeature),
/* harmony export */   "ɵɵNgOnChangesFeature": () => (/* binding */ ɵɵNgOnChangesFeature),
/* harmony export */   "ɵɵProvidersFeature": () => (/* binding */ ɵɵProvidersFeature),
/* harmony export */   "ɵɵadvance": () => (/* binding */ ɵɵadvance),
/* harmony export */   "ɵɵanimateEnter": () => (/* binding */ ɵɵanimateEnter),
/* harmony export */   "ɵɵanimateEnterListener": () => (/* binding */ ɵɵanimateEnterListener),
/* harmony export */   "ɵɵanimateLeave": () => (/* binding */ ɵɵanimateLeave),
/* harmony export */   "ɵɵanimateLeaveListener": () => (/* binding */ ɵɵanimateLeaveListener),
/* harmony export */   "ɵɵariaProperty": () => (/* binding */ ɵɵariaProperty),
/* harmony export */   "ɵɵattachSourceLocations": () => (/* binding */ ɵɵattachSourceLocations),
/* harmony export */   "ɵɵattribute": () => (/* binding */ ɵɵattribute),
/* harmony export */   "ɵɵclassMap": () => (/* binding */ ɵɵclassMap),
/* harmony export */   "ɵɵclassProp": () => (/* binding */ ɵɵclassProp),
/* harmony export */   "ɵɵcomponentInstance": () => (/* binding */ ɵɵcomponentInstance),
/* harmony export */   "ɵɵconditional": () => (/* binding */ ɵɵconditional),
/* harmony export */   "ɵɵconditionalBranchCreate": () => (/* binding */ ɵɵconditionalBranchCreate),
/* harmony export */   "ɵɵconditionalCreate": () => (/* binding */ ɵɵconditionalCreate),
/* harmony export */   "ɵɵcontentQuery": () => (/* binding */ ɵɵcontentQuery),
/* harmony export */   "ɵɵcontentQuerySignal": () => (/* binding */ ɵɵcontentQuerySignal),
/* harmony export */   "ɵɵcontrol": () => (/* binding */ ɵɵcontrol),
/* harmony export */   "ɵɵcontrolCreate": () => (/* binding */ ɵɵcontrolCreate),
/* harmony export */   "ɵɵdeclareLet": () => (/* binding */ ɵɵdeclareLet),
/* harmony export */   "ɵɵdefer": () => (/* binding */ ɵɵdefer),
/* harmony export */   "ɵɵdeferEnableTimerScheduling": () => (/* binding */ ɵɵdeferEnableTimerScheduling),
/* harmony export */   "ɵɵdeferHydrateNever": () => (/* binding */ ɵɵdeferHydrateNever),
/* harmony export */   "ɵɵdeferHydrateOnHover": () => (/* binding */ ɵɵdeferHydrateOnHover),
/* harmony export */   "ɵɵdeferHydrateOnIdle": () => (/* binding */ ɵɵdeferHydrateOnIdle),
/* harmony export */   "ɵɵdeferHydrateOnImmediate": () => (/* binding */ ɵɵdeferHydrateOnImmediate),
/* harmony export */   "ɵɵdeferHydrateOnInteraction": () => (/* binding */ ɵɵdeferHydrateOnInteraction),
/* harmony export */   "ɵɵdeferHydrateOnTimer": () => (/* binding */ ɵɵdeferHydrateOnTimer),
/* harmony export */   "ɵɵdeferHydrateOnViewport": () => (/* binding */ ɵɵdeferHydrateOnViewport),
/* harmony export */   "ɵɵdeferHydrateWhen": () => (/* binding */ ɵɵdeferHydrateWhen),
/* harmony export */   "ɵɵdeferOnHover": () => (/* binding */ ɵɵdeferOnHover),
/* harmony export */   "ɵɵdeferOnIdle": () => (/* binding */ ɵɵdeferOnIdle),
/* harmony export */   "ɵɵdeferOnImmediate": () => (/* binding */ ɵɵdeferOnImmediate),
/* harmony export */   "ɵɵdeferOnInteraction": () => (/* binding */ ɵɵdeferOnInteraction),
/* harmony export */   "ɵɵdeferOnTimer": () => (/* binding */ ɵɵdeferOnTimer),
/* harmony export */   "ɵɵdeferOnViewport": () => (/* binding */ ɵɵdeferOnViewport),
/* harmony export */   "ɵɵdeferPrefetchOnHover": () => (/* binding */ ɵɵdeferPrefetchOnHover),
/* harmony export */   "ɵɵdeferPrefetchOnIdle": () => (/* binding */ ɵɵdeferPrefetchOnIdle),
/* harmony export */   "ɵɵdeferPrefetchOnImmediate": () => (/* binding */ ɵɵdeferPrefetchOnImmediate),
/* harmony export */   "ɵɵdeferPrefetchOnInteraction": () => (/* binding */ ɵɵdeferPrefetchOnInteraction),
/* harmony export */   "ɵɵdeferPrefetchOnTimer": () => (/* binding */ ɵɵdeferPrefetchOnTimer),
/* harmony export */   "ɵɵdeferPrefetchOnViewport": () => (/* binding */ ɵɵdeferPrefetchOnViewport),
/* harmony export */   "ɵɵdeferPrefetchWhen": () => (/* binding */ ɵɵdeferPrefetchWhen),
/* harmony export */   "ɵɵdeferWhen": () => (/* binding */ ɵɵdeferWhen),
/* harmony export */   "ɵɵdefineComponent": () => (/* binding */ ɵɵdefineComponent),
/* harmony export */   "ɵɵdefineDirective": () => (/* binding */ ɵɵdefineDirective),
/* harmony export */   "ɵɵdefineNgModule": () => (/* binding */ ɵɵdefineNgModule),
/* harmony export */   "ɵɵdefinePipe": () => (/* binding */ ɵɵdefinePipe),
/* harmony export */   "ɵɵdirectiveInject": () => (/* binding */ ɵɵdirectiveInject),
/* harmony export */   "ɵɵdomElement": () => (/* binding */ ɵɵdomElement),
/* harmony export */   "ɵɵdomElementContainer": () => (/* binding */ ɵɵdomElementContainer),
/* harmony export */   "ɵɵdomElementContainerEnd": () => (/* binding */ ɵɵdomElementContainerEnd),
/* harmony export */   "ɵɵdomElementContainerStart": () => (/* binding */ ɵɵdomElementContainerStart),
/* harmony export */   "ɵɵdomElementEnd": () => (/* binding */ ɵɵdomElementEnd),
/* harmony export */   "ɵɵdomElementStart": () => (/* binding */ ɵɵdomElementStart),
/* harmony export */   "ɵɵdomListener": () => (/* binding */ ɵɵdomListener),
/* harmony export */   "ɵɵdomProperty": () => (/* binding */ ɵɵdomProperty),
/* harmony export */   "ɵɵdomTemplate": () => (/* binding */ ɵɵdomTemplate),
/* harmony export */   "ɵɵelement": () => (/* binding */ ɵɵelement),
/* harmony export */   "ɵɵelementContainer": () => (/* binding */ ɵɵelementContainer),
/* harmony export */   "ɵɵelementContainerEnd": () => (/* binding */ ɵɵelementContainerEnd),
/* harmony export */   "ɵɵelementContainerStart": () => (/* binding */ ɵɵelementContainerStart),
/* harmony export */   "ɵɵelementEnd": () => (/* binding */ ɵɵelementEnd),
/* harmony export */   "ɵɵelementStart": () => (/* binding */ ɵɵelementStart),
/* harmony export */   "ɵɵgetComponentDepsFactory": () => (/* binding */ ɵɵgetComponentDepsFactory),
/* harmony export */   "ɵɵgetCurrentView": () => (/* binding */ ɵɵgetCurrentView),
/* harmony export */   "ɵɵgetInheritedFactory": () => (/* binding */ ɵɵgetInheritedFactory),
/* harmony export */   "ɵɵgetReplaceMetadataURL": () => (/* binding */ ɵɵgetReplaceMetadataURL),
/* harmony export */   "ɵɵi18n": () => (/* binding */ ɵɵi18n),
/* harmony export */   "ɵɵi18nApply": () => (/* binding */ ɵɵi18nApply),
/* harmony export */   "ɵɵi18nAttributes": () => (/* binding */ ɵɵi18nAttributes),
/* harmony export */   "ɵɵi18nEnd": () => (/* binding */ ɵɵi18nEnd),
/* harmony export */   "ɵɵi18nExp": () => (/* binding */ ɵɵi18nExp),
/* harmony export */   "ɵɵi18nPostprocess": () => (/* binding */ ɵɵi18nPostprocess),
/* harmony export */   "ɵɵi18nStart": () => (/* binding */ ɵɵi18nStart),
/* harmony export */   "ɵɵinjectAttribute": () => (/* binding */ ɵɵinjectAttribute),
/* harmony export */   "ɵɵinterpolate": () => (/* binding */ ɵɵinterpolate),
/* harmony export */   "ɵɵinterpolate1": () => (/* binding */ ɵɵinterpolate1),
/* harmony export */   "ɵɵinterpolate2": () => (/* binding */ ɵɵinterpolate2),
/* harmony export */   "ɵɵinterpolate3": () => (/* binding */ ɵɵinterpolate3),
/* harmony export */   "ɵɵinterpolate4": () => (/* binding */ ɵɵinterpolate4),
/* harmony export */   "ɵɵinterpolate5": () => (/* binding */ ɵɵinterpolate5),
/* harmony export */   "ɵɵinterpolate6": () => (/* binding */ ɵɵinterpolate6),
/* harmony export */   "ɵɵinterpolate7": () => (/* binding */ ɵɵinterpolate7),
/* harmony export */   "ɵɵinterpolate8": () => (/* binding */ ɵɵinterpolate8),
/* harmony export */   "ɵɵinterpolateV": () => (/* binding */ ɵɵinterpolateV),
/* harmony export */   "ɵɵinvalidFactory": () => (/* binding */ ɵɵinvalidFactory),
/* harmony export */   "ɵɵlistener": () => (/* binding */ ɵɵlistener),
/* harmony export */   "ɵɵloadQuery": () => (/* binding */ ɵɵloadQuery),
/* harmony export */   "ɵɵnextContext": () => (/* binding */ ɵɵnextContext),
/* harmony export */   "ɵɵpipe": () => (/* binding */ ɵɵpipe),
/* harmony export */   "ɵɵpipeBind1": () => (/* binding */ ɵɵpipeBind1),
/* harmony export */   "ɵɵpipeBind2": () => (/* binding */ ɵɵpipeBind2),
/* harmony export */   "ɵɵpipeBind3": () => (/* binding */ ɵɵpipeBind3),
/* harmony export */   "ɵɵpipeBind4": () => (/* binding */ ɵɵpipeBind4),
/* harmony export */   "ɵɵpipeBindV": () => (/* binding */ ɵɵpipeBindV),
/* harmony export */   "ɵɵprojection": () => (/* binding */ ɵɵprojection),
/* harmony export */   "ɵɵprojectionDef": () => (/* binding */ ɵɵprojectionDef),
/* harmony export */   "ɵɵproperty": () => (/* binding */ ɵɵproperty),
/* harmony export */   "ɵɵpureFunction0": () => (/* binding */ ɵɵpureFunction0),
/* harmony export */   "ɵɵpureFunction1": () => (/* binding */ ɵɵpureFunction1),
/* harmony export */   "ɵɵpureFunction2": () => (/* binding */ ɵɵpureFunction2),
/* harmony export */   "ɵɵpureFunction3": () => (/* binding */ ɵɵpureFunction3),
/* harmony export */   "ɵɵpureFunction4": () => (/* binding */ ɵɵpureFunction4),
/* harmony export */   "ɵɵpureFunction5": () => (/* binding */ ɵɵpureFunction5),
/* harmony export */   "ɵɵpureFunction6": () => (/* binding */ ɵɵpureFunction6),
/* harmony export */   "ɵɵpureFunction7": () => (/* binding */ ɵɵpureFunction7),
/* harmony export */   "ɵɵpureFunction8": () => (/* binding */ ɵɵpureFunction8),
/* harmony export */   "ɵɵpureFunctionV": () => (/* binding */ ɵɵpureFunctionV),
/* harmony export */   "ɵɵqueryAdvance": () => (/* binding */ ɵɵqueryAdvance),
/* harmony export */   "ɵɵqueryRefresh": () => (/* binding */ ɵɵqueryRefresh),
/* harmony export */   "ɵɵreadContextLet": () => (/* binding */ ɵɵreadContextLet),
/* harmony export */   "ɵɵreference": () => (/* binding */ ɵɵreference),
/* harmony export */   "ɵɵrepeater": () => (/* binding */ ɵɵrepeater),
/* harmony export */   "ɵɵrepeaterCreate": () => (/* binding */ ɵɵrepeaterCreate),
/* harmony export */   "ɵɵrepeaterTrackByIdentity": () => (/* binding */ ɵɵrepeaterTrackByIdentity),
/* harmony export */   "ɵɵrepeaterTrackByIndex": () => (/* binding */ ɵɵrepeaterTrackByIndex),
/* harmony export */   "ɵɵreplaceMetadata": () => (/* binding */ ɵɵreplaceMetadata),
/* harmony export */   "ɵɵresolveBody": () => (/* binding */ ɵɵresolveBody),
/* harmony export */   "ɵɵresolveDocument": () => (/* binding */ ɵɵresolveDocument),
/* harmony export */   "ɵɵresolveWindow": () => (/* binding */ ɵɵresolveWindow),
/* harmony export */   "ɵɵsanitizeHtml": () => (/* binding */ ɵɵsanitizeHtml),
/* harmony export */   "ɵɵsanitizeResourceUrl": () => (/* binding */ ɵɵsanitizeResourceUrl),
/* harmony export */   "ɵɵsanitizeScript": () => (/* binding */ ɵɵsanitizeScript),
/* harmony export */   "ɵɵsanitizeStyle": () => (/* binding */ ɵɵsanitizeStyle),
/* harmony export */   "ɵɵsanitizeUrl": () => (/* binding */ ɵɵsanitizeUrl),
/* harmony export */   "ɵɵsanitizeUrlOrResourceUrl": () => (/* binding */ ɵɵsanitizeUrlOrResourceUrl),
/* harmony export */   "ɵɵsetComponentScope": () => (/* binding */ ɵɵsetComponentScope),
/* harmony export */   "ɵɵsetNgModuleScope": () => (/* binding */ ɵɵsetNgModuleScope),
/* harmony export */   "ɵɵstoreLet": () => (/* binding */ ɵɵstoreLet),
/* harmony export */   "ɵɵstyleMap": () => (/* binding */ ɵɵstyleMap),
/* harmony export */   "ɵɵstyleProp": () => (/* binding */ ɵɵstyleProp),
/* harmony export */   "ɵɵsyntheticHostListener": () => (/* binding */ ɵɵsyntheticHostListener),
/* harmony export */   "ɵɵsyntheticHostProperty": () => (/* binding */ ɵɵsyntheticHostProperty),
/* harmony export */   "ɵɵtemplate": () => (/* binding */ ɵɵtemplate),
/* harmony export */   "ɵɵtemplateRefExtractor": () => (/* binding */ ɵɵtemplateRefExtractor),
/* harmony export */   "ɵɵtext": () => (/* binding */ ɵɵtext),
/* harmony export */   "ɵɵtextInterpolate": () => (/* binding */ ɵɵtextInterpolate),
/* harmony export */   "ɵɵtextInterpolate1": () => (/* binding */ ɵɵtextInterpolate1),
/* harmony export */   "ɵɵtextInterpolate2": () => (/* binding */ ɵɵtextInterpolate2),
/* harmony export */   "ɵɵtextInterpolate3": () => (/* binding */ ɵɵtextInterpolate3),
/* harmony export */   "ɵɵtextInterpolate4": () => (/* binding */ ɵɵtextInterpolate4),
/* harmony export */   "ɵɵtextInterpolate5": () => (/* binding */ ɵɵtextInterpolate5),
/* harmony export */   "ɵɵtextInterpolate6": () => (/* binding */ ɵɵtextInterpolate6),
/* harmony export */   "ɵɵtextInterpolate7": () => (/* binding */ ɵɵtextInterpolate7),
/* harmony export */   "ɵɵtextInterpolate8": () => (/* binding */ ɵɵtextInterpolate8),
/* harmony export */   "ɵɵtextInterpolateV": () => (/* binding */ ɵɵtextInterpolateV),
/* harmony export */   "ɵɵtrustConstantHtml": () => (/* binding */ ɵɵtrustConstantHtml),
/* harmony export */   "ɵɵtrustConstantResourceUrl": () => (/* binding */ ɵɵtrustConstantResourceUrl),
/* harmony export */   "ɵɵtwoWayBindingSet": () => (/* binding */ ɵɵtwoWayBindingSet),
/* harmony export */   "ɵɵtwoWayListener": () => (/* binding */ ɵɵtwoWayListener),
/* harmony export */   "ɵɵtwoWayProperty": () => (/* binding */ ɵɵtwoWayProperty),
/* harmony export */   "ɵɵvalidateAttribute": () => (/* binding */ ɵɵvalidateAttribute),
/* harmony export */   "ɵɵviewQuery": () => (/* binding */ ɵɵviewQuery),
/* harmony export */   "ɵɵviewQuerySignal": () => (/* binding */ ɵɵviewQuerySignal)
/* harmony export */ });
/* harmony import */ var _Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 89204);
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 11817);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 44866);
/* harmony import */ var _angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core/primitives/signals */ 95094);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 32778);
/* harmony import */ var _attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_attribute-chunk.mjs */ 66248);

/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */







function noSideEffects(fn) {
  return {
    toString: fn
  }.toString();
}
const ANNOTATIONS = '__annotations__';
const PARAMETERS = '__parameters__';
const PROP_METADATA = '__prop__metadata__';
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn) typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
          value: []
        })[ANNOTATIONS];
        annotations.push(annotationInstance);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
          value: []
        })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name) {
        if (target === undefined) {
          throw new Error('Standard Angular field decorators are not supported in JIT mode.');
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
          value: {}
        })[PROP_METADATA];
        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
        meta[name].unshift(decoratorInstance);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
const Inject = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(/*#__PURE__*/makeParamDecorator('Inject', token => ({
  token
})), -1);
const Optional = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(/*#__PURE__*/makeParamDecorator('Optional'), 8);
const Self = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(/*#__PURE__*/makeParamDecorator('Self'), 2);
const SkipSelf = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(/*#__PURE__*/makeParamDecorator('SkipSelf'), 4);
const Host = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.attachInjectFlag)(/*#__PURE__*/makeParamDecorator('Host'), 1);
function getCompilerFacade(request) {
  const globalNg = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global['ng'];
  if (globalNg && globalNg.ɵcompilerFacade) {
    return globalNg.ɵcompilerFacade;
  }
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.\n`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n`;
      message += '\n';
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error('JIT compiler unavailable');
  }
}
const angularCoreDiEnv = {
  'ɵɵdefineInjectable': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"],
  'ɵɵdefineInjector': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"],
  'ɵɵinject': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"],
  'ɵɵinvalidFactoryDep': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinvalidFactoryDep"],
  'resolveForwardRef': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef
};
const Type = Function;
function isType(v) {
  return typeof v === 'function';
}
const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
const ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
const ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
class ReflectionCapabilities {
  _reflect;
  constructor(reflect) {
    this._reflect = reflect || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global['Reflect'];
  }
  factory(t) {
    return (...args) => new t(...args);
  }
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === 'undefined') {
      result = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(paramAnnotations.length);
    } else {
      result = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(paramTypes.length);
    }
    for (let i = 0; i < result.length; i++) {
      if (typeof paramTypes === 'undefined') {
        result[i] = [];
      } else if (paramTypes[i] && paramTypes[i] != Object) {
        result[i] = [paramTypes[i]];
      } else {
        result[i] = [];
      }
      if (paramAnnotations && paramAnnotations[i] != null) {
        result[i] = result[i].concat(paramAnnotations[i]);
      }
    }
    return result;
  }
  _ownParameters(type, parentCtor) {
    const typeStr = type.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type.parameters && type.parameters !== parentCtor.parameters) {
      return type.parameters;
    }
    const tsickleCtorParams = type.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);
      const paramAnnotations = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(type.length);
  }
  parameters(type) {
    if (!isType(type)) {
      return [];
    }
    const parentCtor = getParentCtor(type);
    let parameters = this._ownParameters(type, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === 'function' && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach(prop => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach(propName => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach(propName => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type, lcProperty) {
    return type instanceof Type && lcProperty in type.prototype;
  }
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map(decoratorInvocation => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
class SimpleChange {
  previousValue;
  currentValue;
  firstChange;
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  isFirstChange() {
    return this.firstChange;
  }
}
const ɵɵNgOnChangesFeature = /* @__PURE__ */(() => {
  const ɵɵNgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;
  ɵɵNgOnChangesFeatureImpl.ngInherit = true;
  return ɵɵNgOnChangesFeatureImpl;
})();
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(declaredName, 'Name of input in ngOnChanges has to be a string');
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
    previous: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    current: null
  });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
const SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store) {
  return instance[SIMPLE_CHANGES_STORE] = store;
}
const profilerCallbacks = [];
const NOOP_PROFILER_REMOVAL = () => {};
function removeProfiler(profiler) {
  const profilerIdx = profilerCallbacks.indexOf(profiler);
  if (profilerIdx !== -1) {
    profilerCallbacks.splice(profilerIdx, 1);
  }
}
function setProfiler(profiler) {
  if (profiler !== null) {
    if (!profilerCallbacks.includes(profiler)) {
      profilerCallbacks.push(profiler);
    }
    return () => removeProfiler(profiler);
  } else {
    profilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
const profiler = function (event, instance = null, eventFn) {
  for (let i = 0; i < profilerCallbacks.length; i++) {
    const profilerCallback = profilerCallbacks[i];
    profilerCallback(event, instance, eventFn);
  }
};
var ProfilerEvent = /*#__PURE__*/function (ProfilerEvent) {
  ProfilerEvent[ProfilerEvent["TemplateCreateStart"] = 0] = "TemplateCreateStart";
  ProfilerEvent[ProfilerEvent["TemplateCreateEnd"] = 1] = "TemplateCreateEnd";
  ProfilerEvent[ProfilerEvent["TemplateUpdateStart"] = 2] = "TemplateUpdateStart";
  ProfilerEvent[ProfilerEvent["TemplateUpdateEnd"] = 3] = "TemplateUpdateEnd";
  ProfilerEvent[ProfilerEvent["LifecycleHookStart"] = 4] = "LifecycleHookStart";
  ProfilerEvent[ProfilerEvent["LifecycleHookEnd"] = 5] = "LifecycleHookEnd";
  ProfilerEvent[ProfilerEvent["OutputStart"] = 6] = "OutputStart";
  ProfilerEvent[ProfilerEvent["OutputEnd"] = 7] = "OutputEnd";
  ProfilerEvent[ProfilerEvent["BootstrapApplicationStart"] = 8] = "BootstrapApplicationStart";
  ProfilerEvent[ProfilerEvent["BootstrapApplicationEnd"] = 9] = "BootstrapApplicationEnd";
  ProfilerEvent[ProfilerEvent["BootstrapComponentStart"] = 10] = "BootstrapComponentStart";
  ProfilerEvent[ProfilerEvent["BootstrapComponentEnd"] = 11] = "BootstrapComponentEnd";
  ProfilerEvent[ProfilerEvent["ChangeDetectionStart"] = 12] = "ChangeDetectionStart";
  ProfilerEvent[ProfilerEvent["ChangeDetectionEnd"] = 13] = "ChangeDetectionEnd";
  ProfilerEvent[ProfilerEvent["ChangeDetectionSyncStart"] = 14] = "ChangeDetectionSyncStart";
  ProfilerEvent[ProfilerEvent["ChangeDetectionSyncEnd"] = 15] = "ChangeDetectionSyncEnd";
  ProfilerEvent[ProfilerEvent["AfterRenderHooksStart"] = 16] = "AfterRenderHooksStart";
  ProfilerEvent[ProfilerEvent["AfterRenderHooksEnd"] = 17] = "AfterRenderHooksEnd";
  ProfilerEvent[ProfilerEvent["ComponentStart"] = 18] = "ComponentStart";
  ProfilerEvent[ProfilerEvent["ComponentEnd"] = 19] = "ComponentEnd";
  ProfilerEvent[ProfilerEvent["DeferBlockStateStart"] = 20] = "DeferBlockStateStart";
  ProfilerEvent[ProfilerEvent["DeferBlockStateEnd"] = 21] = "DeferBlockStateEnd";
  ProfilerEvent[ProfilerEvent["DynamicComponentStart"] = 22] = "DynamicComponentStart";
  ProfilerEvent[ProfilerEvent["DynamicComponentEnd"] = 23] = "DynamicComponentEnd";
  ProfilerEvent[ProfilerEvent["HostBindingsUpdateStart"] = 24] = "HostBindingsUpdateStart";
  ProfilerEvent[ProfilerEvent["HostBindingsUpdateEnd"] = 25] = "HostBindingsUpdateEnd";
  return ProfilerEvent;
}(ProfilerEvent || {});
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const {
    ngOnChanges,
    ngOnInit,
    ngDoCheck
  } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveDef, 'Expecting DirectiveDef');
    const lifecycleHooks = directiveDef.type.prototype;
    const {
      ngAfterContentInit,
      ngAfterContentChecked,
      ngAfterViewInit,
      ngAfterViewChecked,
      ngOnDestroy
    } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(initPhase, 3, 'Init pre-order hooks should not be called more than once');
  if ((lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(initPhase, 3, 'Init hooks phase should not be incremented after all init hooks have been run.');
  let flags = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)(), false, 'Hooks should never be run when in check no changes mode.');
  const startIndex = currentNodeIndex !== undefined ? currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max; i++) {
    const hook = arr[i + 1];
    if (typeof hook === 'number') {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] = (currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(ProfilerEvent.LifecycleHookStart, directive, hook);
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    hook.call(directive);
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    profiler(ProfilerEvent.LifecycleHookEnd, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PREORDER_HOOK_FLAGS] >> 16 && (currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 3) === initPhase) {
      currentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
const NO_PARENT_INJECTOR = -1;
class NodeInjectorFactory {
  factory;
  name;
  injectImpl;
  resolving = false;
  canSeeViewProviders;
  multi;
  componentProviders;
  index;
  providerFactory;
  constructor(factory, isViewProvider, injectImplementation, name) {
    this.factory = factory;
    this.name = name;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(factory, 'Factory not specified');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof factory, 'function', 'Expected factory function.');
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
}
function toTNodeTypeAsString(tNodeType) {
  let text = '';
  tNodeType & 1 && (text += '|Text');
  tNodeType & 2 && (text += '|Element');
  tNodeType & 4 && (text += '|Container');
  tNodeType & 8 && (text += '|ElementContainer');
  tNodeType & 16 && (text += '|Projection');
  tNodeType & 32 && (text += '|IcuContainer');
  tNodeType & 64 && (text += '|Placeholder');
  tNodeType & 128 && (text += '|LetDeclaration');
  return text.length > 0 ? text.substring(1) : text;
}
function isTNodeShape(value) {
  return value != null && typeof value === 'object' && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === 'number' || Array.isArray(value.insertBeforeIndex));
}
function isLetDeclaration(tNode) {
  return !!(tNode.type & 128);
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNode, 'should be called with a TNode');
  if ((tNode.type & expectedTypes) === 0) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === 'number') {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) ;else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === 'number') {
        srcMarker = item;
      } else {
        if (srcMarker === 0) ;else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === 'number') {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === 'number') {
      break;
    } else if (item === key1) {
      {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      }
    }
    i++;
    if (value !== null) i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(parentLocation, 'Number expected');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(parentLocation, -1, 'Not a valid state.');
    const parentInjectorIndex = parentLocation & 32767;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(parentInjectorIndex, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location, startView) {
  let viewOffset = getParentInjectorViewOffset(location);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
let includeViewProviders = true;
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
const BLOOM_SIZE = 256;
const BLOOM_MASK = BLOOM_SIZE - 1;
const BLOOM_BUCKET_BITS = 5;
let nextNgElementId = 0;
const NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.firstCreatePass, true, 'expected firstCreatePass to be true');
  let id;
  if (typeof type === 'string') {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID)) {
    id = type[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[injectorIndex + 8] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) {
    return -1;
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(parentTNode, lViewCursor[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(tNode, 12 | 3);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNode, 'expecting tNode');
  if (attrNameToInject === 'class') {
    return tNode.classes;
  }
  if (attrNameToInject === 'style') {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value)) break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === 'number') {
        i++;
        while (i < attrsLength && typeof attrs[i] === 'string') {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & 8 || notFoundValue !== undefined) {
    return notFoundValue;
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwProviderNotFoundError)(token, 'NodeInjector');
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & 8 && notFoundValue === undefined) {
    notFoundValue = null;
  }
  if ((flags & (2 | 1)) === 0) {
    const moduleInjector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    const previousInjectImplementation = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(undefined);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & 8);
      } else {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.injectRootLimpMode)(token, notFoundValue, flags & 8);
      }
    } finally {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = 0, notFoundValue) {
  if (tNode !== null) {
    if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2048 && !(flags & 2)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === 'function') {
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterDI)(lView, tNode, flags)) {
      return flags & 1 ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.runInInjectorProfilerContext)(new NodeInjector((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()), token, () => {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInjectorToCreateInstanceEvent)(token);
          value = bloomHash(flags);
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInstanceCreatedByInjectorEvent)(value);
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & 8)) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwProviderNotFoundError)(token);
      } else {
        return value;
      }
    } finally {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveDI)();
    }
  } else if (typeof bloomHash === 'number') {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & 1 ? lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] : null;
    if (injectorIndex === -1 || flags & 4) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNodeInjector)(lView, injectorIndex);
      const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tView.data[injectorIndex + 8], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[injectorIndex + 8];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tNode = currentTView.data[injectorIndex + 8];
  const canAccessViewProviders = previousTView == null ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
  const isHostSpecialCase = flags & 1 && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode, flags);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
let injectionPath = [];
function getNodeInjectable(lView, tView, index, tNode, flags) {
  let value = lView[index];
  const tData = tView.data;
  if (value instanceof NodeInjectorFactory) {
    const factory = value;
    ngDevMode && injectionPath.push(factory.name ?? 'unknown');
    if (factory.resolving) {
      const token = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(tData[index]);
      if (ngDevMode) {
        throw (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.cyclicDependencyErrorWithDetails)(token, injectionPath);
      } else {
        throw (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.cyclicDependencyError)(token);
      }
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    const token = tData[index].type || tData[index];
    let prevInjectContext;
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)({
        injector,
        token
      });
    }
    const previousInjectImplementation = factory.injectImpl ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(factory.injectImpl) : null;
    const success = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterDI)(lView, tNode, 0);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInjectorToCreateInstanceEvent)(token);
      value = lView[index] = factory.factory(undefined, flags, tData, lView, tNode);
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInstanceCreatedByInjectorEvent)(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDirectiveDef)(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)(prevInjectContext);
      previousInjectImplementation !== null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveDI)();
      ngDevMode && (injectionPath = []);
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(token, 'token must be defined');
  if (typeof token === 'string') {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = token.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID) ? token[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_ELEMENT_ID] : undefined;
  if (typeof tokenId === 'number') {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tokenId, -1, 'Expecting to get Special Injector Id');
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & 2) && !(flags & 1 && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
class NodeInjector {
  _tNode;
  _lView;
  constructor(_tNode, _lView) {
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToBitFlags)(flags), notFoundValue);
  }
}
function createNodeInjector() {
  return new NodeInjector((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
function ɵɵgetInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return t => new t();
  });
}
function getFactoryOf(type) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isForwardRef)(type)) {
    return () => {
      const factory = getFactoryOf((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type));
      return factory && factory();
    };
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getFactoryDef)(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2048 && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(currentLView)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | 2, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView.declTNode, 'Embedded TNodes should have declaration parents.');
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  }
  return null;
}
function ɵɵinjectAttribute(attrNameToInject) {
  return injectAttributeImpl((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), attrNameToInject);
}
const Attribute = /*#__PURE__*/makeParamDecorator('Attribute', attributeName => ({
  attributeName,
  __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName)
}));
let _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map(dep => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === undefined) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === 'Optional') {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === 'Self') {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === 'Host') {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === undefined) {
          throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === undefined || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PROV_DEF)) {
    Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: 'injectable',
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF)) {
    Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: 'injectable',
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      configurable: true
    });
  }
}
const USE_VALUE = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  provide: String,
  useValue: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== undefined;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== undefined;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== undefined;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || {
    providedIn: null
  };
  const compilerMeta = {
    name: type.name,
    type: type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
const Injectable = /*#__PURE__*/makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));
function injectElementRef() {
  return createElementRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
function createElementRef(tNode, lView) {
  return new ElementRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView));
}
let ElementRef = /*#__PURE__*/(() => {
  class ElementRef {
    nativeElement;
    constructor(nativeElement) {
      this.nativeElement = nativeElement;
    }
    static __NG_ELEMENT_ID__ = injectElementRef;
  }
  return ElementRef;
})();
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
class QueryList {
  _emitDistinctChangesOnly;
  dirty = true;
  _onDirty = undefined;
  _results = [];
  _changesDetected = false;
  _changes = undefined;
  length = 0;
  first = undefined;
  last = undefined;
  get changes() {
    return this._changes ??= new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
  }
  constructor(_emitDistinctChangesOnly = false) {
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
  }
  get(index) {
    return this._results[index];
  }
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  find(fn) {
    return this._results.find(fn);
  }
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  forEach(fn) {
    this._results.forEach(fn);
  }
  some(fn) {
    return this._results.some(fn);
  }
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(resultsTree);
    if (this._changesDetected = !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arrayEquals)(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  notifyOnChanges() {
    if (this._changes !== undefined && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.next(this);
  }
  onDirty(cb) {
    this._onDirty = cb;
  }
  setDirty() {
    this.dirty = true;
    this._onDirty?.();
  }
  destroy() {
    if (this._changes !== undefined) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
  [Symbol.iterator] = /*#__PURE__*/(() => symbolIterator)();
}
const SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';
const SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = 'ngskiphydration';
function hasSkipHydrationAttrOnTNode(tNode) {
  const attrs = tNode.mergedAttrs;
  if (attrs === null) return false;
  for (let i = 0; i < attrs.length; i += 2) {
    const value = attrs[i];
    if (typeof value === 'number') return false;
    if (typeof value === 'string' && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {
      return true;
    }
  }
  return false;
}
function hasSkipHydrationAttrOnRElement(rNode) {
  return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);
}
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
function isInSkipHydrationBlock(tNode) {
  if (hasInSkipHydrationBlockFlag(tNode)) {
    return true;
  }
  let currentTNode = tNode.parent;
  while (currentTNode) {
    if (hasInSkipHydrationBlockFlag(tNode) || hasSkipHydrationAttrOnTNode(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
function isI18nInSkipHydrationBlock(parentTNode) {
  return hasInSkipHydrationBlockFlag(parentTNode) || hasSkipHydrationAttrOnTNode(parentTNode) || isInSkipHydrationBlock(parentTNode);
}
var ChangeDetectionStrategy = /*#__PURE__*/function (ChangeDetectionStrategy) {
  ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
  return ChangeDetectionStrategy;
}(ChangeDetectionStrategy || {});
const TRACKED_LVIEWS = /*#__PURE__*/new Map();
let uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], 'LView must have an ID in order to be registered');
  TRACKED_LVIEWS.set(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], lView);
}
function getLViewById(id) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(id, 'ID used for LView lookup must be a number');
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], 'Cannot stop tracking an LView that does not have an ID');
  TRACKED_LVIEWS.delete(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
}
function getTrackedLViews() {
  return TRACKED_LVIEWS;
}
class LContext {
  lViewId;
  nodeIndex;
  native;
  component;
  directives;
  localRefs;
  get lView() {
    return getLViewById(this.lViewId);
  }
  constructor(lViewId, nodeIndex, native) {
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
}
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = undefined;
      let directives = undefined;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error('The provided component was not found in the application');
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error('The provided directive was not found in the application');
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context.component === undefined) {
        context.component = component;
        attachPatchData(context.component, context);
      }
      if (directives && context.directives === undefined) {
        context.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context);
        }
      }
      attachPatchData(context.native, context);
      mpValue = context;
    }
  } else {
    const rElement = target;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[index]);
          const context = createLContext(lView, index, native);
          attachPatchData(native, context);
          mpValue = context;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(nodeIndex, contextLView);
    const context = createLContext(contextLView, nodeIndex, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
    context.component = componentInstance;
    attachPatchData(componentInstance, context);
    attachPatchData(context.native, context);
  } else {
    const context = patchedData;
    const contextLView = context.lView;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(contextLView);
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(context.nodeIndex, contextLView);
  }
  return lView;
}
const MONKEY_PATCH_KEY_NAME = '__ngContext__';
function attachPatchData(target, data) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(target, 'Target expected');
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(target, 'Target expected');
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === 'number' ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵcmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.ɵdir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(elementComponentIndex, lView);
      if (componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
    if (rootComponent === componentInstance) {
      return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[nodeIndex];
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;
}
function discoverLocalRefs(lView, nodeIndex) {
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[nodeIndex];
  if (tNode && tNode.localNames) {
    const result = {};
    let localIndex = tNode.index + 1;
    for (let i = 0; i < tNode.localNames.length; i += 2) {
      result[tNode.localNames[i]] = lView[localIndex];
      localIndex++;
    }
    return result;
  }
  return null;
}
function getRootView(componentOrLView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(componentOrLView, 'component');
  let lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView)) {
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView);
  }
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT], 'Root view has no context. Perhaps it is disconnected?');
  return rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(viewOrContainer)) {
    viewOrContainer = viewOrContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
  }
  return viewOrContainer;
}
function getComponent(element) {
  ngDevMode && assertDomElement(element);
  const context = getLContext(element);
  if (context === null) return null;
  if (context.component === undefined) {
    const lView = context.lView;
    if (lView === null) {
      return null;
    }
    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);
  }
  return context.component;
}
function getContext(element) {
  assertDomElement(element);
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  return lView === null ? null : lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context = getLContext(elementOrDir);
  let lView = context ? context.lView : null;
  if (lView === null) return null;
  let parent;
  while (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].type === 2 && (parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView))) {
    lView = parent;
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView) ? null : lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context = getLContext(elementOrDir);
  const lView = context ? context.lView : null;
  if (lView === null) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector.NULL;
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[context.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getInjectionTokens(element) {
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  if (lView === null) return [];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tNode = tView.data[context.nodeIndex];
  const providerTokens = [];
  const startIndex = tNode.providerIndexes & 1048575;
  const endIndex = tNode.directiveEnd;
  for (let i = startIndex; i < endIndex; i++) {
    let value = tView.data[i];
    if (isDirectiveDefHack(value)) {
      value = value.type;
    }
    providerTokens.push(value);
  }
  return providerTokens;
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context = getLContext(node);
  const lView = context ? context.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const nodeIndex = context.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context.directives === undefined) {
    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context.directives === null ? [] : [...context.directives];
}
var AcxChangeDetectionStrategy = /*#__PURE__*/function (AcxChangeDetectionStrategy) {
  AcxChangeDetectionStrategy[AcxChangeDetectionStrategy["Default"] = 0] = "Default";
  AcxChangeDetectionStrategy[AcxChangeDetectionStrategy["OnPush"] = 1] = "OnPush";
  return AcxChangeDetectionStrategy;
}(AcxChangeDetectionStrategy || {});
var AcxViewEncapsulation = /*#__PURE__*/function (AcxViewEncapsulation) {
  AcxViewEncapsulation[AcxViewEncapsulation["Emulated"] = 0] = "Emulated";
  AcxViewEncapsulation[AcxViewEncapsulation["None"] = 1] = "None";
  return AcxViewEncapsulation;
}(AcxViewEncapsulation || {});
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const {
    constructor
  } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error('Unable to find the instance constructor');
  }
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return {
      inputs,
      outputs: directiveDef.outputs
    };
  }
  return null;
}
function getLocalRefs(target) {
  const context = getLContext(target);
  if (context === null) return {};
  if (context.localRefs === undefined) {
    const lView = context.lView;
    if (lView === null) {
      return {};
    }
    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);
  }
  return context.localRefs || {};
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null) return [];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length;) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === 'string') {
        const name = firstParam;
        const listenerElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';
        const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({
            element,
            name,
            callback,
            useCapture,
            type
          });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name) return 0;
  return a.name < b.name ? -1 : 1;
}
function isDirectiveDefHack(obj) {
  return obj.type !== undefined && obj.declaredInputs !== undefined && obj.resolveHostDirectives !== undefined;
}
function assertDomElement(value) {
  if (typeof Element !== 'undefined' && !(value instanceof Element)) {
    throw new Error('Expecting instance of DOM Element');
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (inputs.hasOwnProperty(key)) {
      const value = inputs[key];
      if (value !== undefined) {
        res[key] = value[0];
      }
    }
  }
  return res;
}
let DOCUMENT = undefined;
function setDocument(document) {
  DOCUMENT = document;
}
function getDocument() {
  if (DOCUMENT !== undefined) {
    return DOCUMENT;
  } else if (typeof document !== 'undefined') {
    return document;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(210, (typeof ngDevMode === 'undefined' || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
const APP_ID = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AppId' : '', {
  factory: () => DEFAULT_APP_ID
});
const DEFAULT_APP_ID = 'ng';
const validAppIdInitializer = {
  provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT_INITIALIZER,
  multi: true,
  useValue: () => {
    const appId = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(APP_ID);
    const isAlphanumeric = /^[a-zA-Z0-9\-_]+$/.test(appId);
    if (!isAlphanumeric) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(211, `APP_ID value "${appId}" is not alphanumeric. ` + `The APP_ID must be a string of alphanumeric characters. (a-zA-Z0-9), hyphens (-) and underscores (_) are allowed.`);
    }
  }
};
const PLATFORM_INITIALIZER = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Platform Initializer' : '');
const PLATFORM_ID = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Platform ID' : '', {
  providedIn: 'platform',
  factory: () => 'unknown'
});
const ANIMATION_MODULE_TYPE = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AnimationModuleType' : '');
const CSP_NONCE = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'CSP nonce' : '', {
  factory: () => {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT).body?.querySelector('[ngCspNonce]')?.getAttribute('ngCspNonce') || null;
  }
});
const IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
const IMAGE_CONFIG = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ImageConfig' : '', {
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
let TransferState = /*#__PURE__*/(() => {
  class TransferState {
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: TransferState,
      providedIn: 'root',
      factory: () => {
        const transferState = new TransferState();
        if (typeof ngServerMode === 'undefined' || !ngServerMode) {
          transferState.store = retrieveTransferredState((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(APP_ID));
        }
        return transferState;
      }
    });
    store = {};
    onSerializeCallbacks = {};
    get(key, defaultValue) {
      return this.store[key] !== undefined ? this.store[key] : defaultValue;
    }
    set(key, value) {
      this.store[key] = value;
    }
    remove(key) {
      delete this.store[key];
    }
    hasKey(key) {
      return this.store.hasOwnProperty(key);
    }
    get isEmpty() {
      return Object.keys(this.store).length === 0;
    }
    onSerialize(key, callback) {
      this.onSerializeCallbacks[key] = callback;
    }
    toJson() {
      for (const key in this.onSerializeCallbacks) {
        if (this.onSerializeCallbacks.hasOwnProperty(key)) {
          try {
            this.store[key] = this.onSerializeCallbacks[key]();
          } catch (e) {
            console.warn('Exception in onSerialize callback: ', e);
          }
        }
      }
      return JSON.stringify(this.store).replace(/</g, '\\u003C');
    }
  }
  return TransferState;
})();
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + '-state');
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn('Exception while restoring TransferState for app ' + appId, e);
    }
  }
  return {};
}
const REFERENCE_NODE_HOST = 'h';
const REFERENCE_NODE_BODY = 'b';
const NODE_NAVIGATION_STEP_FIRST_CHILD = 'f';
const NODE_NAVIGATION_STEP_NEXT_SIBLING = 'n';
const ELEMENT_CONTAINERS = 'e';
const TEMPLATES = 't';
const CONTAINERS = 'c';
const MULTIPLIER = 'x';
const NUM_ROOT_NODES = 'r';
const TEMPLATE_ID = 'i';
const NODES = 'n';
const DISCONNECTED_NODES = 'd';
const I18N_DATA = 'l';
const DEFER_BLOCK_ID = 'di';
const DEFER_BLOCK_STATE$1 = 's';
const DEFER_PARENT_BLOCK_ID = 'p';
const DEFER_HYDRATE_TRIGGERS = 't';
const IS_HYDRATION_DOM_REUSE_ENABLED = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');
const PRESERVE_HOST_CONTENT_DEFAULT = false;
const PRESERVE_HOST_CONTENT = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'PRESERVE_HOST_CONTENT' : '', {
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
const IS_I18N_HYDRATION_ENABLED = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_I18N_HYDRATION_ENABLED' : '');
const IS_EVENT_REPLAY_ENABLED = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_EVENT_REPLAY_ENABLED' : '');
const EVENT_REPLAY_ENABLED_DEFAULT = false;
const EVENT_REPLAY_QUEUE = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'EVENT_REPLAY_QUEUE' : '', {
  factory: () => []
});
const IS_INCREMENTAL_HYDRATION_ENABLED = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_INCREMENTAL_HYDRATION_ENABLED' : '');
const JSACTION_BLOCK_ELEMENT_MAP = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'JSACTION_BLOCK_ELEMENT_MAP' : '', {
  factory: () => new Map()
});
const IS_ENABLED_BLOCKING_INITIAL_NAVIGATION = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'IS_ENABLED_BLOCKING_INITIAL_NAVIGATION' : '');
const eventListenerOptions = {
  passive: true,
  capture: true
};
const hoverTriggers = /*#__PURE__*/new WeakMap();
const interactionTriggers = /*#__PURE__*/new WeakMap();
const viewportTriggers = /*#__PURE__*/new WeakMap();
const interactionEventNames = ['click', 'keydown'];
const hoverEventNames = ['mouseenter', 'mouseover', 'focusin'];
const intersectionObservers = /*#__PURE__*/new Map();
class DeferEventEntry {
  callbacks = /*#__PURE__*/new Set();
  listener = () => {
    for (const callback of this.callbacks) {
      callback();
    }
  };
}
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function createIntersectionObserver(options) {
  const key = getIntersectionObserverKey(options);
  return new IntersectionObserver(entries => {
    for (const current of entries) {
      if (current.isIntersecting && viewportTriggers.has(current.target)) {
        viewportTriggers.get(current.target)?.get(key)?.listener();
      }
    }
  }, options);
}
function onViewport(trigger, callback, observerFactoryFn, options) {
  const key = getIntersectionObserverKey(options);
  let entry = viewportTriggers.get(trigger)?.get(key);
  if (!intersectionObservers.has(key)) {
    intersectionObservers.set(key, {
      observer: observerFactoryFn(options),
      count: 0
    });
  }
  const config = intersectionObservers.get(key);
  if (!entry) {
    entry = new DeferEventEntry();
    config.observer.observe(trigger);
    let triggerConfig = viewportTriggers.get(trigger);
    if (triggerConfig) {
      triggerConfig.set(key, entry);
    } else {
      triggerConfig = new Map();
      viewportTriggers.set(trigger, triggerConfig);
    }
    triggerConfig.set(key, entry);
    config.count++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.get(trigger)?.has(key)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      config.observer.unobserve(trigger);
      config.count--;
      const triggerConfig = viewportTriggers.get(trigger);
      if (triggerConfig) {
        triggerConfig.delete(key);
        if (triggerConfig.size === 0) {
          viewportTriggers.delete(trigger);
        }
      }
    }
    if (config.count === 0) {
      config.observer.disconnect();
      intersectionObservers.delete(key);
    }
  };
}
function getIntersectionObserverKey(options) {
  if (!options) {
    return '';
  }
  return `${options.rootMargin}/${typeof options.threshold === 'number' ? options.threshold : options.threshold?.join('\n')}`;
}
const DEFER_BLOCK_SSR_ID_ATTRIBUTE = 'ngb';
function setJSActionAttributes(nativeElement, eventTypes, parentDeferBlockId = null) {
  if (eventTypes.length === 0 || nativeElement.nodeType !== Node.ELEMENT_NODE) {
    return;
  }
  const existingAttr = nativeElement.getAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.Attribute.JSACTION);
  const parts = eventTypes.reduce((prev, curr) => {
    return (existingAttr?.indexOf(curr) ?? -1) === -1 ? prev + curr + ':;' : prev;
  }, '');
  nativeElement.setAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.Attribute.JSACTION, `${existingAttr ?? ''}${parts}`);
  const blockName = parentDeferBlockId ?? '';
  if (blockName !== '' && parts.length > 0) {
    nativeElement.setAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE, blockName);
  }
}
const sharedStashFunction = (rEl, eventType, listenerFn) => {
  const el = rEl;
  const eventListenerMap = el.__jsaction_fns ?? new Map();
  const eventListeners = eventListenerMap.get(eventType) ?? [];
  eventListeners.push(listenerFn);
  eventListenerMap.set(eventType, eventListeners);
  el.__jsaction_fns = eventListenerMap;
};
const sharedMapFunction = (rEl, jsActionMap) => {
  const el = rEl;
  let blockName = el.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE) ?? '';
  const blockSet = jsActionMap.get(blockName) ?? new Set();
  if (!blockSet.has(el)) {
    blockSet.add(el);
  }
  jsActionMap.set(blockName, blockSet);
};
function removeListenersFromBlocks(blockNames, jsActionMap) {
  if (blockNames.length > 0) {
    let blockList = [];
    for (let blockName of blockNames) {
      if (jsActionMap.has(blockName)) {
        blockList = [...blockList, ...jsActionMap.get(blockName)];
      }
    }
    const replayList = new Set(blockList);
    replayList.forEach(removeListeners);
  }
}
const removeListeners = el => {
  el.removeAttribute(_attribute_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.Attribute.JSACTION);
  el.removeAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE);
  el.__jsaction_fns = undefined;
};
const JSACTION_EVENT_CONTRACT = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'EVENT_CONTRACT_DETAILS' : '', {
  factory: () => ({})
});
function invokeListeners(event, currentTarget) {
  const handlerFns = currentTarget?.__jsaction_fns?.get(event.type);
  if (!handlerFns || !currentTarget?.isConnected) {
    return;
  }
  for (const handler of handlerFns) {
    handler(event);
  }
}
const stashEventListeners = /*#__PURE__*/new Map();
function setStashFn(appId, fn) {
  stashEventListeners.set(appId, fn);
  return () => stashEventListeners.delete(appId);
}
let isStashEventListenerImplEnabled = false;
let _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {};
function stashEventListenerImpl(lView, target, eventName, wrappedListener) {
  _stashEventListenerImpl(lView, target, eventName, wrappedListener);
}
function enableStashEventListenerImpl() {
  if (!isStashEventListenerImplEnabled) {
    _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {
      const appId = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(APP_ID);
      const stashEventListener = stashEventListeners.get(appId);
      stashEventListener?.(target, eventName, wrappedListener);
    };
    isStashEventListenerImplEnabled = true;
  }
}
const DEHYDRATED_BLOCK_REGISTRY = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEHYDRATED_BLOCK_REGISTRY' : '');
let DehydratedBlockRegistry = /*#__PURE__*/(() => {
  class DehydratedBlockRegistry {
    registry = new Map();
    cleanupFns = new Map();
    jsActionMap = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(JSACTION_BLOCK_ELEMENT_MAP);
    contract = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(JSACTION_EVENT_CONTRACT);
    add(blockId, info) {
      this.registry.set(blockId, info);
      if (this.awaitingCallbacks.has(blockId)) {
        const awaitingCallbacks = this.awaitingCallbacks.get(blockId);
        for (const cb of awaitingCallbacks) {
          cb();
        }
      }
    }
    get(blockId) {
      return this.registry.get(blockId) ?? null;
    }
    has(blockId) {
      return this.registry.has(blockId);
    }
    cleanup(hydratedBlocks) {
      removeListenersFromBlocks(hydratedBlocks, this.jsActionMap);
      for (let blockId of hydratedBlocks) {
        this.registry.delete(blockId);
        this.jsActionMap.delete(blockId);
        this.invokeTriggerCleanupFns(blockId);
        this.hydrating.delete(blockId);
        this.awaitingCallbacks.delete(blockId);
      }
      if (this.size === 0) {
        this.contract.instance?.cleanUp();
      }
    }
    get size() {
      return this.registry.size;
    }
    addCleanupFn(blockId, fn) {
      let cleanupFunctions = [];
      if (this.cleanupFns.has(blockId)) {
        cleanupFunctions = this.cleanupFns.get(blockId);
      }
      cleanupFunctions.push(fn);
      this.cleanupFns.set(blockId, cleanupFunctions);
    }
    invokeTriggerCleanupFns(blockId) {
      const fns = this.cleanupFns.get(blockId) ?? [];
      for (let fn of fns) {
        fn();
      }
      this.cleanupFns.delete(blockId);
    }
    hydrating = new Map();
    awaitingCallbacks = new Map();
    awaitParentBlock(topmostParentBlock, callback) {
      const parentBlockAwaitCallbacks = this.awaitingCallbacks.get(topmostParentBlock) ?? [];
      parentBlockAwaitCallbacks.push(callback);
      this.awaitingCallbacks.set(topmostParentBlock, parentBlockAwaitCallbacks);
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: DehydratedBlockRegistry,
      providedIn: null,
      factory: () => new DehydratedBlockRegistry()
    });
  }
  return DehydratedBlockRegistry;
})();
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
const TRANSFER_STATE_TOKEN_ID = '__nghData__';
const NGH_DATA_KEY = /*#__PURE__*/makeStateKey(TRANSFER_STATE_TOKEN_ID);
const TRANSFER_STATE_DEFER_BLOCKS_INFO = '__nghDeferData__';
const NGH_DEFER_BLOCKS_KEY = /*#__PURE__*/makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);
function isInternalHydrationTransferStateKey(key) {
  return key === TRANSFER_STATE_TOKEN_ID || key === TRANSFER_STATE_DEFER_BLOCKS_INFO;
}
const NGH_ATTR_NAME = 'ngh';
const SSR_CONTENT_INTEGRITY_MARKER = 'nghm';
let _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfoImpl(rNode, injector, isRootView = false) {
  let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
  if (nghAttrValue == null) return null;
  const [componentViewNgh, rootViewNgh] = nghAttrValue.split('|');
  nghAttrValue = isRootView ? rootViewNgh : componentViewNgh;
  if (!nghAttrValue) return null;
  const rootNgh = rootViewNgh ? `|${rootViewNgh}` : '';
  const remainingNgh = isRootView ? componentViewNgh : rootNgh;
  let data = {};
  if (nghAttrValue !== '') {
    const transferState = injector.get(TransferState, null, {
      optional: true
    });
    if (transferState !== null) {
      const nghData = transferState.get(NGH_DATA_KEY, []);
      data = nghData[Number(nghAttrValue)];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(data, 'Unable to retrieve hydration info from the TransferState.');
    }
  }
  const dehydratedView = {
    data,
    firstChild: rNode.firstChild ?? null
  };
  if (isRootView) {
    dehydratedView.firstChild = rNode;
    setSegmentHead(dehydratedView, 0, rNode.nextSibling);
  }
  if (remainingNgh) {
    rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);
  } else {
    rNode.removeAttribute(NGH_ATTR_NAME);
  }
  ngDevMode && markRNodeAsClaimedByHydration(rNode, false);
  ngDevMode && ngDevMode.hydratedComponents++;
  return dehydratedView;
}
function enableRetrieveHydrationInfoImpl() {
  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;
}
function retrieveHydrationInfo(rNode, injector, isRootView = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView)) {
    lView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET];
  }
  return lView;
}
function getTextNodeContent(node) {
  return node.textContent?.replace(/\s/gm, '');
}
function processTextNodeMarkersBeforeHydration(node) {
  const doc = getDocument();
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode(node) {
      const content = getTextNodeContent(node);
      const isTextNodeMarker = content === "ngetn" || content === "ngtns";
      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    }
  });
  let currentNode;
  const nodes = [];
  while (currentNode = commentNodesIterator.nextNode()) {
    nodes.push(currentNode);
  }
  for (const node of nodes) {
    if (node.textContent === "ngetn") {
      node.replaceWith(doc.createTextNode(''));
    } else {
      node.remove();
    }
  }
}
var HydrationStatus = /*#__PURE__*/function (HydrationStatus) {
  HydrationStatus["Hydrated"] = "hydrated";
  HydrationStatus["Skipped"] = "skipped";
  HydrationStatus["Mismatched"] = "mismatched";
  return HydrationStatus;
}(HydrationStatus || {});
const HYDRATION_INFO_KEY = '__ngDebugHydrationInfo__';
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function readHydrationInfo(node) {
  return node[HYDRATION_INFO_KEY] ?? null;
}
function markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {
  if (!ngDevMode) {
    throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' + 'is not supported and likely a mistake.');
  }
  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
    throw new Error('Trying to claim a node, which was claimed already.');
  }
  patchHydrationInfo(node, {
    status: HydrationStatus.Hydrated
  });
  ngDevMode.hydratedNodes++;
}
function markRNodeAsSkippedByHydration(node) {
  if (!ngDevMode) {
    throw new Error('Calling `markRNodeAsSkippedByHydration` in prod mode ' + 'is not supported and likely a mistake.');
  }
  patchHydrationInfo(node, {
    status: HydrationStatus.Skipped
  });
  ngDevMode.componentsSkippedHydration++;
}
function countBlocksSkippedByHydration(injector) {
  const transferState = injector.get(TransferState);
  const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  if (ngDevMode) {
    ngDevMode.deferBlocksWithIncrementalHydration = Object.keys(nghDeferData).length;
  }
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error('Calling `markRNodeAsMismatchedByHydration` in prod mode ' + 'is not supported and likely a mistake.');
  }
  while (node && !getComponent(node)) {
    node = node?.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isRNodeClaimedForHydration(node) {
  return readHydrationInfo(node)?.status === HydrationStatus.Hydrated;
}
function setSegmentHead(hydrationInfo, index, node) {
  hydrationInfo.segmentHeads ??= {};
  hydrationInfo.segmentHeads[index] = node;
}
function getSegmentHead(hydrationInfo, index) {
  return hydrationInfo.segmentHeads?.[index] ?? null;
}
function isIncrementalHydrationEnabled(injector) {
  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {
    optional: true
  });
}
let incrementalHydrationEnabledWarned = false;
function resetIncrementalHydrationEnabledWarnedForTests() {
  incrementalHydrationEnabledWarned = false;
}
function warnIncrementalHydrationNotConfigured() {
  if (!incrementalHydrationEnabledWarned) {
    incrementalHydrationEnabledWarned = true;
    console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(508, 'Angular has detected that some `@defer` blocks use `hydrate` triggers, ' + 'but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` ' + 'call is added as an argument for the `provideClientHydration()` function call ' + 'in your application config.'));
  }
}
function assertSsrIdDefined(ssrUniqueId) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(ssrUniqueId, 'Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present');
}
function getNgContainerSize(hydrationInfo, index) {
  const data = hydrationInfo.data;
  let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;
  if (size === null && data[CONTAINERS]?.[index]) {
    size = calcSerializedContainerSize(hydrationInfo, index);
  }
  return size;
}
function isSerializedElementContainer(hydrationInfo, index) {
  return hydrationInfo.data[ELEMENT_CONTAINERS]?.[index] !== undefined;
}
function getSerializedContainerViews(hydrationInfo, index) {
  return hydrationInfo.data[CONTAINERS]?.[index] ?? null;
}
function calcSerializedContainerSize(hydrationInfo, index) {
  const views = getSerializedContainerViews(hydrationInfo, index) ?? [];
  let numNodes = 0;
  for (let view of views) {
    numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);
  }
  return numNodes;
}
function initDisconnectedNodes(hydrationInfo) {
  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return hydrationInfo.disconnectedNodes;
}
function isDisconnectedNode$1(hydrationInfo, index) {
  if (typeof hydrationInfo.disconnectedNodes === 'undefined') {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return !!initDisconnectedNodes(hydrationInfo)?.has(index);
}
function canHydrateNode(lView, tNode) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  return hydrationInfo !== null && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)() && !isDetachedByI18n(tNode) && !isDisconnectedNode$1(hydrationInfo, tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
}
function processTextNodeBeforeSerialization(context, node) {
  const el = node;
  const corruptedTextNodes = context.corruptedTextNodes;
  if (el.textContent === '') {
    corruptedTextNodes.set(el, "ngetn");
  } else if (el.nextSibling?.nodeType === Node.TEXT_NODE) {
    corruptedTextNodes.set(el, "ngtns");
  }
}
function convertHydrateTriggersToJsAction(triggers) {
  let actionList = [];
  if (triggers !== null) {
    if (triggers.has(4)) {
      actionList.push(...hoverEventNames);
    }
    if (triggers.has(3)) {
      actionList.push(...interactionEventNames);
    }
  }
  return actionList;
}
function getParentBlockHydrationQueue(deferBlockId, injector) {
  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
  const transferState = injector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  let isTopMostDeferBlock = false;
  let currentBlockId = deferBlockId;
  let parentBlockPromise = null;
  const hydrationQueue = [];
  while (!isTopMostDeferBlock && currentBlockId) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(hydrationQueue.indexOf(currentBlockId), -1, 'Internal error: defer block hierarchy has a cycle.');
    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);
    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);
    if (parentBlockPromise === null && hydratingParentBlock != null) {
      parentBlockPromise = hydratingParentBlock.promise;
      break;
    }
    hydrationQueue.unshift(currentBlockId);
    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];
  }
  return {
    parentBlockPromise,
    hydrationQueue
  };
}
function gatherDeferBlocksByJSActionAttribute(doc) {
  const jsactionNodes = doc.body.querySelectorAll('[jsaction]');
  const blockMap = new Set();
  const eventTypes = [hoverEventNames.join(':;'), interactionEventNames.join(':;')].join('|');
  for (let node of jsactionNodes) {
    const attr = node.getAttribute('jsaction');
    const blockId = node.getAttribute('ngb');
    if (attr?.match(eventTypes) && blockId !== null) {
      blockMap.add(node);
    }
  }
  return blockMap;
}
function appendDeferBlocksToJSActionMap(doc, injector) {
  const blockMap = gatherDeferBlocksByJSActionAttribute(doc);
  const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);
  for (let rNode of blockMap) {
    sharedMapFunction(rNode, jsActionMap);
  }
}
let _retrieveDeferBlockDataImpl = () => {
  return {};
};
function retrieveDeferBlockDataImpl(injector) {
  const transferState = injector.get(TransferState, null, {
    optional: true
  });
  if (transferState !== null) {
    const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(nghDeferData, 'Unable to retrieve defer block info from the TransferState.');
    return nghDeferData;
  }
  return {};
}
function enableRetrieveDeferBlockDataImpl() {
  _retrieveDeferBlockDataImpl = retrieveDeferBlockDataImpl;
}
function retrieveDeferBlockData(injector) {
  return _retrieveDeferBlockDataImpl(injector);
}
function isTimerTrigger(triggerInfo) {
  return typeof triggerInfo === 'object' && triggerInfo.trigger === 5;
}
function getHydrateTimerTrigger(blockData) {
  const trigger = blockData[DEFER_HYDRATE_TRIGGERS]?.find(t => isTimerTrigger(t));
  return trigger?.delay ?? null;
}
function getHydrateViewportTrigger(blockData) {
  const details = blockData[DEFER_HYDRATE_TRIGGERS];
  if (details) {
    for (const current of details) {
      if (current === 2) {
        return true;
      } else if (typeof current === 'object' && current.trigger === 2) {
        return current.intersectionObserverOptions || true;
      }
    }
  }
  return null;
}
function hasHydrateTrigger(blockData, trigger) {
  return blockData[DEFER_HYDRATE_TRIGGERS]?.includes(trigger) ?? false;
}
function createBlockSummary(blockInfo) {
  return {
    data: blockInfo,
    hydrate: {
      idle: hasHydrateTrigger(blockInfo, 0),
      immediate: hasHydrateTrigger(blockInfo, 1),
      timer: getHydrateTimerTrigger(blockInfo),
      viewport: getHydrateViewportTrigger(blockInfo)
    }
  };
}
function processBlockData(injector) {
  const blockData = retrieveDeferBlockData(injector);
  let blockDetails = new Map();
  for (let blockId in blockData) {
    blockDetails.set(blockId, createBlockSummary(blockData[blockId]));
  }
  return blockDetails;
}
function isSsrContentsIntegrity(node) {
  return !!node && node.nodeType === Node.COMMENT_NODE && node.textContent?.trim() === SSR_CONTENT_INTEGRITY_MARKER;
}
function skipTextNodes(node) {
  while (node && node.nodeType === Node.TEXT_NODE) {
    node = node.previousSibling;
  }
  return node;
}
function verifySsrContentsIntegrity(doc) {
  for (const node of doc.body.childNodes) {
    if (isSsrContentsIntegrity(node)) {
      return;
    }
  }
  const beforeBody = skipTextNodes(doc.body.previousSibling);
  if (isSsrContentsIntegrity(beforeBody)) {
    return;
  }
  let endOfHead = skipTextNodes(doc.head.lastChild);
  if (isSsrContentsIntegrity(endOfHead)) {
    return;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-507, typeof ngDevMode !== 'undefined' && ngDevMode && 'Angular hydration logic detected that HTML content of this page was modified after it ' + 'was produced during server side rendering. Make sure that there are no optimizations ' + 'that remove comment nodes from HTML enabled on your CDN. Angular hydration ' + 'relies on HTML produced by the server, including whitespaces and comment nodes.');
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveDef, 'DirectiveDef not found.');
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveDef.contentQueries, 'contentQueries function should be defined');
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(viewQueryFn, 'View queries function to execute must be defined.');
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)(0);
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isContentQueryHost)(tNode)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(directiveIndex, 'Incorrect reference to a directive defining a content query');
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
var ViewEncapsulation = /*#__PURE__*/function (ViewEncapsulation) {
  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
  ViewEncapsulation[ViewEncapsulation["ExperimentalIsolatedShadowDom"] = 4] = "ExperimentalIsolatedShadowDom";
  return ViewEncapsulation;
}(ViewEncapsulation || {});
const CUSTOM_ELEMENTS_SCHEMA = {
  name: 'custom-elements'
};
const NO_ERRORS_SCHEMA = {
  name: 'no-errors-schema'
};
let shouldThrowErrorOnUnknownElement = false;
function ɵsetUnknownElementStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownElement = shouldThrow;
}
function ɵgetUnknownElementStrictMode() {
  return shouldThrowErrorOnUnknownElement;
}
let shouldThrowErrorOnUnknownProperty = false;
function ɵsetUnknownPropertyStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownProperty = shouldThrow;
}
function ɵgetUnknownPropertyStrictMode() {
  return shouldThrowErrorOnUnknownProperty;
}
function validateElementIsKnown(lView, tNode) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView.schemas === null) return;
  const tagName = tNode.value;
  if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode) && tagName !== null) {
    const isUnknown = typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView) instanceof HTMLUnknownElement || typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 && !customElements.get(tagName);
    if (isUnknown && !matchingSchemas(tView.schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:\n`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : 'a part of an @NgModule where this component is declared'}.\n`;
      if (tagName && tagName.indexOf('-') > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(304, message);
      } else {
        console.error((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null) return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = 'ng-template';
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : 'a part of an @NgModule where this component is declared';
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `\nIf the '${propName}' is an Angular control flow directive, ` + `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `\n1. If '${tagName}' is an Angular component and it has the ` + `'${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf('-') > -1) {
      message += `\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` + `to the ${schemas} of this component to suppress this message.`;
      message += `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;
    } else {
      message += `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` + `the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(303, message);
  } else {
    console.error((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Must never be called in production mode');
  const declarationLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  if (!context) return null;
  return context.constructor ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(context.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Must never be called in production mode');
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Must never be called in production mode');
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';
}
const KNOWN_CONTROL_FLOW_DIRECTIVES = /*#__PURE__*/new Map([['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'], ['ngSwitchDefault', 'NgSwitchDefault']]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {
        return true;
      }
    }
  }
  return false;
}
let policy$1;
function getPolicy$1() {
  if (policy$1 === undefined) {
    policy$1 = null;
    if (_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes) {
      try {
        policy$1 = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes.createPolicy('angular', {
          createHTML: s => s,
          createScript: s => s,
          createScriptURL: s => s
        });
      } catch {}
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
let policy;
function getPolicy() {
  if (policy === undefined) {
    policy = null;
    if (_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes) {
      try {
        policy = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.trustedTypes.createPolicy('angular#unsafe-bypass', {
          createHTML: s => s,
          createScript: s => s,
          createScriptURL: s => s
        });
      } catch {}
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
class SafeValueImpl {
  changingThisBreaksApplicationSecurity;
  constructor(changingThisBreaksApplicationSecurity) {
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + ` (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`;
  }
}
class SafeHtmlImpl extends SafeValueImpl {
  getTypeName() {
    return "HTML";
  }
}
class SafeStyleImpl extends SafeValueImpl {
  getTypeName() {
    return "Style";
  }
}
class SafeScriptImpl extends SafeValueImpl {
  getTypeName() {
    return "Script";
  }
}
class SafeUrlImpl extends SafeValueImpl {
  getTypeName() {
    return "URL";
  }
}
class SafeResourceUrlImpl extends SafeValueImpl {
  getTypeName() {
    return "ResourceURL";
  }
}
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL") return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
class DOMParserHelper {
  inertDocumentHelper;
  constructor(inertDocumentHelper) {
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    html = '<body><remove></remove>' + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      body.firstChild?.remove();
      return body;
    } catch {
      return null;
    }
  }
}
class InertDocumentHelper {
  defaultDoc;
  inertDocument;
  constructor(defaultDoc) {
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement('template');
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
}
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');
  } catch {
    return false;
  }
}
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN)) return url;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
  }
  return 'unsafe:' + url;
}
function tagSet(tags) {
  const res = {};
  for (const t of tags.split(',')) res[t] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v)) res[v] = true;
    }
  }
  return res;
}
const VOID_ELEMENTS = /*#__PURE__*/tagSet('area,br,col,hr,img,wbr');
const OPTIONAL_END_TAG_BLOCK_ELEMENTS = /*#__PURE__*/tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
const OPTIONAL_END_TAG_INLINE_ELEMENTS = /*#__PURE__*/tagSet('rp,rt');
const OPTIONAL_END_TAG_ELEMENTS = /*#__PURE__*/merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
const BLOCK_ELEMENTS = /*#__PURE__*/merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, /*#__PURE__*/tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
const INLINE_ELEMENTS = /*#__PURE__*/merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, /*#__PURE__*/tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
const VALID_ELEMENTS = /*#__PURE__*/merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
const URI_ATTRS = /*#__PURE__*/tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
const HTML_ATTRS = /*#__PURE__*/tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');
const ARIA_ATTRS = /*#__PURE__*/tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' + 'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' + 'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' + 'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' + 'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' + 'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' + 'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');
const VALID_ATTRS = /*#__PURE__*/merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = /*#__PURE__*/tagSet('script,style,template');
class SanitizingHtmlSerializer {
  sanitizedSomething = false;
  buf = [];
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join('');
  }
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push('<');
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i = 0; i < elAttrs.length; i++) {
      const elAttr = elAttrs.item(i);
      const attrName = elAttr.name;
      const lower = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value = elAttr.value;
      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
      this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
    }
    this.buf.push('>');
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push('</');
      this.buf.push(tagName);
      this.buf.push('>');
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
}
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === 'string' ? nodeName : 'FORM';
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
  return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match) {
    const hi = match.charCodeAt(0);
    const low = match.charCodeAt(1);
    return '&#' + ((hi - 0xd800) * 0x400 + (low - 0xdc00) + 0x10000) + ';';
  }).replace(NON_ALPHANUMERIC_REGEXP, function (match) {
    return '&#' + match.charCodeAt(0) + ';';
  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
let inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error('Failed to sanitize html because the input is unstable');
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return 'content' in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';
}
const COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
const COMMENT_DELIMITER = /(<|>)/g;
const COMMENT_DELIMITER_ESCAPED = '\u200B$1\u200B';
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, text => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function createTextNode(renderer, value) {
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  return renderer.createElement(name, namespace);
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(parent, 'parent node must be defined');
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeRemoveNode(renderer, rNode, isHostElement, requireSynchronousElementRemoval) {
  renderer.removeChild(null, rNode, isHostElement, requireSynchronousElementRemoval);
}
function clearElementContents(rElement) {
  rElement.textContent = '';
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, 'style', newValue);
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(newValue, "'newValue' should be a string");
  if (newValue === '') {
    renderer.removeAttribute(element, 'class');
  } else {
    renderer.setAttribute(element, 'class', newValue);
  }
}
function setupStaticAttributes(renderer, element, tNode) {
  const {
    mergedAttrs,
    classes,
    styles
  } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
function enforceIframeSecurity(iframe) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  iframe.src = '';
  iframe.srcdoc = trustedHTMLFromString('');
  nativeRemoveNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], iframe);
}
var SecurityContext = /*#__PURE__*/function (SecurityContext) {
  SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
  SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
  SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
  SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext[SecurityContext["URL"] = 4] = "URL";
  SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  return SecurityContext;
}(SecurityContext || {});
function ɵɵsanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeHtml, "HTML")) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(unsafeHtml));
}
function ɵɵsanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeStyle, "Style")) {
    return unwrapSafeValue(unsafeStyle);
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(unsafeStyle);
}
function ɵɵsanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeUrl, "URL")) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(unsafeUrl));
}
function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, "ResourceURL")) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
}
function ɵɵsanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeScript, "Script")) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(905, ngDevMode && 'unsafe value used in a script context');
}
function ɵɵtrustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);
  }
  return trustedHTMLFromString(html[0]);
}
function ɵɵtrustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);
  }
  return trustedScriptURLFromString(url[0]);
}
const SRC_RESOURCE_TAGS = /*#__PURE__*/new Set(['embed', 'frame', 'iframe', 'media', 'script']);
const HREF_RESOURCE_TAGS = /*#__PURE__*/new Set(['base', 'link', 'script']);
function getUrlSanitizer(tag, prop) {
  const isResource = prop === 'src' && SRC_RESOURCE_TAGS.has(tag) || prop === 'href' && HREF_RESOURCE_TAGS.has(tag) || prop === 'xlink:href' && tag === 'script';
  return isResource ? ɵɵsanitizeResourceUrl : ɵɵsanitizeUrl;
}
function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...` + `\nIf '${name}' is a directive input, make sure the directive is imported by the` + ` current module.`;
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` + `please use (${name.slice(2)})=...`;
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  return lView && lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].sanitizer;
}
const attributeName = /*#__PURE__*/new Set(['attributename']);
const SECURITY_SENSITIVE_ELEMENTS = {
  'iframe': /*#__PURE__*/new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']),
  'animate': attributeName,
  'set': attributeName,
  'animatemotion': attributeName,
  'animatetransform': attributeName
};
function ɵɵvalidateAttribute(value, tagName, attributeName) {
  const lowerCaseTagName = tagName.toLowerCase();
  const lowerCaseAttrName = attributeName.toLowerCase();
  if (!SECURITY_SENSITIVE_ELEMENTS[lowerCaseTagName]?.has(lowerCaseAttrName)) {
    return value;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (tNode.type !== 2) {
    return value;
  }
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (lowerCaseTagName === 'iframe') {
    const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    enforceIframeSecurity(element);
  }
  const errorMessage = ngDevMode && `Angular has detected that the \`${attributeName}\` was applied ` + `as a binding to the <${tagName}> element${getTemplateLocationDetails(lView)}. ` + `For security reasons, the \`${attributeName}\` can be set on the <${tagName}> element ` + `as a static attribute only. \n` + `To fix this, switch the \`${attributeName}\` binding to a static attribute ` + `in a template or in host bindings section.`;
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-910, errorMessage);
}
const NG_REFLECT_ATTRS_FLAG_DEFAULT = false;
const NG_REFLECT_ATTRS_FLAG = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'NG_REFLECT_FLAG' : '', {
  factory: () => NG_REFLECT_ATTRS_FLAG_DEFAULT
});
function provideNgReflectAttributes() {
  const providers = typeof ngDevMode === 'undefined' || ngDevMode ? [{
    provide: NG_REFLECT_ATTRS_FLAG,
    useValue: true
  }] : [];
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)(providers);
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
  return `ng-reflect-${name}`;
}
const CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return '[ERROR] Exception while trying to serialize the value';
  }
}
function ɵɵresolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function ɵɵresolveDocument(element) {
  return element.ownerDocument;
}
function ɵɵresolveBody(element) {
  return element.ownerDocument.body;
}
const INTERPOLATION_DELIMITER = `�`;
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
const VALUE_STRING_LENGTH_LIMIT = 200;
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
  if (!componentDef.standalone) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(907, `The ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} component is not marked as standalone, ` + `but Angular expects to have a standalone component here. ` + `Please make sure the ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} component does not have ` + `the \`standalone: false\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type)) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(906, `The ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} is not an Angular component, ` + `make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first, second) {
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ` + `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(first)} and ` + `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : '';
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ''}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked.` + ` Has it been created in a change detection hook?`;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === '[object Object]') {
      strValue = JSON.stringify(value);
    }
  } catch (error) {}
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + '…' : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix,
    newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return {
    propName,
    oldValue,
    newValue
  };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === 'string') {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return {
      propName: metadata,
      oldValue,
      newValue
    };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === 'string') {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return {
    propName: undefined,
    oldValue,
    newValue
  };
}
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(classToSearch, '', 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1) return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
const NG_TEMPLATE_SELECTOR = 'ng-template';
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === 'string'; i += 2) {
      if (attrs[i] === 'class' && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === 'string') {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(selector[0], 'Selector should have a tag name');
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === 'number') {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current)) continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector) continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== '') {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = '';
        } else {
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(nodeAttrs[attrIndexInNode], 0, 'We do not match directives on namespaced attributes');
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
  if (attrs === null) return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === 'string') {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(4);
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === 'number') return -1;
      if (attr === name) return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = '';
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === 'string') {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += '[' + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : '') + ']';
      } else if (mode & 8) {
        currentChunk += '.' + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += ' ' + valueOrMarker;
      }
    } else {
      if (currentChunk !== '' && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = '';
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== '') {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(',');
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === 'string') {
      if (mode === 2) {
        if (valueOrMarker !== '') {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode)) break;
      mode = valueOrMarker;
    }
    i++;
  }
  if (classes.length) {
    attrs.push(1, ...classes);
  }
  return attrs;
}
const NO_CHANGE = typeof ngDevMode === 'undefined' || ngDevMode ? {
  __brand__: 'NO_CHANGE'
} : {};
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  const bindingStartIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW] = {
    type: type,
    blueprint: blueprint,
    template: templateFn,
    queries: null,
    viewQuery: viewQuery,
    declTNode: declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex: bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === 'function' ? directives() : directives,
    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
    firstChild: null,
    schemas: schemas,
    consts: consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] = host;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;
  if (embeddedViewInjector !== null || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2048) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 2048;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resetPreOrderHookFlags)(lView);
  ngDevMode && tView.declTNode && parentLView && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tView.declTNode, parentLView);
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_VIEW] = parentLView;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = context;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT] = environment || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT], 'LViewEnvironment is required');
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER] = renderer || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], 'Renderer is required');
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1] = injector || parentLView && parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1] || null;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] = tHostNode;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID] = getUniqueLViewId();
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION] = hydrationInfo;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.type == 2 ? parentLView !== null : true, true, 'Embedded views must have parentLView');
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function createComponentLView(lView, hostTNode, def) {
  const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].rendererFactory;
  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  return lView[hostTNode.index] = componentView;
}
function getInitialLViewFlagsFromDef(def) {
  let flags = 16;
  if (def.signals) {
    flags = 4096;
  } else if (def.onPush) {
    flags = 64;
  }
  return flags;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0) return -1;
  if (ngDevMode) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSame)(tView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], '`LView` must be associated with `TView`!');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.data.length, lView.length, 'Expecting LView to be same size as TView');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstUpdatePass)(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function addToEndOfViewTree(lView, lViewOrLContainer) {
  if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD]) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = lViewOrLContainer;
  } else {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD] = lViewOrLContainer;
  }
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function ɵɵadvance(delta = 1) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(delta, 0, 'Can only advance forward');
  selectIndexInternal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)() + delta, !!ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(index);
}
var InputFlags = /*#__PURE__*/function (InputFlags) {
  InputFlags[InputFlags["None"] = 0] = "None";
  InputFlags[InputFlags["SignalBased"] = 1] = "SignalBased";
  InputFlags[InputFlags["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
  return InputFlags;
}(InputFlags || {});
function writeToDirectiveInput(def, instance, publicName, value) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    if (ngDevMode) {
      if (!def.inputs.hasOwnProperty(publicName)) {
        throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of "${publicName}"`);
      }
      if (instance instanceof NodeInjectorFactory) {
        throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`);
      }
    }
    const [privateName, flags, transform] = def.inputs[publicName];
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== undefined) {
      value = inputSignalNode.transformFn(value);
    } else if (transform !== null) {
      value = transform.call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
var RendererStyleFlags2 = /*#__PURE__*/function (RendererStyleFlags2) {
  RendererStyleFlags2[RendererStyleFlags2["Important"] = 1] = "Important";
  RendererStyleFlags2[RendererStyleFlags2["DashCase"] = 2] = "DashCase";
  return RendererStyleFlags2;
}(RendererStyleFlags2 || {});
let _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === undefined) {
    _icuContainerIterate = loader();
  }
}
function parseCssTimeUnitsToMs(value) {
  if (!value) return 0;
  const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;
  return parseFloat(value) * multiplier;
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(',').map(part => part.trim());
}
function getLongestComputedTransition(computedStyle) {
  const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');
  const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');
  const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');
  const longest = {
    propertyName: '',
    duration: 0,
    animationName: undefined
  };
  for (let i = 0; i < transitionedProperties.length; i++) {
    const duration = parseCssTimeUnitsToMs(rawDelays[i]) + parseCssTimeUnitsToMs(rawDurations[i]);
    if (duration > longest.duration) {
      longest.propertyName = transitionedProperties[i];
      longest.duration = duration;
    }
  }
  return longest;
}
function getLongestComputedAnimation(computedStyle) {
  const rawNames = parseCssPropertyValue(computedStyle, 'animation-name');
  const rawDelays = parseCssPropertyValue(computedStyle, 'animation-delay');
  const rawDurations = parseCssPropertyValue(computedStyle, 'animation-duration');
  const longest = {
    animationName: '',
    propertyName: undefined,
    duration: 0
  };
  for (let i = 0; i < rawNames.length; i++) {
    const duration = parseCssTimeUnitsToMs(rawDelays[i]) + parseCssTimeUnitsToMs(rawDurations[i]);
    if (duration > longest.duration) {
      longest.animationName = rawNames[i];
      longest.duration = duration;
    }
  }
  return longest;
}
function isShorterThanExistingAnimation(existing, longest) {
  return existing !== undefined && existing.duration > longest.duration;
}
function longestExists(longest) {
  return (longest.animationName != undefined || longest.propertyName != undefined) && longest.duration > 0;
}
function determineLongestAnimationFromComputedStyles(el, animationsMap) {
  const computedStyle = getComputedStyle(el);
  const longestAnimation = getLongestComputedAnimation(computedStyle);
  const longestTransition = getLongestComputedTransition(computedStyle);
  const longest = longestAnimation.duration > longestTransition.duration ? longestAnimation : longestTransition;
  if (isShorterThanExistingAnimation(animationsMap.get(el), longest)) return;
  if (longestExists(longest)) {
    animationsMap.set(el, longest);
  }
}
function determineLongestAnimation(el, animationsMap, areAnimationSupported) {
  if (!areAnimationSupported) return;
  const animations = el.getAnimations();
  return animations.length === 0 ? determineLongestAnimationFromComputedStyles(el, animationsMap) : determineLongestAnimationFromElementAnimations(el, animationsMap, animations);
}
function determineLongestAnimationFromElementAnimations(el, animationsMap, animations) {
  let longest = {
    animationName: undefined,
    propertyName: undefined,
    duration: 0
  };
  for (const animation of animations) {
    const timing = animation.effect?.getTiming();
    const animDuration = typeof timing?.duration === 'number' ? timing.duration : 0;
    let duration = (timing?.delay ?? 0) + animDuration;
    let propertyName;
    let animationName;
    if (animation.animationName) {
      animationName = animation.animationName;
    } else {
      propertyName = animation.transitionProperty;
    }
    if (duration >= longest.duration) {
      longest = {
        animationName,
        propertyName,
        duration
      };
    }
  }
  if (isShorterThanExistingAnimation(animationsMap.get(el), longest)) return;
  if (longestExists(longest)) {
    animationsMap.set(el, longest);
  }
}
const allLeavingAnimations = /*#__PURE__*/new Set();
var TracingAction = /*#__PURE__*/function (TracingAction) {
  TracingAction[TracingAction["CHANGE_DETECTION"] = 0] = "CHANGE_DETECTION";
  TracingAction[TracingAction["AFTER_NEXT_RENDER"] = 1] = "AFTER_NEXT_RENDER";
  return TracingAction;
}(TracingAction || {});
const TracingService = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'TracingService' : '');
const markedFeatures = /*#__PURE__*/new Set();
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.('mark_feature_usage', {
    detail: {
      feature
    }
  });
}
let AfterRenderManager = /*#__PURE__*/(() => {
  class AfterRenderManager {
    impl = null;
    execute() {
      this.impl?.execute();
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: AfterRenderManager,
      providedIn: 'root',
      factory: () => new AfterRenderManager()
    });
  }
  return AfterRenderManager;
})();
const AFTER_RENDER_PHASES = /* @__PURE__ **/(() => [0, 1, 2, 3])();
let AfterRenderImpl = /*#__PURE__*/(() => {
  class AfterRenderImpl {
    ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
    scheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionScheduler);
    errorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler, {
      optional: true
    });
    sequences = new Set();
    deferredRegistrations = new Set();
    executing = false;
    constructor() {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(TracingService, {
        optional: true
      });
    }
    execute() {
      const hasSequencesToExecute = this.sequences.size > 0;
      if (hasSequencesToExecute) {
        profiler(ProfilerEvent.AfterRenderHooksStart);
      }
      this.executing = true;
      for (const phase of AFTER_RENDER_PHASES) {
        for (const sequence of this.sequences) {
          if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {
            continue;
          }
          try {
            sequence.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => {
              const hookFn = sequence.hooks[phase];
              const value = hookFn(sequence.pipelinedValue);
              return value;
            }, sequence.snapshot));
          } catch (err) {
            sequence.erroredOrDestroyed = true;
            this.errorHandler?.handleError(err);
          }
        }
      }
      this.executing = false;
      for (const sequence of this.sequences) {
        sequence.afterRun();
        if (sequence.once) {
          this.sequences.delete(sequence);
          sequence.destroy();
        }
      }
      for (const sequence of this.deferredRegistrations) {
        this.sequences.add(sequence);
      }
      if (this.deferredRegistrations.size > 0) {
        this.scheduler.notify(7);
      }
      this.deferredRegistrations.clear();
      if (hasSequencesToExecute) {
        profiler(ProfilerEvent.AfterRenderHooksEnd);
      }
    }
    register(sequence) {
      const {
        view
      } = sequence;
      if (view !== undefined) {
        (view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD] ??= []).push(sequence);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markAncestorsForTraversal)(view);
        view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 8192;
      } else if (!this.executing) {
        this.addSequence(sequence);
      } else {
        this.deferredRegistrations.add(sequence);
      }
    }
    addSequence(sequence) {
      this.sequences.add(sequence);
      this.scheduler.notify(7);
    }
    unregister(sequence) {
      if (this.executing && this.sequences.has(sequence)) {
        sequence.erroredOrDestroyed = true;
        sequence.pipelinedValue = undefined;
        sequence.once = true;
      } else {
        this.sequences.delete(sequence);
        this.deferredRegistrations.delete(sequence);
      }
    }
    maybeTrace(fn, snapshot) {
      return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: AfterRenderImpl,
      providedIn: 'root',
      factory: () => new AfterRenderImpl()
    });
  }
  return AfterRenderImpl;
})();
class AfterRenderSequence {
  impl;
  hooks;
  view;
  once;
  snapshot;
  erroredOrDestroyed = false;
  pipelinedValue = undefined;
  unregisterOnDestroy;
  constructor(impl, hooks, view, once, destroyRef, snapshot = null) {
    this.impl = impl;
    this.hooks = hooks;
    this.view = view;
    this.once = once;
    this.snapshot = snapshot;
    this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
  }
  afterRun() {
    this.erroredOrDestroyed = false;
    this.pipelinedValue = undefined;
    this.snapshot?.dispose();
    this.snapshot = null;
  }
  destroy() {
    this.impl.unregister(this);
    this.unregisterOnDestroy?.();
    const scheduled = this.view?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD];
    if (scheduled) {
      this.view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled.filter(s => s !== this);
    }
  }
}
function afterEveryRender(callbackOrSpec, options) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotInReactiveContext)(afterEveryRender, 'Call `afterEveryRender` outside of a reactive context. For example, schedule the render ' + 'callback inside the component constructor`.');
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(afterEveryRender);
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature('NgAfterRender');
  return afterEveryRenderImpl(callbackOrSpec, injector, options, false);
}
function afterNextRender(callbackOrSpec, options) {
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(afterNextRender);
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature('NgAfterNextRender');
  return afterEveryRenderImpl(callbackOrSpec, injector, options, true);
}
function getHooks(callbackOrSpec) {
  if (callbackOrSpec instanceof Function) {
    return [undefined, undefined, callbackOrSpec, undefined];
  } else {
    return [callbackOrSpec.earlyRead, callbackOrSpec.write, callbackOrSpec.mixedReadWrite, callbackOrSpec.read];
  }
}
function afterEveryRenderImpl(callbackOrSpec, injector, options, once) {
  const manager = injector.get(AfterRenderManager);
  manager.impl ??= injector.get(AfterRenderImpl);
  const tracing = injector.get(TracingService, null, {
    optional: true
  });
  const destroyRef = options?.manualCleanup !== true ? injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef) : null;
  const viewContext = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewContext, null, {
    optional: true
  });
  const sequence = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec), viewContext?.view, once, destroyRef, tracing?.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
const NOOP_AFTER_RENDER_REF = {
  destroy() {}
};
const ANIMATION_QUEUE = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AnimationQueue' : '', {
  factory: () => {
    return {
      queue: new Set(),
      isScheduled: false,
      scheduler: null,
      injector: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector)
    };
  }
});
function addToAnimationQueue(injector, animationFns, animationData) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (Array.isArray(animationFns)) {
    for (const animateFn of animationFns) {
      animationQueue.queue.add(animateFn);
      animationData?.detachedLeaveAnimationFns?.push(animateFn);
    }
  } else {
    animationQueue.queue.add(animationFns);
    animationData?.detachedLeaveAnimationFns?.push(animationFns);
  }
  animationQueue.scheduler && animationQueue.scheduler(injector);
}
function removeFromAnimationQueue(injector, animationData) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (animationData.detachedLeaveAnimationFns) {
    for (const animationFn of animationData.detachedLeaveAnimationFns) {
      animationQueue.queue.delete(animationFn);
    }
    animationData.detachedLeaveAnimationFns = undefined;
  }
}
function scheduleAnimationQueue(injector) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (!animationQueue.isScheduled) {
    afterNextRender(() => {
      animationQueue.isScheduled = false;
      for (let animateFn of animationQueue.queue) {
        animateFn();
      }
      animationQueue.queue.clear();
    }, {
      injector: animationQueue.injector
    });
    animationQueue.isScheduled = true;
  }
}
function initializeAnimationQueueScheduler(injector) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  animationQueue.scheduler = scheduleAnimationQueue;
  animationQueue.scheduler(injector);
}
function queueEnterAnimations(injector, enterAnimations) {
  for (const [_, nodeAnimations] of enterAnimations) {
    addToAnimationQueue(injector, nodeAnimations.animateFns);
  }
}
function maybeQueueEnterAnimation(parentLView, parent, tNode, injector) {
  const enterAnimations = parentLView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS]?.enter;
  if (parent !== null && enterAnimations && enterAnimations.has(tNode.index)) {
    queueEnterAnimations(injector, enterAnimations);
  }
}
function applyToElementOrContainer(action, renderer, injector, parent, lNodeToHandle, tNode, beforeNode, parentLView) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent = false;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lNodeToHandle)) {
      isComponent = true;
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lNodeToHandle[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST], 'HOST must be defined for a component LView');
      lNodeToHandle = lNodeToHandle[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
    }
    const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lNodeToHandle);
    if (action === 0 && parent !== null) {
      maybeQueueEnterAnimation(parentLView, parent, tNode, injector);
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      maybeQueueEnterAnimation(parentLView, parent, tNode, injector);
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      runLeaveAnimationsWithCallback(parentLView, tNode, injector, nodeHasLeaveAnimations => {
        nativeRemoveNode(renderer, rNode, isComponent, nodeHasLeaveAnimations);
      });
    } else if (action === 3) {
      runLeaveAnimationsWithCallback(parentLView, tNode, injector, () => {
        renderer.destroyNode(rNode);
      });
    }
    if (lContainer != null) {
      applyContainer(renderer, action, injector, lContainer, tNode, parent, beforeNode);
    }
  }
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] = null;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] = parentNativeNode;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].changeDetectionScheduler?.notify(9);
  applyView(tView, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lViewOrLContainer)) {
      next = lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD];
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lViewOrLContainer);
      const firstView = lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET];
      if (firstView) next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] && lViewOrLContainer !== rootView) {
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
      }
      if (lViewOrLContainer === null) lViewOrLContainer = rootView;
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
    }
    lViewOrLContainer = next;
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationContainer);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');
  const movedViews = declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function destroyLView(tView, lView) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(lView)) {
    return;
  }
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  if (renderer.destroyNode) {
    applyView(tView, lView, renderer, 3, null, null);
  }
  destroyViewTree(lView);
}
function cleanUpView(tView, lView) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(lView)) {
    return;
  }
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~128;
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 256;
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerDestroy)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].type === 1) {
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER].destroy();
    }
    const declarationContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT])) {
      if (declarationContainer !== lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function runLeaveAnimationsWithCallback(lView, tNode, injector, callback) {
  const animations = lView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS];
  if (animations == null || animations.leave == undefined || !animations.leave.has(tNode.index)) return callback(false);
  if (lView) allLeavingAnimations.add(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
  addToAnimationQueue(injector, () => {
    if (animations.leave && animations.leave.has(tNode.index)) {
      const leaveAnimationMap = animations.leave;
      const leaveAnimations = leaveAnimationMap.get(tNode.index);
      const runningAnimations = [];
      if (leaveAnimations) {
        for (let index = 0; index < leaveAnimations.animateFns.length; index++) {
          const animationFn = leaveAnimations.animateFns[index];
          const {
            promise
          } = animationFn();
          runningAnimations.push(promise);
        }
        animations.detachedLeaveAnimationFns = undefined;
      }
      animations.running = Promise.allSettled(runningAnimations);
      runAfterLeaveAnimations(lView, callback);
    } else {
      if (lView) allLeavingAnimations.delete(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
      callback(false);
    }
  }, animations);
}
function runAfterLeaveAnimations(lView, callback) {
  const runningAnimations = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS]?.running;
  if (runningAnimations) {
    runningAnimations.then(() => {
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS].running = undefined;
      allLeavingAnimations.delete(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
      callback(true);
    });
    return;
  }
  callback(false);
}
function processCleanups(tView, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotReactive)(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === 'string') {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(targetIdx, 'cleanup target must be a number');
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context);
      }
    }
  }
  if (lCleanup !== null) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP] = null;
  }
  const destroyHooks = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFunction)(destroyHooksFn, 'Expecting destroy hook to be a function.');
      destroyHooksFn();
    }
  }
  const effects = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS];
  if (effects !== null) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS] = null;
    for (const effect of effects) {
      effect.destroy();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotReactive)(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context = lView[destroyHooks[i]];
      if (!(context instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context[toCall[j]];
            const hook = toCall[j + 1];
            profiler(ProfilerEvent.LifecycleHookStart, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(ProfilerEvent.LifecycleHookEnd, callContext, hook);
            }
          }
        } else {
          profiler(ProfilerEvent.LifecycleHookStart, context, toCall);
          try {
            toCall.call(context);
          } finally {
            profiler(ProfilerEvent.LifecycleHookEnd, context, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  } else {
    ngDevMode && assertTNodeType(parentTNode, 3 | 4);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(parentTNode)) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(parentTNode, lView);
      const {
        encapsulation
      } = tView.data[parentTNode.directiveStart + parentTNode.componentOffset];
      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {
        return null;
      }
    }
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(parentTNode, lView);
  }
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(parentTNode, lView);
  }
  return null;
}
let _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
let _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;
  _processI18nInsertBefore = processI18nInsertBefore;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const parentTNode = childTNode.parent || lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== undefined && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(tNode, 3 | 12 | 32 | 16 | 128);
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW]);
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertParentView)(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertProjectionSlots)(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE];
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
    const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if (!isDetachedByI18n(tNode)) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, injector, parentRElement, rNode, tNode, beforeNode, lView);
        }
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(tNode, 3 | 4);
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof tProjectionNode.projection, 'number', 'expecting projection index');
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], parentRElement, rNode, tProjectionNode, beforeNode, lView);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, injector, lContainer, tNode, parentRElement, beforeNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  const anchor = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE];
  const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, injector, parentRElement, anchor, tNode, beforeNode);
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      renderer.removeClass(rNode, prop);
    } else {
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;
    if (value == null) {
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function executeTemplate(tView, lView, templateFn, rf, context) {
  const prevSelectedIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)();
  const isUpdatePhase = rf & 2;
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(-1);
    if (isUpdatePhase && lView.length > _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET) {
      selectIndexInternal(tView, lView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, !!ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)());
    }
    const preHookType = isUpdatePhase ? ProfilerEvent.TemplateUpdateStart : ProfilerEvent.TemplateCreateStart;
    profiler(preHookType, context, templateFn);
    templateFn(rf, context);
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(prevSelectedIndex);
    const postHookType = isUpdatePhase ? ProfilerEvent.TemplateUpdateEnd : ProfilerEvent.TemplateCreateEnd;
    profiler(postHookType, context, templateFn);
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  instantiateAllDirectives(tView, lView, tNode);
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom || encapsulation === ViewEncapsulation.ExperimentalIsolatedShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
let _applyRootElementTransformImpl = () => null;
function applyRootElementTransformImpl(rootElement) {
  if (hasSkipHydrationAttrOnRElement(rootElement)) {
    clearElementContents(rootElement);
  } else {
    processTextNodeMarkersBeforeHydration(rootElement);
  }
}
function enableApplyRootElementTransformImpl() {
  _applyRootElementTransformImpl = applyRootElementTransformImpl;
}
function mapPropName(name) {
  if (name === 'class') return 'className';
  if (name === 'for') return 'htmlFor';
  if (name === 'formaction') return 'formAction';
  if (name === 'innerHtml') return 'innerHTML';
  if (name === 'readonly') return 'readOnly';
  if (name === 'tabindex') return 'tabIndex';
  return name;
}
function setPropertyAndInputs(tNode, lView, propName, value, renderer, sanitizer) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);
  if (hasSetInput) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && markDirtyIfOnPush(lView, tNode.index);
    ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);
    return;
  }
  if (tNode.type & 3) {
    propName = mapPropName(propName);
  }
  setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
}
function setDomProperty(tNode, lView, propName, value, renderer, sanitizer) {
  if (tNode.type & 3) {
    const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  const childComponentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(viewIndex, lView);
  if (!(childComponentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 16)) {
    childComponentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, tNode, attrName, value) {
  const environment = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  if (!environment.ngReflect) {
    return;
  }
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (tNode.type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({
      [attrName]: debugValue
    }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, tView, tNode, publicName, value) {
  const environment = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  if (!environment.ngReflect || !(tNode.type & (3 | 4))) {
    return;
  }
  const inputConfig = tNode.inputs?.[publicName];
  const hostInputConfig = tNode.hostDirectiveInputs?.[publicName];
  if (hostInputConfig) {
    for (let i = 0; i < hostInputConfig.length; i += 2) {
      const index = hostInputConfig[i];
      const publicName = hostInputConfig[i + 1];
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
  if (inputConfig) {
    for (const index of inputConfig) {
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
}
function instantiateAllDirectives(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
    ngDevMode && assertTNodeType(tNode, 3);
    createComponentLView(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
      const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
      componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveIndex)();
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentDirectiveIndex)(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(-1);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentDirectiveIndex)(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  ngDevMode && assertTNodeType(tNode, 3 | 12);
  const registry = tView.directiveRegistry;
  let matches = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
        matches ??= [];
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. ` + `Please use a different tag to activate the ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(def.type)} component.`);
            if (matches.length && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(matches[0])) {
              throwMultipleComponentError(tNode, matches.find(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef).type, def.type);
            }
          }
          matches.unshift(def);
        } else {
          matches.push(def);
        }
      }
    }
  }
  return matches;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. ` + `Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  setElementAttribute(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    renderer.removeAttribute(element, name, namespace);
  } else {
    const strValue = sanitizer == null ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(value) : sanitizer(value, tagName || '', name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; i += 2) {
      const lookupName = initialInputs[i];
      const value = initialInputs[i + 1];
      writeToDirectiveInput(def, instance, lookupName, value);
      if (ngDevMode) {
        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);
      }
    }
  }
}
function elementLikeStartShared(tNode, lView, index, name, locateOrCreateNativeNode) {
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const native = locateOrCreateNativeNode(tView, lView, tNode, name, index);
  lView[adjustedIndex] = native;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, true);
  const isElement = tNode.type === 2;
  if (isElement) {
    setupStaticAttributes(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], native, tNode);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getElementDepthCount)() === 0 || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
      attachPatchData(native, lView);
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.increaseElementDepthCount)();
  } else {
    attachPatchData(native, lView);
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)() && (!isElement || !isDetachedByI18n(tNode))) {
    appendChild(tView, lView, native, tNode);
  }
  return tNode;
}
function elementLikeEndShared(tNode) {
  let currentTNode = tNode;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCurrentTNodeParent)()) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNodeAsNotParent)();
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertHasParent)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)());
    currentTNode = currentTNode.parent;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(currentTNode, false);
  }
  return currentTNode;
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (!tNode.inputs?.[propertyName] && !tNode.hostDirectiveInputs?.[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(currentDef)) {
    lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapLView)(lView[tNode.index]);
  }
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
}
function handleUncaughtError(lView, error) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  if (!injector) {
    return;
  }
  let errorHandler;
  try {
    errorHandler = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER, null);
  } catch {
    errorHandler = null;
  }
  errorHandler?.(error);
}
function setAllInputsForProperty(tNode, tView, lView, publicName, value) {
  const inputs = tNode.inputs?.[publicName];
  const hostDirectiveInputs = tNode.hostDirectiveInputs?.[publicName];
  let hasMatch = false;
  if (hostDirectiveInputs) {
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
      const publicName = hostDirectiveInputs[i + 1];
      const def = tView.data[index];
      writeToDirectiveInput(def, lView[index], publicName, value);
      hasMatch = true;
    }
  }
  if (inputs) {
    for (const index of inputs) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
      const instance = lView[index];
      const def = tView.data[index];
      writeToDirectiveInput(def, instance, publicName, value);
      hasMatch = true;
    }
  }
  return hasMatch;
}
function setDirectiveInput(tNode, tView, lView, target, publicName, value) {
  let hostIndex = null;
  let hostDirectivesStart = null;
  let hostDirectivesEnd = null;
  let hasSet = false;
  if (ngDevMode && !tNode.directiveToIndex?.has(target.type)) {
    throw new Error(`Node does not have a directive with type ${target.type.name}`);
  }
  const data = tNode.directiveToIndex.get(target.type);
  if (typeof data === 'number') {
    hostIndex = data;
  } else {
    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;
  }
  if (hostDirectivesStart !== null && hostDirectivesEnd !== null && tNode.hostDirectiveInputs?.hasOwnProperty(publicName)) {
    const hostDirectiveInputs = tNode.hostDirectiveInputs[publicName];
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
        const def = tView.data[index];
        const hostDirectivePublicName = hostDirectiveInputs[i + 1];
        writeToDirectiveInput(def, lView[index], hostDirectivePublicName, value);
        hasSet = true;
      } else if (index > hostDirectivesEnd) {
        break;
      }
    }
  }
  if (hostIndex !== null && target.inputs.hasOwnProperty(publicName)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, hostIndex);
    writeToDirectiveInput(target, lView[hostIndex], publicName, value);
    hasSet = true;
  }
  return hasSet;
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(hostLView), true, 'Should be run in creation mode');
  const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(componentHostIdx, hostLView);
  const componentTView = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  if (hostRNode !== null && componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION] === null) {
    componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  }
  profiler(ProfilerEvent.ComponentStart);
  try {
    renderView(componentTView, componentView, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  } finally {
    profiler(ProfilerEvent.ComponentEnd, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  }
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(lView), true, 'Should be run in creation mode');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotReactive)(renderView.name);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterView)(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~4;
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveView)();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(embeddedTView, 'TView must be defined for a template node.');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(templateTNode, declarationLView);
    const isSignalView = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationLContainer);
    embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context);
    return embeddedLView;
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
const USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT = false;
const UseExhaustiveCheckNoChanges = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'exhaustive checkNoChanges' : '');
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lNode));
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW]);
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertParentView)(parentView);
        collectNativeNodes(parentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] !== lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]) {
    result.push(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE]);
  }
}
function addAfterRenderSequencesForView(lView) {
  if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD] !== null) {
    for (const sequence of lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD]) {
      sequence.impl.addSequence(sequence);
    }
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.AFTER_RENDER_SEQUENCES_TO_ADD].length = 0;
  }
}
let freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
const REACTIVE_LVIEW_CONSUMER_NODE = {
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  kind: 'template',
  consumerMarkedDirty: node => {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markAncestorsForTraversal)(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] = this;
  }
};
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
const TEMPORARY_CONSUMER_NODE = {
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  kind: 'template',
  consumerMarkedDirty: node => {
    let parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(node.lView);
    while (parent && !viewShouldHaveReactiveConsumer(parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW])) {
      parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(parent);
    }
    if (!parent) {
      return;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markViewForRefresh)(parent);
  },
  consumerOnSignalRead() {
    this.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] = this;
  }
};
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function isReactiveLViewConsumer(node) {
  return node.kind === 'template';
}
function runEffectsInView(view) {
  if (view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS] === null) {
    return;
  }
  let tryFlushEffects = true;
  while (tryFlushEffects) {
    let foundDirtyEffect = false;
    for (const effect of view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS]) {
      if (!effect.dirty) {
        continue;
      }
      foundDirtyEffect = true;
      if (effect.zone === null || Zone.current === effect.zone) {
        effect.run();
      } else {
        effect.zone.run(() => effect.run());
      }
    }
    tryFlushEffects = foundDirtyEffect && !!(view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 8192);
  }
}
const MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, mode = 0) {
  const environment = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT];
  const rendererFactory = environment.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRefreshingViews)();
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsRefreshingViews)(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isExhaustiveCheckNoChanges)()) {
      return;
    }
    let retries = 0;
    while ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(103, ngDevMode && 'Infinite change detection while trying to refresh views. ' + 'There may be components which each cause the other to require a refresh, ' + 'causing an infinite loop.');
      }
      retries++;
      detectChangesInView(lView, 1);
    }
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsRefreshingViews)(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, exhaustive) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsInCheckNoChangesMode)(exhaustive ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CheckNoChangesMode.Exhaustive : _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CheckNoChangesMode.OnlyDirtyViews);
  try {
    detectChangesInternal(lView);
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsInCheckNoChangesMode)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(lView), false, 'Should be run in update mode');
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(lView)) return;
  const flags = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS];
  const isInCheckNoChangesPass = ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isExhaustiveCheckNoChanges)();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterView)(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerBeforeComputation)(currentConsumer);
    } else if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getActiveConsumer)() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerBeforeComputation)(currentConsumer);
    } else if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER]) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerDestroy)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER]);
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resetPreOrderHookFlags)(lView);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setBindingIndex)(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(lView, 0);
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(lView, 0);
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(lView, contentHooks, 1);
        }
        incrementInitPhaseFlags(lView, 1);
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(lView, components, 0);
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(lView, viewHooks, 2);
        }
        incrementInitPhaseFlags(lView, 2);
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      addAfterRenderSequencesForView(lView);
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markAncestorsForTraversal)(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerAfterComputation)(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveView)();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 2)) continue;
    const movedViews = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markViewForRefresh)(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(hostLView), false, 'Should be run in update mode');
  profiler(ProfilerEvent.ComponentStart);
  const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(componentHostIdx, hostLView);
  try {
    detectChangesInViewIfAttached(componentView, mode);
  } finally {
    profiler(ProfilerEvent.ComponentEnd, componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  }
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.viewAttachedToChangeDetector)(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)();
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const flags = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS];
  const consumer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.consumerPollProducersForChange)(consumer));
  shouldRefreshView ||= !!(ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isExhaustiveCheckNoChanges)());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]);
  } else if (flags & 8192) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      if (!isInCheckNoChangesPass) {
        runEffectsInView(lView);
      }
      detectChangesInEmbeddedViews(lView, 1);
      const components = tView.components;
      if (components !== null) {
        detectChangesInChildComponents(lView, components, 1);
      }
      if (!isInCheckNoChangesPass) {
        addAfterRenderSequencesForView(lView);
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null) return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setBindingRootForHostBindings)(bindingRootIndx, directiveIdx);
        const context = lView[directiveIdx];
        profiler(ProfilerEvent.HostBindingsUpdateStart, context);
        try {
          hostBindingFn(2, context);
        } finally {
          profiler(ProfilerEvent.HostBindingsUpdateEnd, context);
        }
      }
    }
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setSelectedIndex)(-1);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRefreshingViews)() ? 64 : 1024 | 64;
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= dirtyBitsToUse;
    const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLViewParent)(lView);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(currentView);
  const lContainer = [hostNative, true, 0, currentView, null, tNode, null, native, null, null];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(lContainer.length, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');
  return lContainer;
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
    return lView;
  }
  return undefined;
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
    const parentRNode = renderer.parentNode(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== undefined) {
    destroyLView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
  }
  return lView;
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
    }
    const removedLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(lContainer, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], viewToDetach);
    const lQueries = removedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW]);
    }
    viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] = null;
    viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = null;
    viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~128;
  }
  return viewToDetach;
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = lView;
  }
  if (index < containerLength - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = lContainer[indexInContainer];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.addToArray)(lContainer, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = null;
  }
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] = lContainer;
  const declarationLContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.updateAncestorTraversalFlagsOnAttach)(lView);
  lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView, 'LView required');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationContainer);
  const movedViews = declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
  const parent = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(parent, 'missing parent');
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(parent)) {
    declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 2;
  } else {
    const insertedComponentLView = parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(insertedComponentLView, 'Missing insertedComponentLView');
    const declaredComponentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(declaredComponentLView, 'Missing declaredComponentLView');
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 2;
    }
  }
  if (movedViews === null) {
    declarationContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
class ViewRef {
  _lView;
  _cdRefInjectingView;
  _appRef = null;
  _attachedToViewContainer = false;
  exhaustive;
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  constructor(_lView, _cdRefInjectingView) {
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
  }
  get context() {
    return this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  }
  set context(value) {
    if (ngDevMode) {
      console.warn('Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.');
    }
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = value;
  }
  get destroyed() {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(this._lView);
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent = this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(parent)) {
        const viewRefs = parent[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS];
        const index = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index > -1) {
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(index, parent.indexOf(this._lView) - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');
          detachView(parent, index);
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(viewRefs, index);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], this._lView);
  }
  onDestroy(callback) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeLViewOnDestroy)(this._lView, callback);
  }
  markForCheck() {
    markViewDirty(this._cdRefInjectingView || this._lView, 4);
  }
  detach() {
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] &= ~128;
  }
  reattach() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.updateAncestorTraversalFlagsOnAttach)(this._lView);
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 128;
  }
  detectChanges() {
    this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 1024;
    detectChangesInternal(this._lView);
  }
  checkNoChanges() {
    if (ngDevMode) {
      try {
        this.exhaustive ??= this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(UseExhaustiveCheckNoChanges, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT);
      } catch {
        this.exhaustive = USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT;
      }
      checkNoChangesInternal(this._lView, this.exhaustive);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(902, ngDevMode && 'This view is already attached directly to the ApplicationRef!');
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(this._lView);
    const declarationContainer = this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(902, ngDevMode && 'This view is already attached to a ViewContainer!');
    }
    this._appRef = appRef;
    const isRoot = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(this._lView);
    const declarationContainer = this._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.updateAncestorTraversalFlagsOnAttach)(this._lView);
  }
}
function isViewDirty(view) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(view._lView) || !!(view._lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 64);
}
function markForRefresh(view) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.markViewForRefresh)(view._lView);
}
let TemplateRef = /*#__PURE__*/(() => {
  class TemplateRef {
    _declarationLView;
    _declarationTContainer;
    elementRef;
    static __NG_ELEMENT_ID__ = injectTemplateRef;
    constructor(_declarationLView, _declarationTContainer, elementRef) {
      this._declarationLView = _declarationLView;
      this._declarationTContainer = _declarationTContainer;
      this.elementRef = elementRef;
    }
    get ssrId() {
      return this._declarationTContainer.tView?.ssrId || null;
    }
    createEmbeddedView(context, injector) {
      return this.createEmbeddedViewImpl(context, injector);
    }
    createEmbeddedViewImpl(context, injector, dehydratedView) {
      const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, {
        embeddedViewInjector: injector,
        dehydratedView
      });
      return new ViewRef(embeddedLView);
    }
  }
  return TemplateRef;
})();
function injectTemplateRef() {
  return createTemplateRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(hostTNode.tView, 'TView must be allocated');
    return new TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
const AT_THIS_LOCATION = '<-- AT THIS LOCATION';
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return 'view container';
    case 2:
      return 'element';
    case 8:
      return 'ng-container';
    case 32:
      return 'icu';
    case 64:
      return 'i18n';
    case 16:
      return 'projection';
    case 1:
      return 'text';
    case 128:
      return '@let';
    default:
      return '<unknown>';
  }
}
function validateMatchingNode(node, nodeType, tagName, lView, tNode, isViewContainerAnchor = false) {
  if (!node || node.nodeType !== nodeType || node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() !== tagName?.toLowerCase()) {
    const expectedNode = shortRNodeDescription(nodeType, tagName, null);
    let header = `During hydration Angular expected ${expectedNode} but `;
    const hostComponentDef = getDeclarationComponentDef(lView);
    const componentClassName = hostComponentDef?.type?.name;
    const expectedDom = describeExpectedDom(lView, tNode, isViewContainerAnchor);
    const expected = `Angular expected this DOM:\n\n${expectedDom}\n\n`;
    let actual = '';
    const componentHostElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
    if (!node) {
      header += `the node was not found.\n\n`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom);
    } else {
      const actualNode = shortRNodeDescription(node.nodeType, node.tagName ?? null, node.textContent ?? null);
      header += `found ${actualNode}.\n\n`;
      const actualDom = describeDomFromNode(node);
      actual = `Actual DOM is:\n\n${actualDom}\n\n`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom, actualDom);
    }
    const footer = getHydrationErrorFooter(componentClassName);
    const message = header + expected + actual + getHydrationAttributeNote() + footer;
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-500, message);
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = 'During hydration Angular expected more sibling nodes to be present.\n\n';
    const actual = `Actual DOM is:\n\n${describeDomFromNode(node)}\n\n`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, '', actual);
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = 'During hydration, Angular expected an element to be present at this location.\n\n';
    let expected = '';
    let footer = '';
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]), expected, '');
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-502, `${header}${expected}\n\n${footer}`);
  }
}
function nodeNotFoundError(lView, tNode) {
  const header = 'During serialization, Angular was unable to find an element in the DOM:\n\n';
  const expected = `${describeExpectedDom(lView, tNode, false)}\n\n`;
  const footer = getHydrationErrorFooter();
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-502, header + expected + footer);
}
function nodeNotFoundAtPathError(host, path) {
  const header = `During hydration Angular was unable to locate a node ` + `using the "${path}" path, starting from the ${describeRNode(host)} node.\n\n`;
  const footer = getHydrationErrorFooter();
  markRNodeAsHavingHydrationMismatch(host);
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-502, header + footer);
}
function unsupportedProjectionOfDomNodes(rNode) {
  const header = 'During serialization, Angular detected DOM nodes ' + 'that were created outside of Angular context and provided as projectable nodes ' + '(likely via `ViewContainerRef.createComponent` or `createComponent` APIs). ' + 'Hydration is not supported for such cases, consider refactoring the code to avoid ' + 'this pattern or using `ngSkipHydration` on the host element of the component.\n\n';
  const actual = `${describeDomFromNode(rNode)}\n\n`;
  const message = header + actual + getHydrationAttributeNote();
  return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-503, message);
}
function invalidSkipHydrationHost(rNode) {
  const header = 'The `ngSkipHydration` flag is applied on a node ' + "that doesn't act as a component host. Hydration can be " + 'skipped only on per-component basis.\n\n';
  const actual = `${describeDomFromNode(rNode)}\n\n`;
  const footer = 'Please move the `ngSkipHydration` attribute to the component host element.\n\n';
  const message = header + actual + footer;
  return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-504, message);
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i = 0; i < tNode.attrs.length;) {
      const attrName = tNode.attrs[i++];
      if (typeof attrName == 'number') {
        break;
      }
      const attrValue = tNode.attrs[i++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(' ');
}
const internalAttrs = /*#__PURE__*/new Set(['ngh', 'ng-version', 'ng-server-context']);
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i = 0; i < rNode.attributes.length; i++) {
    const attr = rNode.attributes[i];
    if (internalAttrs.has(attr.name)) continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(' ');
}
function describeTNode(tNode, innerContent = '…') {
  switch (tNode.type) {
    case 1:
      const content = tNode.value ? `(${tNode.value})` : '';
      return `#text${content}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;
    case 8:
      return '<!-- ng-container -->';
    case 4:
      return '<!-- container -->';
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = '…') {
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? ' ' + attrs : ''}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content = node.textContent ? shorten(node.textContent) : '';
      return `#text${content ? `(${content})` : ''}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten(node.textContent ?? '')} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = '  ';
  let content = '';
  if (tNode.prev) {
    content += spacer + '…\n';
    content += spacer + describeTNode(tNode.prev) + '\n';
  } else if (tNode.type && tNode.type & 12) {
    content += spacer + '…\n';
  }
  if (isViewContainerAnchor) {
    content += spacer + describeTNode(tNode) + '\n';
    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}\n`;
  } else {
    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}\n`;
  }
  content += spacer + '…\n';
  const parentRNode = tNode.type ? getParentRElement(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content = describeRNode(parentRNode, '\n' + content);
  }
  return content;
}
function describeDomFromNode(node) {
  const spacer = '  ';
  let content = '';
  const currentNode = node;
  if (currentNode.previousSibling) {
    content += spacer + '…\n';
    content += spacer + describeRNode(currentNode.previousSibling) + '\n';
  }
  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}\n`;
  if (node.nextSibling) {
    content += spacer + '…\n';
  }
  if (node.parentNode) {
    content = describeRNode(currentNode.parentNode, '\n' + content);
  }
  return content;
}
function shortRNodeDescription(nodeType, tagName, textContent) {
  switch (nodeType) {
    case Node.ELEMENT_NODE:
      return `<${tagName.toLowerCase()}>`;
    case Node.TEXT_NODE:
      const content = textContent ? ` (with the "${shorten(textContent)}" content)` : '';
      return `a text node${content}`;
    case Node.COMMENT_NODE:
      return 'a comment node';
    default:
      return `#node(nodeType=${nodeType})`;
  }
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : 'corresponding';
  return `To fix this problem:\n` + `  * check ${componentInfo} component for hydration-related issues\n` + `  * check to see if your template has valid HTML structure\n` + `  * or skip hydration by adding the \`ngSkipHydration\` attribute ` + `to its host node in a template\n\n`;
}
function getHydrationAttributeNote() {
  return 'Note: attributes are only displayed to better represent the DOM' + ' but have no effect on hydration mismatches.\n\n';
}
function stripNewlines(input) {
  return input.replace(/\s+/gm, '');
}
function shorten(input, maxLength = 50) {
  if (!input) {
    return '';
  }
  input = stripNewlines(input);
  return input.length > maxLength ? `${input.substring(0, maxLength - 1)}…` : input;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, insertBeforeIndex);
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  ngDevMode && index !== 0 && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(index, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInI18nBlock)()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForTView)(tNode, tView);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(index, tNode.index, 'Expecting same index');
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNodePlaceholderOk)();
  const isParent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCurrentTNodeParent)();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  linkTNodeInTView(tView, tNode, currentTNode, isParent);
  return tNode;
}
function linkTNodeInTView(tView, tNode, currentTNode, isParent) {
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(index, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(attrs, undefined, "'undefined' is not valid value for 'attrs'");
  ngDevMode && tParent && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForTView)(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    fieldIndex: -1,
    customControlIndex: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value: value,
    attrs: attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: null,
    inputs: null,
    hostDirectiveInputs: null,
    outputs: null,
    hostDirectiveOutputs: null,
    directiveToIndex: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: undefined,
    classes: null,
    classesWithoutHost: null,
    residualClasses: undefined,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === 'string') return null;
  if (ngDevMode && !(value.hasOwnProperty('tView') || value.hasOwnProperty('currentCaseLViewIndex'))) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value : value.value;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tNode === null || tNode.hasOwnProperty('tView'), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(tNode, 32);
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(Array.isArray(insertBeforeIndex), true, 'Expecting array here');
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(parentIdx, 0, 'Missing parent index');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(refIdx, 0, 'Missing ref index');
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(removeOpCode, 'Expecting OpCode number');
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[tIcuIndex];
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      state.lView = undefined;
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length) _state.stack.pop();
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
function createIcuIterator(tIcu, lView) {
  const state = {
    stack: [],
    index: -1,
    lView
  };
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
  enterIcu(state, tIcu, lView);
  return icuContainerIteratorNext.bind(null, state);
}
const REF_EXTRACTOR_REGEXP = /* @__PURE__ */(() => {
  return new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
})();
function compressNodeLocation(referenceNode, path) {
  const result = [referenceNode];
  for (const segment of path) {
    const lastIdx = result.length - 1;
    if (lastIdx > 0 && result[lastIdx - 1] === segment) {
      const value = result[lastIdx] || 1;
      result[lastIdx] = value + 1;
    } else {
      result.push(segment, '');
    }
  }
  return result.join('');
}
function decompressNodeLocation(path) {
  const matches = path.match(REF_EXTRACTOR_REGEXP);
  const [_, refNodeId, refNodeName, rest] = matches;
  const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;
  const steps = [];
  for (const [_, step, count] of rest.matchAll(/(f|n)(\d*)/g)) {
    const repeat = parseInt(count, 10) || 1;
    steps.push(step, repeat);
  }
  return [ref, ...steps];
}
function isFirstElementInNgContainer(tNode) {
  return !tNode.prev && tNode.parent?.type === 8;
}
function getNoOffsetIndex(tNode) {
  return tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
}
function isDisconnectedNode(tNode, lView) {
  return !(tNode.type & (16 | 128)) && !!lView[tNode.index] && isDisconnectedRNode((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[tNode.index]));
}
function isDisconnectedRNode(rNode) {
  return !!rNode && !rNode.isConnected;
}
function locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex) {
  const i18nNodes = hydrationInfo.i18nNodes;
  if (i18nNodes) {
    return i18nNodes.get(noOffsetIndex);
  }
  return undefined;
}
function tryLocateRNodeByPath(hydrationInfo, lView, noOffsetIndex) {
  const nodes = hydrationInfo.data[NODES];
  const path = nodes?.[noOffsetIndex];
  return path ? locateRNodeByPath(path, lView) : null;
}
function locateNextRNode(hydrationInfo, tView, lView, tNode) {
  const noOffsetIndex = getNoOffsetIndex(tNode);
  let native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  if (native === undefined) {
    const nodes = hydrationInfo.data[NODES];
    if (nodes?.[noOffsetIndex]) {
      native = locateRNodeByPath(nodes[noOffsetIndex], lView);
    } else if (tView.firstChild === tNode) {
      native = hydrationInfo.firstChild;
    } else {
      const previousTNodeParent = tNode.prev === null;
      const previousTNode = tNode.prev ?? tNode.parent;
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(previousTNode, 'Unexpected state: current TNode does not have a connection ' + 'to the previous node or a parent node.');
      if (isFirstElementInNgContainer(tNode)) {
        const noOffsetParentIndex = getNoOffsetIndex(tNode.parent);
        native = getSegmentHead(hydrationInfo, noOffsetParentIndex);
      } else {
        let previousRElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(previousTNode, lView);
        if (previousTNodeParent) {
          native = previousRElement.firstChild;
        } else {
          const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);
          const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);
          if (previousTNode.type === 2 && segmentHead) {
            const numRootNodesToSkip = calcSerializedContainerSize(hydrationInfo, noOffsetPrevSiblingIndex);
            const nodesToSkip = numRootNodesToSkip + 1;
            native = siblingAfter(nodesToSkip, segmentHead);
          } else {
            native = previousRElement.nextSibling;
          }
        }
      }
    }
  }
  return native;
}
function siblingAfter(skip, from) {
  let currentNode = from;
  for (let i = 0; i < skip; i++) {
    ngDevMode && validateSiblingNodeExists(currentNode);
    currentNode = currentNode.nextSibling;
  }
  return currentNode;
}
function stringifyNavigationInstructions(instructions) {
  const container = [];
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      container.push(step === NODE_NAVIGATION_STEP_FIRST_CHILD ? 'firstChild' : 'nextSibling');
    }
  }
  return container.join('.');
}
function navigateToNode(from, instructions) {
  let node = from;
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      if (ngDevMode && !node) {
        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
      }
      switch (step) {
        case NODE_NAVIGATION_STEP_FIRST_CHILD:
          node = node.firstChild;
          break;
        case NODE_NAVIGATION_STEP_NEXT_SIBLING:
          node = node.nextSibling;
          break;
      }
    }
  }
  if (ngDevMode && !node) {
    throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
  }
  return node;
}
function locateRNodeByPath(path, lView) {
  const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);
  let ref;
  if (referenceNode === REFERENCE_NODE_HOST) {
    ref = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  } else if (referenceNode === REFERENCE_NODE_BODY) {
    ref = ɵɵresolveBody(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
  } else {
    const parentElementId = Number(referenceNode);
    ref = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[parentElementId + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET]);
  }
  return navigateToNode(ref, navigationInstructions);
}
function navigateBetween(start, finish) {
  if (start === finish) {
    return [];
  } else if (start.parentElement == null || finish.parentElement == null) {
    return null;
  } else if (start.parentElement === finish.parentElement) {
    return navigateBetweenSiblings(start, finish);
  } else {
    const parent = finish.parentElement;
    const parentPath = navigateBetween(start, parent);
    const childPath = navigateBetween(parent.firstChild, finish);
    if (!parentPath || !childPath) return null;
    return [...parentPath, NODE_NAVIGATION_STEP_FIRST_CHILD, ...childPath];
  }
}
function navigateBetweenSiblings(start, finish) {
  const nav = [];
  let node = null;
  for (node = start; node != null && node !== finish; node = node.nextSibling) {
    nav.push(NODE_NAVIGATION_STEP_NEXT_SIBLING);
  }
  return node == null ? null : nav;
}
function calcPathBetween(from, to, fromNodeName) {
  const path = navigateBetween(from, to);
  return path === null ? null : compressNodeLocation(fromNodeName, path);
}
function calcPathForNode(tNode, lView, excludedParentNodes) {
  let parentTNode = tNode.parent;
  let parentIndex;
  let parentRNode;
  let referenceNodeName;
  while (parentTNode !== null && (isDisconnectedNode(parentTNode, lView) || excludedParentNodes?.has(parentTNode.index))) {
    parentTNode = parentTNode.parent;
  }
  if (parentTNode === null || !(parentTNode.type & 3)) {
    parentIndex = referenceNodeName = REFERENCE_NODE_HOST;
    parentRNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  } else {
    parentIndex = parentTNode.index;
    parentRNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[parentIndex]);
    referenceNodeName = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(parentIndex - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
  }
  let rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[tNode.index]);
  if (tNode.type & (12 | 32)) {
    const firstRNode = getFirstNativeNode(lView, tNode);
    if (firstRNode) {
      rNode = firstRNode;
    }
  }
  let path = calcPathBetween(parentRNode, rNode, referenceNodeName);
  if (path === null && parentRNode !== rNode) {
    const body = parentRNode.ownerDocument.body;
    path = calcPathBetween(body, rNode, REFERENCE_NODE_BODY);
    if (path === null) {
      throw nodeNotFoundError(lView, tNode);
    }
  }
  return path;
}
function gatherDeferBlocksCommentNodes(doc, node) {
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode;
  const nodesByBlockId = new Map();
  while (currentNode = commentNodesIterator.nextNode()) {
    const nghPattern = 'ngh=';
    const content = currentNode?.textContent;
    const nghIdx = content?.indexOf(nghPattern) ?? -1;
    if (nghIdx > -1) {
      const nghValue = content.substring(nghIdx + nghPattern.length).trim();
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(nghValue.startsWith('d'), true, 'Invalid defer block id found in a comment node.');
      nodesByBlockId.set(nghValue, currentNode);
    }
  }
  return nodesByBlockId;
}
function acceptNode(node) {
  return node.textContent?.trimStart().startsWith('ngh=') ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
}
let _isI18nHydrationSupportEnabled = false;
let _prepareI18nBlockForHydrationImpl = () => {};
function setIsI18nHydrationSupportEnabled(enabled) {
  _isI18nHydrationSupportEnabled = enabled;
}
function isI18nHydrationSupportEnabled() {
  return _isI18nHydrationSupportEnabled;
}
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
function enablePrepareI18nBlockForHydrationImpl() {
  _prepareI18nBlockForHydrationImpl = prepareI18nBlockForHydrationImpl;
}
function isI18nHydrationEnabled(injector) {
  injector = injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
  return injector.get(IS_I18N_HYDRATION_ENABLED, false);
}
function getOrComputeI18nChildren(tView, context) {
  let i18nChildren = context.i18nChildren.get(tView);
  if (i18nChildren === undefined) {
    i18nChildren = collectI18nChildren(tView);
    context.i18nChildren.set(tView, i18nChildren);
  }
  return i18nChildren;
}
function collectI18nChildren(tView) {
  const children = new Set();
  function collectI18nViews(node) {
    children.add(node.index);
    switch (node.kind) {
      case 1:
      case 2:
        {
          for (const childNode of node.children) {
            collectI18nViews(childNode);
          }
          break;
        }
      case 3:
        {
          for (const caseNodes of node.cases) {
            for (const caseNode of caseNodes) {
              collectI18nViews(caseNode);
            }
          }
          break;
        }
    }
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tI18n = tView.data[i];
    if (!tI18n || !tI18n.ast) {
      continue;
    }
    for (const node of tI18n.ast) {
      collectI18nViews(node);
    }
  }
  return children.size === 0 ? null : children;
}
function trySerializeI18nBlock(lView, index, context) {
  if (!context.isI18nHydrationEnabled) {
    return null;
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tI18n = tView.data[index];
  if (!tI18n || !tI18n.ast) {
    return null;
  }
  const parentTNode = tView.data[tI18n.parentTNodeIndex];
  if (parentTNode && isI18nInSkipHydrationBlock(parentTNode)) {
    return null;
  }
  const serializedI18nBlock = {
    caseQueue: [],
    disconnectedNodes: new Set(),
    disjointNodes: new Set()
  };
  serializeI18nBlock(lView, serializedI18nBlock, context, tI18n.ast);
  return serializedI18nBlock.caseQueue.length === 0 && serializedI18nBlock.disconnectedNodes.size === 0 && serializedI18nBlock.disjointNodes.size === 0 ? null : serializedI18nBlock;
}
function serializeI18nBlock(lView, serializedI18nBlock, context, nodes) {
  let prevRNode = null;
  for (const node of nodes) {
    const nextRNode = serializeI18nNode(lView, serializedI18nBlock, context, node);
    if (nextRNode) {
      if (isDisjointNode(prevRNode, nextRNode)) {
        serializedI18nBlock.disjointNodes.add(node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
      }
      prevRNode = nextRNode;
    }
  }
  return prevRNode;
}
function isDisjointNode(prevNode, nextNode) {
  return prevNode && prevNode.nextSibling !== nextNode;
}
function serializeI18nNode(lView, serializedI18nBlock, context, node) {
  const maybeRNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[node.index]);
  if (!maybeRNode || isDisconnectedRNode(maybeRNode)) {
    serializedI18nBlock.disconnectedNodes.add(node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    return null;
  }
  const rNode = maybeRNode;
  switch (node.kind) {
    case 0:
      {
        processTextNodeBeforeSerialization(context, rNode);
        break;
      }
    case 1:
    case 2:
      {
        serializeI18nBlock(lView, serializedI18nBlock, context, node.children);
        break;
      }
    case 3:
      {
        const currentCase = lView[node.currentCaseLViewIndex];
        if (currentCase != null) {
          const caseIdx = currentCase < 0 ? ~currentCase : currentCase;
          serializedI18nBlock.caseQueue.push(caseIdx);
          serializeI18nBlock(lView, serializedI18nBlock, context, node.cases[caseIdx]);
        }
        break;
      }
  }
  return getFirstNativeNodeForI18nNode(lView, node);
}
function getFirstNativeNodeForI18nNode(lView, node) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const maybeTNode = tView.data[node.index];
  if (isTNodeShape(maybeTNode)) {
    return getFirstNativeNode(lView, maybeTNode);
  } else if (node.kind === 3) {
    const icuIterator = createIcuIterator(maybeTNode, lView);
    let rNode = icuIterator();
    return rNode ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[node.index]);
  } else {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[node.index]) ?? null;
  }
}
function setCurrentNode(state, node) {
  state.currentNode = node;
}
function appendI18nNodeToCollection(context, state, astNode) {
  const noOffsetIndex = astNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const {
    disconnectedNodes
  } = context;
  const currentNode = state.currentNode;
  if (state.isConnected) {
    context.i18nNodes.set(noOffsetIndex, currentNode);
    disconnectedNodes.delete(noOffsetIndex);
  } else {
    disconnectedNodes.add(noOffsetIndex);
  }
  return currentNode;
}
function skipSiblingNodes(state, skip) {
  let currentNode = state.currentNode;
  for (let i = 0; i < skip; i++) {
    if (!currentNode) {
      break;
    }
    currentNode = currentNode?.nextSibling ?? null;
  }
  return currentNode;
}
function forkHydrationState(state, nextNode) {
  return {
    currentNode: nextNode,
    isConnected: state.isConnected
  };
}
function prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  if (!hydrationInfo) {
    return;
  }
  if (!isI18nHydrationSupportEnabled() || parentTNode && (isI18nInSkipHydrationBlock(parentTNode) || isDisconnectedNode$1(hydrationInfo, parentTNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET))) {
    return;
  }
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tI18n = tView.data[index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tI18n, 'Expected i18n data to be present in a given TView slot during hydration');
  function findHydrationRoot() {
    if (isRootTemplateMessage(subTemplateIndex)) {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(parentTNode, 'Expected parent TNode while hydrating i18n root');
      const rootNode = locateNextRNode(hydrationInfo, tView, lView, parentTNode);
      return parentTNode.type & 8 ? rootNode : rootNode.firstChild;
    }
    return hydrationInfo?.firstChild;
  }
  const currentNode = findHydrationRoot();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(currentNode, 'Expected root i18n node during hydration');
  const disconnectedNodes = initDisconnectedNodes(hydrationInfo) ?? new Set();
  const i18nNodes = hydrationInfo.i18nNodes ??= new Map();
  const caseQueue = hydrationInfo.data[I18N_DATA]?.[index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET] ?? [];
  const dehydratedIcuData = hydrationInfo.dehydratedIcuData ??= new Map();
  collectI18nNodesFromDom({
    hydrationInfo,
    lView,
    i18nNodes,
    disconnectedNodes,
    caseQueue,
    dehydratedIcuData
  }, {
    currentNode,
    isConnected: true
  }, tI18n.ast);
  hydrationInfo.disconnectedNodes = disconnectedNodes.size === 0 ? null : disconnectedNodes;
}
function collectI18nNodesFromDom(context, state, nodeOrNodes) {
  if (Array.isArray(nodeOrNodes)) {
    let nextState = state;
    for (const node of nodeOrNodes) {
      const targetNode = tryLocateRNodeByPath(context.hydrationInfo, context.lView, node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
      if (targetNode) {
        nextState = forkHydrationState(state, targetNode);
      }
      collectI18nNodesFromDom(context, nextState, node);
    }
  } else {
    if (context.disconnectedNodes.has(nodeOrNodes.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET)) {
      return;
    }
    switch (nodeOrNodes.kind) {
      case 0:
        {
          const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
          setCurrentNode(state, currentNode?.nextSibling ?? null);
          break;
        }
      case 1:
        {
          collectI18nNodesFromDom(context, forkHydrationState(state, state.currentNode?.firstChild ?? null), nodeOrNodes.children);
          const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
          setCurrentNode(state, currentNode?.nextSibling ?? null);
          break;
        }
      case 2:
        {
          const noOffsetIndex = nodeOrNodes.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
          const {
            hydrationInfo
          } = context;
          const containerSize = getNgContainerSize(hydrationInfo, noOffsetIndex);
          switch (nodeOrNodes.type) {
            case 0:
              {
                const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
                if (isSerializedElementContainer(hydrationInfo, noOffsetIndex)) {
                  collectI18nNodesFromDom(context, state, nodeOrNodes.children);
                  const nextNode = skipSiblingNodes(state, 1);
                  setCurrentNode(state, nextNode);
                } else {
                  collectI18nNodesFromDom(context, forkHydrationState(state, state.currentNode?.firstChild ?? null), nodeOrNodes.children);
                  setCurrentNode(state, currentNode?.nextSibling ?? null);
                  if (containerSize !== null) {
                    const nextNode = skipSiblingNodes(state, containerSize + 1);
                    setCurrentNode(state, nextNode);
                  }
                }
                break;
              }
            case 1:
              {
                ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(containerSize, null, 'Expected a container size while hydrating i18n subtemplate');
                appendI18nNodeToCollection(context, state, nodeOrNodes);
                const nextNode = skipSiblingNodes(state, containerSize + 1);
                setCurrentNode(state, nextNode);
                break;
              }
          }
          break;
        }
      case 3:
        {
          const selectedCase = state.isConnected ? context.caseQueue.shift() : null;
          const childState = {
            currentNode: null,
            isConnected: false
          };
          for (let i = 0; i < nodeOrNodes.cases.length; i++) {
            collectI18nNodesFromDom(context, i === selectedCase ? state : childState, nodeOrNodes.cases[i]);
          }
          if (selectedCase !== null) {
            context.dehydratedIcuData.set(nodeOrNodes.index, {
              case: selectedCase,
              node: nodeOrNodes
            });
          }
          const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
          setCurrentNode(state, currentNode?.nextSibling ?? null);
          break;
        }
    }
  }
}
let _claimDehydratedIcuCaseImpl = () => {};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function enableClaimDehydratedIcuCaseImpl() {
  _claimDehydratedIcuCaseImpl = claimDehydratedIcuCaseImpl;
}
function claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex) {
  const dehydratedIcuDataMap = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION]?.dehydratedIcuData;
  if (dehydratedIcuDataMap) {
    const dehydratedIcuData = dehydratedIcuDataMap.get(icuIndex);
    if (dehydratedIcuData?.case === caseIndex) {
      dehydratedIcuDataMap.delete(icuIndex);
    }
  }
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  if (hydrationInfo) {
    const {
      i18nNodes,
      dehydratedIcuData: dehydratedIcuDataMap
    } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = undefined;
    hydrationInfo.dehydratedIcuData = undefined;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  const views = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS] ?? [];
  const parentLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  const renderer = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const retainedViews = [];
  for (const view of views) {
    if (view.data[DEFER_BLOCK_ID] !== undefined) {
      retainedViews.push(view);
    } else {
      removeDehydratedView(view, renderer);
      ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
  }
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS] = retainedViews;
}
function removeDehydratedViewList(deferBlock) {
  const {
    lContainer
  } = deferBlock;
  const dehydratedViews = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS];
  if (dehydratedViews === null) return;
  const parentLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  const renderer = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  for (const view of dehydratedViews) {
    removeDehydratedView(view, renderer);
    ngDevMode && ngDevMode.dehydratedViewsRemoved++;
  }
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    cleanupLView(lContainer[i]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lView[i])) {
      const lContainer = lView[i];
      cleanupLContainer(lContainer);
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lView[i])) {
      cleanupLView(lView[i]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST] !== null) {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {
  if (deferBlock !== null) {
    registry.cleanup(hydratedBlocks);
    cleanupLContainer(deferBlock.lContainer);
    cleanupDehydratedViews(appRef);
  }
}
function locateDehydratedViewsInContainer(currentRNode, serializedViews) {
  const dehydratedViews = [];
  for (const serializedView of serializedViews) {
    for (let i = 0; i < (serializedView[MULTIPLIER] ?? 1); i++) {
      const view = {
        data: serializedView,
        firstChild: null
      };
      if (serializedView[NUM_ROOT_NODES] > 0) {
        view.firstChild = currentRNode;
        currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode);
      }
      dehydratedViews.push(view);
    }
  }
  return [currentRNode, dehydratedViews];
}
let _findMatchingDehydratedViewImpl = () => null;
let _findAndReconcileMatchingDehydratedViewsImpl = () => null;
function enableFindMatchingDehydratedViewImpl() {
  _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;
  _findAndReconcileMatchingDehydratedViewsImpl = findAndReconcileMatchingDehydratedViewsImpl;
}
function findMatchingDehydratedViewImpl(lContainer, template) {
  if (hasMatchingDehydratedView(lContainer, template)) {
    return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS].shift();
  } else {
    removeDehydratedViews(lContainer);
    return null;
  }
}
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
function findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView) {
  if (templateTNode.tView.ssrId === null) return null;
  const dehydratedView = findMatchingDehydratedView(lContainer, templateTNode.tView.ssrId);
  if (hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstUpdatePass && dehydratedView === null) {
    removeStaleDehydratedBranch(hostLView, templateTNode);
  }
  return dehydratedView;
}
function findAndReconcileMatchingDehydratedViews(lContainer, templateTNode, hostLView) {
  return _findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView);
}
function removeStaleDehydratedBranch(hostLView, tNode) {
  let currentTNode = tNode;
  while (currentTNode) {
    if (cleanupMatchingDehydratedViews(hostLView, currentTNode)) return;
    if ((currentTNode.flags & 256) === 256) {
      break;
    }
    currentTNode = currentTNode.prev;
  }
  currentTNode = tNode.next;
  while (currentTNode) {
    if ((currentTNode.flags & 512) !== 512) {
      break;
    }
    if (cleanupMatchingDehydratedViews(hostLView, currentTNode)) return;
    currentTNode = currentTNode.next;
  }
}
function hasMatchingDehydratedView(lContainer, template) {
  const views = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS];
  if (!template || views === null || views.length === 0) {
    return false;
  }
  return views[0].data[TEMPLATE_ID] === template;
}
function cleanupMatchingDehydratedViews(hostLView, currentTNode) {
  const ssrId = currentTNode.tView?.ssrId;
  if (ssrId == null) return false;
  const container = hostLView[currentTNode.index];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(container) && hasMatchingDehydratedView(container, ssrId)) {
    removeDehydratedViews(container);
    return true;
  }
  return false;
}
let ComponentRef$1 = class ComponentRef {};
let ComponentFactory$1 = class ComponentFactory {};
class _NullComponentFactoryResolver {
  resolveComponentFactory(component) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(917, typeof ngDevMode !== 'undefined' && ngDevMode && `No component factory found for ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(component)}.`);
  }
}
let ComponentFactoryResolver$1 = class ComponentFactoryResolver {
  static NULL = /*#__PURE__*/new _NullComponentFactoryResolver();
};
class RendererFactory2 {}
let Renderer2 = /*#__PURE__*/(() => {
  class Renderer2 {
    destroyNode = null;
    static __NG_ELEMENT_ID__ = () => injectRenderer2();
  }
  return Renderer2;
})();
function injectRenderer2() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const nodeAtIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
  return ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(nodeAtIndex) ? nodeAtIndex : lView)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
}
let Sanitizer = /*#__PURE__*/(() => {
  class Sanitizer {
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: Sanitizer,
      providedIn: 'root',
      factory: () => null
    });
  }
  return Sanitizer;
})();
function isModuleWithProviders(value) {
  return value.ngModule !== undefined;
}
function isNgModule(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(value);
}
function isPipe(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(value);
}
function isDirective(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(value);
}
function isComponent(value) {
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(value);
}
function getDependencyTypeForError(type) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type)) return 'component';
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type)) return 'directive';
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type)) return 'pipe';
  return 'type';
}
function verifyStandaloneImport(depType, importingType) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isForwardRef)(depType)) {
    depType = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}", to return a standalone entity or NgModule but got "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(depType) || depType}".`);
    }
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(depType) == null) {
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(depType) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(depType) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(depType);
    if (def != null) {
      if (!def.standalone) {
        const type = getDependencyTypeForError(depType);
        throw new Error(`The "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(depType)}" ${type}, imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}", is not standalone. Does the ${type} have the standalone: false flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(depType)}" type, imported from "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
class DepsTracker {
  ownerNgModule = /*#__PURE__*/new Map();
  ngModulesWithSomeUnresolvedDecls = /*#__PURE__*/new Set();
  ngModulesScopeCache = /*#__PURE__*/new Map();
  standaloneComponentsScopeCache = /*#__PURE__*/new Map();
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(moduleType);
      if (def?.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  getComponentDependencies(type, rawImports) {
    this.resolveNgModulesDecls();
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type, rawImports);
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes, ...scope.compilation.ngModules]
      };
    } else {
      if (!this.ownerNgModule.has(type)) {
        return {
          dependencies: []
        };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  registerNgModule(type, scopeInfo) {
    if (!isNgModule(type)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type);
  }
  clearScopeCacheFor(type) {
    this.ngModulesScopeCache.delete(type);
    this.standaloneComponentsScopeCache.delete(type);
  }
  getNgModuleScope(type) {
    if (this.ngModulesScopeCache.has(type)) {
      return this.ngModulesScopeCache.get(type);
    }
    const scope = this.computeNgModuleScope(type);
    this.ngModulesScopeCache.set(type, scope);
    return scope;
  }
  computeNgModuleScope(type) {
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(type);
    const scope = {
      exported: {
        directives: new Set(),
        pipes: new Set()
      },
      compilation: {
        directives: new Set(),
        pipes: new Set()
      }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(980, 'The standalone imported type is neither a component nor a directive nor a pipe');
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  getStandaloneComponentScope(type, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type)) {
      return this.standaloneComponentsScopeCache.get(type);
    }
    const ans = this.computeStandaloneComponentScope(type, rawImports);
    this.standaloneComponentsScopeCache.set(type, ans);
    return ans;
  }
  computeStandaloneComponentScope(type, rawImports) {
    const ans = {
      compilation: {
        directives: new Set([type]),
        pipes: new Set(),
        ngModules: new Set()
      }
    };
    for (const rawImport of (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(rawImports ?? [])) {
      const imported = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(rawImport);
      try {
        verifyStandaloneImport(imported, type);
      } catch (e) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  isOrphanComponent(cmp) {
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
}
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
const depsTracker = /*#__PURE__*/new DepsTracker();
const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
class ChainedInjector {
  injector;
  parentInjector;
  constructor(injector, parentInjector) {
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, options) {
    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, options);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return this.parentInjector.get(token, notFoundValue, options);
  }
}
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), 'Expecting to be called in first template pass only');
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === 'number') {
        mode = value;
      } else if (mode == 1) {
        classes = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.concatStringsWithSpace)(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.concatStringsWithSpace)(styles, style + ': ' + styleValue + ';');
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function ɵɵdirectiveInject(token, flags = 0) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (lView === null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInjectImplementationNotEqual)(ɵɵdirectiveInject);
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(token, flags);
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const value = getOrCreateInjectable(tNode, lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(token), flags);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitInjectEvent)(token, value, flags);
  return value;
}
function ɵɵinvalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';
  throw new Error(msg);
}
function resolveDirectives(tView, lView, tNode, localRefs, directiveMatcher) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const exportsMap = localRefs === null ? null : {
    '': -1
  };
  const matchedDirectiveDefs = directiveMatcher(tView, tNode);
  if (matchedDirectiveDefs !== null) {
    let directiveDefs = matchedDirectiveDefs;
    let hostDirectiveDefs = null;
    let hostDirectiveRanges = null;
    for (const def of matchedDirectiveDefs) {
      if (def.resolveHostDirectives !== null) {
        [directiveDefs, hostDirectiveDefs, hostDirectiveRanges] = def.resolveHostDirectives(matchedDirectiveDefs);
        break;
      }
    }
    ngDevMode && assertNoDuplicateDirectives(directiveDefs);
    initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs, hostDirectiveRanges);
  }
  if (exportsMap !== null && localRefs !== null) {
    cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  const localNames = tNode.localNames = [];
  for (let i = 0; i < localRefs.length; i += 2) {
    const index = exportsMap[localRefs[i + 1]];
    if (index == null) throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
    localNames.push(localRefs[i], index);
  }
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(componentOffset, -1, 'componentOffset must be great than -1');
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs, hostDirectiveRanges) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const directivesLength = directives.length;
  let componentDef = null;
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (componentDef === null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
      componentDef = def;
      markAsComponentHost(tView, tNode, i);
    }
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, def.type);
  }
  initTNodeFlags(tNode, tView.data.length, directivesLength);
  if (componentDef?.viewProvidersResolver) {
    componentDef.viewProvidersResolver(componentDef);
  }
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (def.providersResolver) {
      def.providersResolver(def);
    }
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directivesLength, null);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertSame)(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');
  if (directivesLength > 0) {
    tNode.directiveToIndex = new Map();
  }
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (hostDirectiveRanges !== null && hostDirectiveRanges.has(def)) {
      const [start, end] = hostDirectiveRanges.get(def);
      tNode.directiveToIndex.set(def.type, [directiveIdx, start + tNode.directiveStart, end + tNode.directiveStart]);
    } else if (hostDirectiveDefs === null || !hostDirectiveDefs.has(def)) {
      tNode.directiveToIndex.set(def.type, directiveIdx);
    }
    if (def.contentQueries !== null) tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  for (let index = tNode.directiveStart; index < tNode.directiveEnd; index++) {
    const directiveDef = tView.data[index];
    if (hostDirectiveDefs === null || !hostDirectiveDefs.has(directiveDef)) {
      setupSelectorMatchedInputsOrOutputs(0, tNode, directiveDef, index);
      setupSelectorMatchedInputsOrOutputs(1, tNode, directiveDef, index);
      setupInitialInputs(tNode, index, false);
    } else {
      const hostDirectiveDef = hostDirectiveDefs.get(directiveDef);
      setupHostDirectiveInputsOrOutputs(0, tNode, hostDirectiveDef, index);
      setupHostDirectiveInputsOrOutputs(1, tNode, hostDirectiveDef, index);
      setupInitialInputs(tNode, index, true);
    }
  }
}
function setupSelectorMatchedInputsOrOutputs(mode, tNode, def, directiveIndex) {
  const aliasMap = mode === 0 ? def.inputs : def.outputs;
  for (const publicName in aliasMap) {
    if (aliasMap.hasOwnProperty(publicName)) {
      let bindings;
      if (mode === 0) {
        bindings = tNode.inputs ??= {};
      } else {
        bindings = tNode.outputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setupHostDirectiveInputsOrOutputs(mode, tNode, config, directiveIndex) {
  const aliasMap = mode === 0 ? config.inputs : config.outputs;
  for (const initialName in aliasMap) {
    if (aliasMap.hasOwnProperty(initialName)) {
      const publicName = aliasMap[initialName];
      let bindings;
      if (mode === 0) {
        bindings = tNode.hostDirectiveInputs ??= {};
      } else {
        bindings = tNode.hostDirectiveOutputs ??= {};
      }
      bindings[publicName] ??= [];
      bindings[publicName].push(directiveIndex, initialName);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setShadowStylingInputFlags(tNode, publicName) {
  if (publicName === 'class') {
    tNode.flags |= 8;
  } else if (publicName === 'style') {
    tNode.flags |= 16;
  }
}
function setupInitialInputs(tNode, directiveIndex, isHostDirective) {
  const {
    attrs,
    inputs,
    hostDirectiveInputs
  } = tNode;
  if (attrs === null || !isHostDirective && inputs === null || isHostDirective && hostDirectiveInputs === null || isInlineTemplate(tNode)) {
    tNode.initialInputs ??= [];
    tNode.initialInputs.push(null);
    return;
  }
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    } else if (typeof attrName === 'number') {
      break;
    }
    if (!isHostDirective && inputs.hasOwnProperty(attrName)) {
      const inputConfig = inputs[attrName];
      for (const index of inputConfig) {
        if (index === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(attrName, attrs[i + 1]);
          break;
        }
      }
    } else if (isHostDirective && hostDirectiveInputs.hasOwnProperty(attrName)) {
      const config = hostDirectiveInputs[attrName];
      for (let j = 0; j < config.length; j += 2) {
        if (config[j] === directiveIndex) {
          inputsToStore ??= [];
          inputsToStore.push(config[j + 1], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  tNode.initialInputs ??= [];
  tNode.initialInputs.push(inputsToStore);
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(directiveIndex, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Must be in Expando section');
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getFactoryDef)(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def), ɵɵdirectiveInject, ngDevMode ? def.type.name : null);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === 'number' && value < 0) {
      return value;
    }
  }
  return 0;
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) exportsMap[''] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. ` + `Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function directiveHostFirstCreatePass(index, lView, type, name, directiveMatcher, bindingsEnabled, attrsIndex, localRefsIndex) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const tViewConsts = tView.consts;
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  if (bindingsEnabled) {
    resolveDirectives(tView, lView, tNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, localRefsIndex), directiveMatcher);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function directiveHostEndFirstCreatePass(tView, tNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  registerPostOrderHooks(tView, tNode);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isContentQueryHost)(tNode)) {
    tView.queries.elementEnd(tNode);
  }
}
function domOnlyFirstCreatePass(index, tView, type, name, attrsIndex, localRefsIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const tViewConsts = tView.consts;
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (localRefsIndex != null) {
    const refs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, localRefsIndex);
    tNode.localNames = [];
    for (let i = 0; i < refs.length; i += 2) {
      tNode.localNames.push(refs[i], -1);
    }
  }
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj)) return false;
  return Array.isArray(obj) || !(obj instanceof Map) && Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done) return true;
    if (item1.done || item2.done) return false;
    if (!comparator(item1.value, item2.value)) return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === 'function' || typeof o === 'object');
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === 'object' || typeof a === 'function');
    const isBObject = b && (typeof b === 'object' || typeof b === 'function');
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, bindingIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  if (value === NO_CHANGE) {
    return false;
  }
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInCheckNoChangesMode)()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
const ɵCONTROL = /*#__PURE__*/Symbol('CONTROL');
function wrapListener(tNode, lView, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(event) {
    const startView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView) : lView;
    markViewDirty(startView, 5);
    const context = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
    let result = executeListenerWithErrorHandling(lView, context, listenerFn, event);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, event) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
  const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__.setActiveConsumer)(null);
  try {
    profiler(ProfilerEvent.OutputStart, context, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleUncaughtError(lView, error);
    return false;
  } finally {
    profiler(ProfilerEvent.OutputEnd, context, listenerFn);
    (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__.setActiveConsumer)(prevConsumer);
  }
}
function listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, originalListener, wrappedListener) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(wrappedListener, originalListener, 'Expected wrapped and original listeners to be different.');
  const isTNodeDirectiveHost = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode);
  let hasCoalesced = false;
  let existingListener = null;
  if (!eventTargetResolver && isTNodeDirectiveHost) {
    existingListener = findExistingListener(tView, lView, eventName, tNode.index);
  }
  if (existingListener !== null) {
    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
    lastListenerFn.__ngNextListenerFn__ = originalListener;
    existingListener.__ngLastListenerFn__ = originalListener;
    hasCoalesced = true;
  } else {
    const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    stashEventListenerImpl(lView, target, eventName, wrappedListener);
    const cleanupFn = renderer.listen(target, eventName, wrappedListener);
    if (!isAnimationEventType(eventName)) {
      const idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(_lView[tNode.index])) : tNode.index;
      storeListenerCleanup(idxOrTargetGetter, tView, lView, eventName, wrappedListener, cleanupFn, false);
    }
  }
  return hasCoalesced;
}
function isAnimationEventType(eventName) {
  return eventName.startsWith('animation') || eventName.startsWith('transition');
}
function findExistingListener(tView, lView, eventName, tNodeIndex) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIndex) {
        const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup && lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === 'string') {
        i += 2;
      }
    }
  }
  return null;
}
function storeListenerCleanup(indexOrTargetGetter, tView, lView, eventName, listenerFn, cleanup, isOutput) {
  const tCleanup = tView.firstCreatePass ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getOrCreateTViewCleanup)(tView) : null;
  const lCleanup = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getOrCreateLViewCleanup)(lView);
  const index = lCleanup.length;
  lCleanup.push(listenerFn, cleanup);
  tCleanup && tCleanup.push(eventName, indexOrTargetGetter, index, (index + 1) * (isOutput ? -1 : 1));
}
function createOutputListener(tNode, lView, listenerFn, targetDef, eventName) {
  const wrappedListener = wrapListener(tNode, lView, listenerFn);
  const hasBound = listenToDirectiveOutput(tNode, lView, targetDef, eventName, wrappedListener);
  if (!hasBound && ngDevMode) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(316, `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(targetDef.type)} does not have an output with a public name of "${eventName}".`);
  }
}
function listenToDirectiveOutput(tNode, lView, target, eventName, listenerFn) {
  let hostIndex = null;
  let hostDirectivesStart = null;
  let hostDirectivesEnd = null;
  let hasOutput = false;
  if (ngDevMode && !tNode.directiveToIndex?.has(target.type)) {
    throw new Error(`Node does not have a directive with type ${target.type.name}`);
  }
  const data = tNode.directiveToIndex.get(target.type);
  if (typeof data === 'number') {
    hostIndex = data;
  } else {
    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;
  }
  if (hostDirectivesStart !== null && hostDirectivesEnd !== null && tNode.hostDirectiveOutputs?.hasOwnProperty(eventName)) {
    const hostDirectiveOutputs = tNode.hostDirectiveOutputs[eventName];
    for (let i = 0; i < hostDirectiveOutputs.length; i += 2) {
      const index = hostDirectiveOutputs[i];
      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
        hasOutput = true;
        listenToOutput(tNode, lView, index, hostDirectiveOutputs[i + 1], eventName, listenerFn);
      } else if (index > hostDirectivesEnd) {
        break;
      }
    }
  }
  if (target.outputs.hasOwnProperty(eventName)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, hostIndex);
    hasOutput = true;
    listenToOutput(tNode, lView, hostIndex, eventName, eventName, listenerFn);
  }
  return hasOutput;
}
function listenToOutput(tNode, lView, directiveIndex, lookupName, eventName, listenerFn) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, directiveIndex);
  const instance = lView[directiveIndex];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const def = tView.data[directiveIndex];
  const propertyName = def.outputs[lookupName];
  const output = instance[propertyName];
  if (ngDevMode && !isOutputSubscribable(output)) {
    throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);
  }
  const subscription = output.subscribe(listenerFn);
  storeListenerCleanup(tNode.index, tView, lView, eventName, listenerFn, subscription, true);
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === 'function';
}
const BINDING = /* @__PURE__ */Symbol('BINDING');
const INPUT_BINDING_METADATA = {
  kind: 'input',
  requiredVars: 1
};
const FIELD_BINDING_METADATA = {
  kind: 'field',
  requiredVars: 2
};
const OUTPUT_BINDING_METADATA = {
  kind: 'output',
  requiredVars: 0
};
function inputBindingUpdate(targetDirectiveIdx, publicName, value) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    const componentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
    markViewDirty(componentLView, 1);
    const targetDef = tView.directiveRegistry[targetDirectiveIdx];
    if (ngDevMode && !targetDef) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(315, `Input binding to property "${publicName}" does not have a target.`);
    }
    const hasSet = setDirectiveInput(tNode, tView, lView, targetDef, publicName, value);
    if (ngDevMode) {
      if (!hasSet) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(315, `${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(targetDef.type)} does not have an input with a public name of "${publicName}".`);
      }
      storePropertyBindingMetadata(tView.data, tNode, publicName, bindingIndex);
    }
  }
}
function controlBinding(binding, tNode) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const directive = lView[tNode.directiveStart + binding.targetIdx];
  return directive[ɵCONTROL];
}
function inputBinding(publicName, value) {
  if (publicName === 'formField') {
    const binding = {
      [BINDING]: FIELD_BINDING_METADATA,
      create: () => {
        controlBinding(binding, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)())?.create();
      },
      update: () => {
        inputBindingUpdate(binding.targetIdx, publicName, value());
        controlBinding(binding, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)())?.update();
      }
    };
    return binding;
  }
  const binding = {
    [BINDING]: INPUT_BINDING_METADATA,
    update: () => inputBindingUpdate(binding.targetIdx, publicName, value())
  };
  return binding;
}
function outputBinding(eventName, listener) {
  const binding = {
    [BINDING]: OUTPUT_BINDING_METADATA,
    create: () => {
      const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
      const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
      const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
      const targetDef = tView.directiveRegistry[binding.targetIdx];
      createOutputListener(tNode, lView, listener, targetDef, eventName);
    }
  };
  return binding;
}
function twoWayBinding(publicName, value) {
  const input = inputBinding(publicName, value);
  const output = outputBinding(publicName + 'Change', eventValue => value.set(eventValue));
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotDefined)(input.create, 'Unexpected `create` callback in inputBinding');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotDefined)(output.update, 'Unexpected `update` callback in outputBinding');
  const binding = {
    [BINDING]: {
      kind: 'twoWay',
      requiredVars: input[BINDING].requiredVars + output[BINDING].requiredVars
    },
    set targetIdx(idx) {
      input.targetIdx = idx;
      output.targetIdx = idx;
    },
    create: output.create,
    update: input.update
  };
  return binding;
}
class ComponentFactoryResolver extends ComponentFactoryResolver$1 {
  ngModule;
  constructor(ngModule) {
    super();
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertComponentType)(component);
    const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(component);
    return new ComponentFactory(componentDef, this.ngModule);
  }
}
function toInputRefArray(map) {
  return Object.keys(map).map(name => {
    const [propName, flags, transform] = map[name];
    const inputData = {
      propName: propName,
      templateName: name,
      isSignal: (flags & InputFlags.SignalBased) !== 0
    };
    if (transform) {
      inputData.transform = transform;
    }
    return inputData;
  });
}
function toOutputRefArray(map) {
  return Object.keys(map).map(name => ({
    propName: map[name],
    templateName: name
  }));
}
function verifyNotAnOrphanComponent(componentDef) {
  if ((typeof ngJitMode === 'undefined' || ngJitMode) && componentDef.debugInfo?.forbidOrphanRendering) {
    if (depsTracker.isOrphanComponent(componentDef.type)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(981, `Orphan component found! Trying to render the component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.debugStringifyTypeForError)(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
    }
  }
}
function createRootViewInjector(componentDef, environmentInjector, injector) {
  let realEnvironmentInjector = environmentInjector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
  if (realEnvironmentInjector && componentDef.getStandaloneInjector !== null) {
    realEnvironmentInjector = componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
  }
  const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
  return rootViewInjector;
}
function createRootLViewEnvironment(rootLViewInjector) {
  const rendererFactory = rootLViewInjector.get(RendererFactory2, null);
  if (rendererFactory === null) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(407, ngDevMode && 'Angular was not able to inject a renderer (RendererFactory2). ' + 'Likely this is due to a broken DI hierarchy. ' + 'Make sure that any injector used to create this component has a correct parent.');
  }
  const sanitizer = rootLViewInjector.get(Sanitizer, null);
  const changeDetectionScheduler = rootLViewInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionScheduler, null);
  let ngReflect = false;
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    ngReflect = rootLViewInjector.get(NG_REFLECT_ATTRS_FLAG, NG_REFLECT_ATTRS_FLAG_DEFAULT);
  }
  return {
    rendererFactory,
    sanitizer,
    changeDetectionScheduler,
    ngReflect
  };
}
function createHostElement(componentDef, renderer) {
  const tagName = inferTagNameFromDefinition(componentDef);
  const namespace = tagName === 'svg' ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SVG_NAMESPACE : tagName === 'math' ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MATH_ML_NAMESPACE : null;
  return createElementNode(renderer, tagName, namespace);
}
function inferTagNameFromDefinition(componentDef) {
  return (componentDef.selectors[0][0] || 'div').toLowerCase();
}
class ComponentFactory extends ComponentFactory$1 {
  componentDef;
  ngModule;
  selector;
  componentType;
  ngContentSelectors;
  isBoundToModule;
  cachedInputs = null;
  cachedOutputs = null;
  get inputs() {
    this.cachedInputs ??= toInputRefArray(this.componentDef.inputs);
    return this.cachedInputs;
  }
  get outputs() {
    this.cachedOutputs ??= toOutputRefArray(this.componentDef.outputs);
    return this.cachedOutputs;
  }
  constructor(componentDef, ngModule) {
    super();
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = componentDef.ngContentSelectors ?? [];
    this.isBoundToModule = !!ngModule;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector, directives, componentBindings) {
    profiler(ProfilerEvent.DynamicComponentStart);
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const cmpDef = this.componentDef;
      ngDevMode && verifyNotAnOrphanComponent(cmpDef);
      const rootTView = createRootTView(rootSelectorOrNode, cmpDef, componentBindings, directives);
      const rootViewInjector = createRootViewInjector(cmpDef, environmentInjector || this.ngModule, injector);
      const environment = createRootLViewEnvironment(rootViewInjector);
      const hostRenderer = environment.rendererFactory.createRenderer(null, cmpDef);
      const hostElement = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, cmpDef.encapsulation, rootViewInjector) : createHostElement(cmpDef, hostRenderer);
      const hasInputBindings = componentBindings?.some(isInputBinding) || directives?.some(d => typeof d !== 'function' && d.bindings.some(isInputBinding));
      const rootLView = createLView(null, rootTView, null, 512 | getInitialLViewFlagsFromDef(cmpDef), null, null, environment, hostRenderer, rootViewInjector, null, retrieveHydrationInfo(hostElement, rootViewInjector, true));
      rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET] = hostElement;
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterView)(rootLView);
      let componentView = null;
      try {
        const hostTNode = directiveHostFirstCreatePass(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, rootLView, 2, '#host', () => rootTView.directiveRegistry, true, 0);
        setupStaticAttributes(hostRenderer, hostElement, hostTNode);
        attachPatchData(hostElement, rootLView);
        createDirectivesInstances(rootTView, rootLView, hostTNode);
        executeContentQueries(rootTView, hostTNode, rootLView);
        directiveHostEndFirstCreatePass(rootTView, hostTNode);
        if (projectableNodes !== undefined) {
          projectNodes(hostTNode, this.ngContentSelectors, projectableNodes);
        }
        componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(hostTNode.index, rootLView);
        rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
        renderView(rootTView, rootLView, null);
      } catch (e) {
        if (componentView !== null) {
          unregisterLView(componentView);
        }
        unregisterLView(rootLView);
        throw e;
      } finally {
        profiler(ProfilerEvent.DynamicComponentEnd);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveView)();
      }
      return new ComponentRef(this.componentType, rootLView, !!hasInputBindings);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function createRootTView(rootSelectorOrNode, componentDef, componentBindings, directives) {
  const tAttributes = rootSelectorOrNode ? ['ng-version', '21.1.0'] : extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
  let creationBindings = null;
  let updateBindings = null;
  let varsToAllocate = 0;
  if (componentBindings) {
    for (const binding of componentBindings) {
      varsToAllocate += binding[BINDING].requiredVars;
      if (binding.create) {
        binding.targetIdx = 0;
        (creationBindings ??= []).push(binding);
      }
      if (binding.update) {
        binding.targetIdx = 0;
        (updateBindings ??= []).push(binding);
      }
    }
  }
  if (directives) {
    for (let i = 0; i < directives.length; i++) {
      const directive = directives[i];
      if (typeof directive !== 'function') {
        for (const binding of directive.bindings) {
          varsToAllocate += binding[BINDING].requiredVars;
          const targetDirectiveIdx = i + 1;
          if (binding.create) {
            binding.targetIdx = targetDirectiveIdx;
            (creationBindings ??= []).push(binding);
          }
          if (binding.update) {
            binding.targetIdx = targetDirectiveIdx;
            (updateBindings ??= []).push(binding);
          }
        }
      }
    }
  }
  const directivesToApply = [componentDef];
  if (directives) {
    for (const directive of directives) {
      const directiveType = typeof directive === 'function' ? directive : directive.type;
      const directiveDef = ngDevMode ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDefOrThrow)(directiveType) : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(directiveType);
      if (ngDevMode && !directiveDef.standalone) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(907, `The ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(directiveType)} directive must be standalone in ` + `order to be applied to a dynamically-created component.`);
      }
      directivesToApply.push(directiveDef);
    }
  }
  const rootTView = createTView(0, null, getRootTViewTemplate(creationBindings, updateBindings), 1, varsToAllocate, directivesToApply, null, null, null, [tAttributes], null);
  return rootTView;
}
function getRootTViewTemplate(creationBindings, updateBindings) {
  if (!creationBindings && !updateBindings) {
    return null;
  }
  return flags => {
    if (flags & 1 && creationBindings) {
      for (const binding of creationBindings) {
        binding.create();
      }
    }
    if (flags & 2 && updateBindings) {
      for (const binding of updateBindings) {
        binding.update();
      }
    }
  };
}
function isInputBinding(binding) {
  const kind = binding[BINDING].kind;
  return kind === 'input' || kind === 'twoWay';
}
class ComponentRef extends ComponentRef$1 {
  _rootLView;
  _hasInputBindings;
  instance;
  hostView;
  changeDetectorRef;
  componentType;
  location;
  previousInputValues = null;
  _tNode;
  constructor(componentType, _rootLView, _hasInputBindings) {
    super();
    this._rootLView = _rootLView;
    this._hasInputBindings = _hasInputBindings;
    this._tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(_rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    this.location = createElementRef(this._tNode, _rootLView);
    this.instance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(this._tNode.index, _rootLView)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
    this.hostView = this.changeDetectorRef = new ViewRef(_rootLView, undefined);
    this.componentType = componentType;
  }
  setInput(name, value) {
    if (this._hasInputBindings && ngDevMode) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(317, 'Cannot call `setInput` on a component that is using the `inputBinding` or `twoWayBinding` functions.');
    }
    const tNode = this._tNode;
    this.previousInputValues ??= new Map();
    if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
      return;
    }
    const lView = this._rootLView;
    const hasSetInput = setAllInputsForProperty(tNode, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView, name, value);
    this.previousInputValues.set(name, value);
    const childComponentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
    markViewDirty(childComponentLView, 1);
    if (ngDevMode && !hasSetInput) {
      const cmpNameForError = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(this.componentType);
      let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
      message += `Make sure that the '${name}' property is declared as an input using the input() or model() function or the @Input() decorator.`;
      reportUnknownPropertyError(message);
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);
  }
}
let ViewContainerRef = /*#__PURE__*/(() => {
  class ViewContainerRef {
    static __NG_ELEMENT_ID__ = injectViewContainerRef;
  }
  return ViewContainerRef;
})();
function injectViewContainerRef() {
  const previousTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  return createContainerRef(previousTNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)());
}
const VE_ViewContainerRef = ViewContainerRef;
const R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {
  _lContainer;
  _hostTNode;
  _hostLView;
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNodeInjector)(parentView, injectorIndex);
      const parentTNode = parentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[injectorIndex + 8];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index] || null;
  }
  get length() {
    return this._lContainer.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context, indexOrOptions) {
    let index;
    let injector;
    if (typeof indexOrOptions === 'number') {
      index = indexOrOptions;
    } else if (indexOrOptions != null) {
      index = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector, directives, bindings) {
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index;
    if (isComponentFactory) {
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' + 'and an options object as the second argument. This combination of arguments ' + 'is incompatible. You can either change the first argument to provide Component ' + 'type or change the second argument to be a number (representing an index at ' + "which to insert the new component's host view into this container)");
      }
      index = indexOrOptions;
    } else {
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` + `Please check whether provided class has @Component decorator.`);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' + "and a number (representing an index at which to insert the new component's " + 'host view into this container as the second argument. This combination of arguments ' + 'is incompatible. Please use an object as the second argument instead.');
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
      directives = options.directives;
      bindings = options.bindings;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(componentFactory.componentType ?? {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
    const rNode = dehydratedView?.firstChild ?? null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector, directives, bindings);
    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index) {
    return this.insertImpl(viewRef, index, true);
  }
  insertImpl(viewRef, index, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(922, ngDevMode && 'Cannot insert a destroyed View in a ViewContainer!');
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.viewAttachedToContainer)(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(prevLContainer), true, 'An attached view should have its PARENT point to a container.');
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST], prevLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.addToArray)(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(923, ngDevMode && 'Cannot move a destroyed View in a ViewContainer!');
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], detachedView);
    }
  }
  detach(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef(view) : null;
  }
  _adjustIndex(index, shift = 0) {
    if (index == null) {
      return this.length + shift;
    }
    if (ngDevMode) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(index, -1, `ViewRef index must be positive, got ${index}`);
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(index, this.length + 1 + shift, 'index');
    }
    return index;
  }
};
function getViewRefs(lContainer) {
  return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS] || (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(hostTNode, 12 | 3);
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToEndOfViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const commentNode = renderer.createComment(ngDevMode ? 'container' : '');
  const hostNative = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(hostTNode, hostLView);
  const parentOfHostNative = renderer.parentNode(hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, renderer.nextSibling(hostNative), false);
  return commentNode;
}
let _locateOrCreateAnchorNode = createAnchorNode;
let _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE]) return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] = commentNode;
}
function populateDehydratedViewsInLContainerImpl(lContainer, tNode, hostLView) {
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] && lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]) {
    return true;
  }
  const hydrationInfo = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const noOffsetIndex = tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock(tNode) || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  if (isNodeCreationMode) {
    return false;
  }
  const currentRNode = getSegmentHead(hydrationInfo, noOffsetIndex);
  const serializedViews = hydrationInfo.data[CONTAINERS]?.[noOffsetIndex];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(serializedViews, 'Unexpected state: no hydration info available for a given TNode, ' + 'which represents a view container.');
  const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(currentRNode, serializedViews);
  if (ngDevMode) {
    validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, tNode, true);
    markRNodeAsClaimedByHydration(commentNode, false);
  }
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE] = commentNode;
  lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS] = dehydratedViews;
  return true;
}
function locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (!_populateDehydratedViewsInLContainer(lContainer, hostTNode, hostLView)) {
    createAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  }
}
function enableLocateOrCreateContainerRefImpl() {
  _locateOrCreateAnchorNode = locateOrCreateAnchorNode;
  _populateDehydratedViewsInLContainer = populateDehydratedViewsInLContainerImpl;
}
class LQuery_ {
  queryList;
  matches = null;
  constructor(queryList) {
    this.queryList = queryList;
  }
  clone() {
    return new LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
}
class LQueries_ {
  queries;
  constructor(queries = []) {
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i = 0; i < noOfInheritedQueries; i++) {
        const tQuery = tQueries.getByIndex(i);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i = 0; i < this.queries.length; i++) {
      if (getTQuery(tView, i).matches !== null) {
        this.queries[i].setDirty();
      }
    }
  }
}
class TQueryMetadata_ {
  flags;
  read;
  predicate;
  constructor(predicate, flags, read = null) {
    this.flags = flags;
    this.read = read;
    if (typeof predicate === 'string') {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
}
class TQueries_ {
  queries;
  constructor(queries = []) {
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView, 'Queries should collect results on the first template pass only');
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i = 0; i < this.length; i++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView, 'Queries should collect results on the first template pass only');
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].template(tView, tNode);
    }
  }
  getByIndex(index) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(this.queries, index);
    return this.queries[index];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
}
class TQuery_ {
  metadata;
  matches = null;
  indexInDeclarationView = -1;
  crossesNgTemplate = false;
  _declarationNodeIndex;
  _appliesToNextNode = true;
  constructor(metadata, nodeIndex = -1) {
    this.metadata = metadata;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent = tNode.parent;
      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
        parent = parent.parent;
      }
      return declarationNodeIdx === (parent !== null ? parent.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i = 0; i < predicate.length; i++) {
        const name = predicate[i];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
}
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(declarationLContainer);
        for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {
          const embeddedLView = declarationLContainer[i];
          if (embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER] === embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT]) {
            collectQueryResults(embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.MOVED_VIEWS];
          for (let i = 0; i < embeddedLViews.length; i++) {
            const embeddedLView = embeddedLViews[i];
            collectQueryResults(embeddedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES], 'LQueries should be defined when trying to load a query');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES].queries, queryIndex);
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList((flags & 4) === 4);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeCleanupWithContext)(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(flags, 'Expecting flags');
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(flags, 'Expecting flags');
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  if (tView.firstCreatePass) {
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(',').map(s => s.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null) tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView.queries, 'TQueries must be defined to retrieve a TQuery');
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function createQuerySignalFn(firstOnly, required, opts) {
  let node;
  const signalFn = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createComputed)(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === undefined) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-951, ngDevMode && 'Child query result is required but no value is available.');
    }
    return value;
  });
  node = signalFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  node._dirtyCounter = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)(0);
  node._flatValue = undefined;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
    node.debugName = opts?.debugName;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn(opts) {
  return createQuerySignalFn(true, false, opts);
}
function createSingleResultRequiredQuerySignalFn(opts) {
  return createQuerySignalFn(true, true, opts);
}
function createMultiResultQuerySignalFn(opts) {
  return createQuerySignalFn(false, false, opts);
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  node._lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update(v => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === undefined || queryIndex === undefined || lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] & 4) {
    return firstOnly ? undefined : _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === undefined) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
let componentResourceResolutionQueue = /*#__PURE__*/new Map();
const componentDefPendingResolution = /*#__PURE__*/new Set();
function resolveComponentResources(_x) {
  return _resolveComponentResources.apply(this, arguments);
}
function _resolveComponentResources() {
  _resolveComponentResources = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (resourceResolver) {
    const currentQueue = componentResourceResolutionQueue;
    componentResourceResolutionQueue = new Map();
    const urlCache = new Map();
    function cachedResourceResolve(url) {
      const promiseCached = urlCache.get(url);
      if (promiseCached) {
        return promiseCached;
      }
      const promise = resourceResolver(url).then(response => unwrapResponse(url, response));
      urlCache.set(url, promise);
      return promise;
    }
    const resolutionPromises = Array.from(currentQueue).map(/*#__PURE__*/function () {
      var _ref = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* ([type, component]) {
        if (component.styleUrl && component.styleUrls?.length) {
          throw new Error('@Component cannot define both `styleUrl` and `styleUrls`. ' + 'Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple');
        }
        const componentTasks = [];
        if (component.templateUrl) {
          componentTasks.push(cachedResourceResolve(component.templateUrl).then(template => {
            component.template = template;
          }));
        }
        const styles = typeof component.styles === 'string' ? [component.styles] : component.styles ?? [];
        component.styles = styles;
        let {
          styleUrl,
          styleUrls
        } = component;
        if (styleUrl) {
          styleUrls = [styleUrl];
          component.styleUrl = undefined;
        }
        if (styleUrls?.length) {
          const allFetched = Promise.all(styleUrls.map(url => cachedResourceResolve(url))).then(fetchedStyles => {
            styles.push(...fetchedStyles);
            component.styleUrls = undefined;
          });
          componentTasks.push(allFetched);
        }
        yield Promise.all(componentTasks);
        componentDefPendingResolution.delete(type);
      });
      return function (_x1) {
        return _ref.apply(this, arguments);
      };
    }());
    yield Promise.all(resolutionPromises);
  });
  return _resolveComponentResources.apply(this, arguments);
}
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function isComponentDefPendingResolution(type) {
  return componentDefPendingResolution.has(type);
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls?.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = new Map();
  return old;
}
function restoreComponentResolutionQueue(queue) {
  componentDefPendingResolution.clear();
  for (const type of queue.keys()) {
    componentDefPendingResolution.add(type);
  }
  componentResourceResolutionQueue = queue;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(_x2, _x3) {
  return _unwrapResponse.apply(this, arguments);
}
function _unwrapResponse() {
  _unwrapResponse = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, response) {
    if (typeof response === 'string') {
      return response;
    }
    if (response.status !== undefined && response.status !== 200) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(918, ngDevMode && `Could not load resource: ${url}. Response status: ${response.status}`);
    }
    return response.text();
  });
  return _unwrapResponse.apply(this, arguments);
}
const modules = /*#__PURE__*/new Map();
let checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(921, ngDevMode && `Duplicate module registered for ${id} - ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(type)} vs ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function getRegisteredNgModuleType(id) {
  return modules.get(id);
}
function setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {
  checkForDuplicateNgModules = !allowDuplicates;
}
let NgModuleRef$1 = class NgModuleRef {};
let NgModuleFactory$1 = class NgModuleFactory {};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector ?? null, []);
}
const createNgModuleRef = createNgModule;
class NgModuleRef extends NgModuleRef$1 {
  ngModuleType;
  _parent;
  _bootstrapComponents = [];
  _r3Injector;
  instance;
  destroyCbs = [];
  componentFactoryResolver = /*#__PURE__*/new ComponentFactoryResolver(this);
  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
    super();
    this.ngModuleType = ngModuleType;
    this._parent = _parent;
    const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(ngModuleType);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(ngModuleDef, `NgModule '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.createInjectorWithoutInjectorInstances)(ngModuleType, _parent, [{
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }, ...additionalProviders], (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(ngModuleType), new Set(['environment']));
    if (runInjectorInitializers) {
      this.resolveInjectorInitializers();
    }
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(this.ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(this.destroyCbs, 'NgModule already destroyed');
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach(fn => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(this.destroyCbs, 'NgModule already destroyed');
    this.destroyCbs.push(callback);
  }
}
class NgModuleFactory extends NgModuleFactory$1 {
  moduleType;
  constructor(moduleType) {
    super();
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef(this.moduleType, parentInjector, []);
  }
}
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef(moduleType, parentInjector, additionalProviders, false);
}
class EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {
  injector;
  componentFactoryResolver = /*#__PURE__*/new ComponentFactoryResolver(this);
  instance = null;
  constructor(config) {
    super();
    const injector = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector([...config.providers, {
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }], config.parent || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNullInjector)(), config.debugName, new Set(['environment']));
    this.injector = injector;
    if (config.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
}
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
let StandaloneService = /*#__PURE__*/(() => {
  class StandaloneService {
    _injector;
    cachedInjectors = new Map();
    constructor(_injector) {
      this._injector = _injector;
    }
    getOrCreateStandaloneInjector(componentDef) {
      if (!componentDef.standalone) {
        return null;
      }
      if (!this.cachedInjectors.has(componentDef)) {
        const providers = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.internalImportProvidersFrom)(false, componentDef.type);
        const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, typeof ngDevMode !== 'undefined' && ngDevMode ? `Standalone[${componentDef.type.name}]` : '') : null;
        this.cachedInjectors.set(componentDef, standaloneInjector);
      }
      return this.cachedInjectors.get(componentDef);
    }
    ngOnDestroy() {
      try {
        for (const injector of this.cachedInjectors.values()) {
          if (injector !== null) {
            injector.destroy();
          }
        }
      } finally {
        this.cachedInjectors.clear();
      }
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: StandaloneService,
      providedIn: 'environment',
      factory: () => new StandaloneService((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector))
    });
  }
  return StandaloneService;
})();
function ɵɵdefineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === 'undefined' || ngDevMode) && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.initNgDevMode)();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = {
      ...baseDef,
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      pipeDefs: null,
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: baseDef.standalone ? parentInjector => {
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);
      } : null,
      getExternalStyles: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
      styles: componentDefinition.styles || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ''
    };
    if (baseDef.standalone) {
      performanceMarkFeature('NgStandalone');
    }
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(dependencies, extractDirectiveDef);
    def.pipeDefs = extractDefListOrFactory(dependencies, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef);
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
}
function ɵɵdefineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      declarations: def.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      imports: def.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      exports: def.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertInputsForDefinition(obj, declaredInputs) {
  if (obj == null) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags;
      let transform;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = value[2] ?? publicName;
        transform = value[3] || null;
      } else {
        publicName = value;
        declaredName = value;
        inputFlags = InputFlags.None;
        transform = null;
      }
      newLookup[publicName] = [minifiedKey, inputFlags, transform];
      declaredInputs[publicName] = declaredName;
    }
  }
  return newLookup;
}
function parseAndConvertOutputsForDefinition(obj) {
  if (obj == null) return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      newLookup[obj[minifiedKey]] = minifiedKey;
    }
  }
  return newLookup;
}
function ɵɵdefineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function ɵɵdefinePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone ?? true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    viewProvidersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs: declaredInputs,
    inputConfig: directiveDefinition.inputs || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone ?? true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    resolveHostDirectives: null,
    hostDirectives: null,
    inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach(fn => fn(definition));
}
function extractDefListOrFactory(dependencies, defExtractor) {
  if (!dependencies) {
    return null;
  }
  return () => {
    const resolvedDependencies = typeof dependencies === 'function' ? dependencies() : dependencies;
    const result = [];
    for (const dep of resolvedDependencies) {
      const definition = defExtractor(dep);
      if (definition !== null) {
        result.push(definition);
      }
    }
    return result;
  };
}
const GENERATED_COMP_IDS = /*#__PURE__*/new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const componentDefConsts = typeof componentDef.consts === 'function' ? '' : componentDef.consts;
  const hashSelectors = [componentDef.selectors, componentDef.ngContentSelectors, componentDef.hostVars, componentDef.hostAttrs, componentDefConsts, componentDef.vars, componentDef.decls, componentDef.encapsulation, componentDef.standalone, componentDef.signals, componentDef.exportAs, JSON.stringify(componentDef.inputs), JSON.stringify(componentDef.outputs), Object.getOwnPropertyNames(componentDef.type.prototype), !!componentDef.contentQueries, !!componentDef.viewQuery];
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    for (const item of hashSelectors) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(typeof item, 'function', 'Internal error: attempting to use a function in component id computation logic.');
    }
  }
  for (const char of hashSelectors.join('|')) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = 'c' + hash;
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && (typeof ngServerMode === 'undefined' || !ngServerMode)) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function ɵɵHostDirectivesFeature(rawHostDirectives) {
  const feature = definition => {
    const isEager = Array.isArray(rawHostDirectives);
    if (definition.hostDirectives === null) {
      definition.resolveHostDirectives = resolveHostDirectives;
      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];
    } else if (isEager) {
      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));
    } else {
      definition.hostDirectives.unshift(rawHostDirectives);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function resolveHostDirectives(matches) {
  const allDirectiveDefs = [];
  let hasComponent = false;
  let hostDirectiveDefs = null;
  let hostDirectiveRanges = null;
  for (let i = 0; i < matches.length; i++) {
    const def = matches[i];
    if (def.hostDirectives !== null) {
      const start = allDirectiveDefs.length;
      hostDirectiveDefs ??= new Map();
      hostDirectiveRanges ??= new Map();
      findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);
      hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);
    }
    if (i === 0 && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def)) {
      hasComponent = true;
      allDirectiveDefs.push(def);
    }
  }
  for (let i = hasComponent ? 1 : 0; i < matches.length; i++) {
    allDirectiveDefs.push(matches[i]);
  }
  return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const configOrFn of currentDef.hostDirectives) {
      if (typeof configOrFn === 'function') {
        const resolved = configOrFn();
        for (const config of resolved) {
          trackHostDirectiveDef(createHostDirectiveDef(config), matchedDefs, hostDirectiveDefs);
        }
      } else {
        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);
      }
    }
  }
}
function trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {
  const hostDirectiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(def.directive);
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    validateHostDirective(def, hostDirectiveDef);
  }
  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);
  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
  hostDirectiveDefs.set(hostDirectiveDef, def);
  matchedDefs.push(hostDirectiveDef);
}
function createHostDirectiveDef(config) {
  return typeof config === 'function' ? {
    directive: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(config),
    inputs: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    outputs: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ
  } : {
    directive: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(config.directive),
    inputs: bindingArrayToMap(config.inputs),
    outputs: bindingArrayToMap(config.outputs)
  };
}
function bindingArrayToMap(bindings) {
  if (bindings === undefined || bindings.length === 0) {
    return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) !== null) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. ` + `Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings('input', directiveDef, hostDirectiveConfig.inputs);
  validateMappings('output', directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === 'input' ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function ɵɵInheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = undefined;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(definition)) {
      superDef = superType.ɵcmp || superType.ɵdir;
    } else {
      if (superType.ɵcmp) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(definition.type)} is attempting to extend component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(superType)}`);
      }
      superDef = superType.ɵdir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.fillProperties)(definition.outputs, superDef.outputs);
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === ɵɵInheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value !== undefined) {
      target.inputs[key] = value;
      target.declaredInputs[key] = source.declaredInputs[key];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
    return {};
  } else if (value === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
function templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags) {
  if (declarationTView.firstCreatePass) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    const embeddedTView = tNode.tView = createTView(2, tNode, templateFn, decls, vars, declarationTView.directiveRegistry, declarationTView.pipeRegistry, null, declarationTView.schemas, declarationTView.consts, null);
    if (declarationTView.queries !== null) {
      declarationTView.queries.template(declarationTView, tNode);
      embeddedTView.queries = declarationTView.queries.embeddedTView(tNode);
    }
  }
  if (flags) {
    tNode.flags |= flags;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET] = lContainer;
  addToEndOfViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
}
function declareDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingsEnabled)()) {
      resolveDirectives(declarationTView, declarationLView, tNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(declarationTView.consts, localRefsIndex), findDirectiveDefMatches);
    }
    registerPostOrderHooks(declarationTView, tNode);
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function declareNoDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (localRefsIndex != null) {
      const refs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(declarationTView.consts, localRefsIndex);
      tNode.localNames = [];
      for (let i = 0; i < refs.length; i += 2) {
        tNode.localNames.push(refs[i], -1);
      }
    }
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, undefined, localRefsIndex, localRefExtractor);
  return ɵɵtemplate;
}
function ɵɵdomTemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, undefined, localRefsIndex, localRefExtractor);
  return ɵɵdomTemplate;
}
let _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER].createComment(ngDevMode ? 'container' : '');
}
function locateOrCreateContainerAnchorImpl(tView, lView, tNode, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  const ssrId = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION]?.data[TEMPLATES]?.[index] ?? null;
  if (ssrId !== null && tNode.tView !== null) {
    if (tNode.tView.ssrId === null) {
      tNode.tView.ssrId = ssrId;
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tNode.tView.ssrId, ssrId, 'Unexpected value of the `ssrId` for this TView');
    }
  }
  if (isNodeCreationMode) {
    return createContainerAnchorImpl(tView, lView);
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  setSegmentHead(hydrationInfo, index, currentRNode);
  const viewContainerSize = calcSerializedContainerSize(hydrationInfo, index);
  const comment = siblingAfter(viewContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateContainerAnchorImpl() {
  _locateOrCreateContainerAnchor = locateOrCreateContainerAnchorImpl;
}
var DeferDependenciesLoadingState = /*#__PURE__*/function (DeferDependenciesLoadingState) {
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState[DeferDependenciesLoadingState["FAILED"] = 3] = "FAILED";
  return DeferDependenciesLoadingState;
}(DeferDependenciesLoadingState || {});
const MINIMUM_SLOT = 0;
const LOADING_AFTER_SLOT = 1;
var DeferBlockState = /*#__PURE__*/function (DeferBlockState) {
  DeferBlockState[DeferBlockState["Placeholder"] = 0] = "Placeholder";
  DeferBlockState[DeferBlockState["Loading"] = 1] = "Loading";
  DeferBlockState[DeferBlockState["Complete"] = 2] = "Complete";
  DeferBlockState[DeferBlockState["Error"] = 3] = "Error";
  return DeferBlockState;
}(DeferBlockState || {});
var DeferBlockInternalState = /*#__PURE__*/function (DeferBlockInternalState) {
  DeferBlockInternalState[DeferBlockInternalState["Initial"] = -1] = "Initial";
  return DeferBlockInternalState;
}(DeferBlockInternalState || {});
const NEXT_DEFER_BLOCK_STATE = 0;
const DEFER_BLOCK_STATE = 1;
const STATE_IS_FROZEN_UNTIL = 2;
const LOADING_AFTER_CLEANUP_FN = 3;
const TRIGGER_CLEANUP_FNS = 4;
const PREFETCH_TRIGGER_CLEANUP_FNS = 5;
const SSR_UNIQUE_ID = 6;
const SSR_BLOCK_STATE = 7;
const ON_COMPLETE_FNS = 8;
const HYDRATE_TRIGGER_CLEANUP_FNS = 9;
var DeferBlockBehavior = /*#__PURE__*/function (DeferBlockBehavior) {
  DeferBlockBehavior[DeferBlockBehavior["Manual"] = 0] = "Manual";
  DeferBlockBehavior[DeferBlockBehavior["Playthrough"] = 1] = "Playthrough";
  return DeferBlockBehavior;
}(DeferBlockBehavior || {});
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = getCleanupFnKeyByType(type);
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = getCleanupFnKeyByType(type);
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
  invokeTriggerCleanupFns(2, lDetails);
}
function getCleanupFnKeyByType(type) {
  let key = TRIGGER_CLEANUP_FNS;
  if (type === 1) {
    key = PREFETCH_TRIGGER_CLEANUP_FNS;
  } else if (type === 2) {
    key = HYDRATE_TRIGGER_CLEANUP_FNS;
  }
  return key;
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInDeclRange)(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, 'Expecting all deferred dependencies to be loaded.');
}
function isTDeferBlockDetails(value) {
  return value !== null && typeof value === 'object' && typeof value.primaryTmplIndex === 'number';
}
function isDeferBlock(tView, tNode) {
  let tDetails = null;
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  if (_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET < slotIndex && slotIndex < tView.bindingStartIndex) {
    tDetails = getTDeferBlockDetails(tView, tNode);
  }
  return !!tDetails && isTDeferBlockDetails(tDetails);
}
function trackTriggerForDebugging(tView, tNode, textRepresentation) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  tDetails.debug ??= {};
  tDetails.debug.triggers ??= new Set();
  tDetails.debug.triggers.add(textRepresentation);
}
function onViewportWrapper(trigger, callback, injector, wrapperOptions) {
  const ngZone = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  return onViewport(trigger, () => ngZone.run(callback), options => ngZone.runOutsideAngular(() => createIntersectionObserver(options)), wrapperOptions);
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.walkUpViews)(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(deferredContainer);
  const triggerLView = deferredContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(renderedState, DeferBlockState.Placeholder, 'Expected a placeholder to be rendered in this defer block.');
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertElement)(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type, options) {
  const injector = initialLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const zone = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  let poll;
  function pollDomTrigger() {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(initialLView)) {
      poll.destroy();
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      poll.destroy();
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      return;
    }
    poll.destroy();
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      zone.run(() => {
        if (initialLView !== triggerLView) {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeLViewOnDestroy)(triggerLView, cleanup);
        }
        callback();
      });
    }, injector, options);
    if (initialLView !== triggerLView) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeLViewOnDestroy)(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  poll = afterEveryRender({
    read: pollDomTrigger
  }, {
    injector
  });
}
function onIdle(callback, injector) {
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
const _requestIdleCallback = () => typeof requestIdleCallback !== 'undefined' ? requestIdleCallback : setTimeout;
const _cancelIdleCallback = () => typeof requestIdleCallback !== 'undefined' ? cancelIdleCallback : clearTimeout;
let IdleScheduler = /*#__PURE__*/(() => {
  class IdleScheduler {
    executingCallbacks = false;
    idleId = null;
    current = new Set();
    deferred = new Set();
    ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
    requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
    cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
    add(callback) {
      const target = this.executingCallbacks ? this.deferred : this.current;
      target.add(callback);
      if (this.idleId === null) {
        this.scheduleIdleCallback();
      }
    }
    remove(callback) {
      const {
        current,
        deferred
      } = this;
      current.delete(callback);
      deferred.delete(callback);
      if (current.size === 0 && deferred.size === 0) {
        this.cancelIdleCallback();
      }
    }
    scheduleIdleCallback() {
      const callback = () => {
        this.cancelIdleCallback();
        this.executingCallbacks = true;
        for (const callback of this.current) {
          callback();
        }
        this.current.clear();
        this.executingCallbacks = false;
        if (this.deferred.size > 0) {
          for (const callback of this.deferred) {
            this.current.add(callback);
          }
          this.deferred.clear();
          this.scheduleIdleCallback();
        }
      };
      this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
    }
    cancelIdleCallback() {
      if (this.idleId !== null) {
        this.cancelIdleCallbackFn(this.idleId);
        this.idleId = null;
      }
    }
    ngOnDestroy() {
      this.cancelIdleCallback();
      this.current.clear();
      this.deferred.clear();
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: IdleScheduler,
      providedIn: 'root',
      factory: () => new IdleScheduler()
    });
  }
  return IdleScheduler;
})();
function onTimer(delay) {
  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);
}
function scheduleTimerTrigger(delay, callback, injector) {
  const scheduler = injector.get(TimerScheduler);
  const ngZone = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback, ngZone);
  return cleanupFn;
}
let TimerScheduler = /*#__PURE__*/(() => {
  class TimerScheduler {
    executingCallbacks = false;
    timeoutId = null;
    invokeTimerAt = null;
    current = [];
    deferred = [];
    add(delay, callback, ngZone) {
      const target = this.executingCallbacks ? this.deferred : this.current;
      this.addToQueue(target, Date.now() + delay, callback);
      this.scheduleTimer(ngZone);
    }
    remove(callback) {
      const {
        current,
        deferred
      } = this;
      const callbackIndex = this.removeFromQueue(current, callback);
      if (callbackIndex === -1) {
        this.removeFromQueue(deferred, callback);
      }
      if (current.length === 0 && deferred.length === 0) {
        this.clearTimeout();
      }
    }
    addToQueue(target, invokeAt, callback) {
      let insertAtIndex = target.length;
      for (let i = 0; i < target.length; i += 2) {
        const invokeQueuedCallbackAt = target[i];
        if (invokeQueuedCallbackAt > invokeAt) {
          insertAtIndex = i;
          break;
        }
      }
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arrayInsert2)(target, insertAtIndex, invokeAt, callback);
    }
    removeFromQueue(target, callback) {
      let index = -1;
      for (let i = 0; i < target.length; i += 2) {
        const queuedCallback = target[i + 1];
        if (queuedCallback === callback) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arraySplice)(target, index, 2);
      }
      return index;
    }
    scheduleTimer(ngZone) {
      const callback = () => {
        this.clearTimeout();
        this.executingCallbacks = true;
        const current = [...this.current];
        const now = Date.now();
        for (let i = 0; i < current.length; i += 2) {
          const invokeAt = current[i];
          const callback = current[i + 1];
          if (invokeAt <= now) {
            callback();
          } else {
            break;
          }
        }
        let lastCallbackIndex = -1;
        for (let i = 0; i < this.current.length; i += 2) {
          const invokeAt = this.current[i];
          if (invokeAt <= now) {
            lastCallbackIndex = i + 1;
          } else {
            break;
          }
        }
        if (lastCallbackIndex >= 0) {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.arraySplice)(this.current, 0, lastCallbackIndex + 1);
        }
        this.executingCallbacks = false;
        if (this.deferred.length > 0) {
          for (let i = 0; i < this.deferred.length; i += 2) {
            const invokeAt = this.deferred[i];
            const callback = this.deferred[i + 1];
            this.addToQueue(this.current, invokeAt, callback);
          }
          this.deferred.length = 0;
        }
        this.scheduleTimer(ngZone);
      };
      const FRAME_DURATION_MS = 16;
      if (this.current.length > 0) {
        const now = Date.now();
        const invokeAt = this.current[0];
        if (this.timeoutId === null || this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
          this.clearTimeout();
          const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
          this.invokeTimerAt = invokeAt;
          this.timeoutId = ngZone.runOutsideAngular(() => {
            return setTimeout(() => ngZone.run(callback), timeout);
          });
        }
      }
    }
    clearTimeout() {
      if (this.timeoutId !== null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }
    ngOnDestroy() {
      this.clearTimeout();
      this.current.length = 0;
      this.deferred.length = 0;
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: TimerScheduler,
      providedIn: 'root',
      factory: () => new TimerScheduler()
    });
  }
  return TimerScheduler;
})();
let CachedInjectorService = /*#__PURE__*/(() => {
  class CachedInjectorService {
    cachedInjectors = new Map();
    getOrCreateInjector(key, parentInjector, providers, debugName) {
      if (!this.cachedInjectors.has(key)) {
        const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
        this.cachedInjectors.set(key, injector);
      }
      return this.cachedInjectors.get(key);
    }
    ngOnDestroy() {
      try {
        for (const injector of this.cachedInjectors.values()) {
          if (injector !== null) {
            injector.destroy();
          }
        }
      } finally {
        this.cachedInjectors.clear();
      }
    }
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: CachedInjectorService,
      providedIn: 'environment',
      factory: () => new CachedInjectorService()
    });
  }
  return CachedInjectorService;
})();
const DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = /* @__PURE__ */new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('DEFER_BLOCK_DEPENDENCY_INTERCEPTOR');
const DEFER_BLOCK_CONFIG = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEFER_BLOCK_CONFIG' : '');
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? 'DeferBlock Injector' : '');
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDestroyed)(hostLView)) return;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(lDetails, 'Expected a defer block state defined');
  const currentState = lDetails[DEFER_BLOCK_STATE];
  const ssrState = lDetails[SSR_BLOCK_STATE];
  if (ssrState !== null && newState < ssrState) {
    return;
  }
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && (typeof ngServerMode === 'undefined' || !ngServerMode) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(applyDeferBlockStateWithSchedulingImpl, 'Expected scheduling function to be defined');
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleUncaughtError(hostLView, error);
    }
  }
}
function findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {
  const dehydratedViewIx = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]?.findIndex(view => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE]) ?? -1;
  const dehydratedView = dehydratedViewIx > -1 ? lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS][dehydratedViewIx] : null;
  return {
    dehydratedView,
    dehydratedViewIx
  };
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  profiler(ProfilerEvent.DeferBlockStateStart);
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const adjustedIndex = stateTmplIndex + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
    const activeBlockTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], tDetails, providers);
      }
    }
    const {
      dehydratedView,
      dehydratedViewIx
    } = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      injector,
      dehydratedView
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(embeddedLView, 2);
    if (dehydratedViewIx > -1) {
      lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]?.splice(dehydratedViewIx, 1);
    }
    if ((newState === DeferBlockState.Complete || newState === DeferBlockState.Error) && Array.isArray(lDetails[ON_COMPLETE_FNS])) {
      for (const callback of lDetails[ON_COMPLETE_FNS]) {
        callback();
      }
      lDetails[ON_COMPLETE_FNS] = null;
    }
  }
  profiler(ProfilerEvent.DeferBlockStateEnd);
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tDetails.loadingPromise, 'Expected loading Promise to exist on this defer block');
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
let applyDeferBlockStateWithSchedulingImpl = null;
function ɵɵdeferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
const ASYNC_COMPONENT_METADATA_FN = '__ngAsyncComponentMetadataFn__';
function getAsyncClassMetadataFn(type) {
  const componentClass = type;
  return componentClass[ASYNC_COMPONENT_METADATA_FN] ?? null;
}
function setClassMetadataAsync(type, dependencyLoaderFn, metadataSetterFn) {
  const componentClass = type;
  componentClass[ASYNC_COMPONENT_METADATA_FN] = () => Promise.all(dependencyLoaderFn()).then(dependencies => {
    metadataSetterFn(...dependencies);
    componentClass[ASYNC_COMPONENT_METADATA_FN] = null;
    return dependencies;
  });
  return componentClass[ASYNC_COMPONENT_METADATA_FN];
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {
        clazz.propDecorators = {
          ...clazz.propDecorators,
          ...propDecorators
        };
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
let Console = /*#__PURE__*/(() => {
  class Console {
    log(message) {
      console.log(message);
    }
    warn(message) {
      console.warn(message);
    }
    static ɵfac = function Console_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || Console)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: Console,
      factory: Console.ɵfac,
      providedIn: 'platform'
    });
  }
  return Console;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{
      providedIn: 'platform'
    }]
  }], null, null);
})();
class DIDebugData {
  resolverToTokenToDependencies = /*#__PURE__*/new WeakMap();
  resolverToProviders = /*#__PURE__*/new WeakMap();
  resolverToEffects = /*#__PURE__*/new WeakMap();
  standaloneInjectorToComponent = /*#__PURE__*/new WeakMap();
  reset() {
    this.resolverToTokenToDependencies = new WeakMap();
    this.resolverToProviders = new WeakMap();
    this.standaloneInjectorToComponent = new WeakMap();
  }
}
let frameworkDIDebugData = /*#__PURE__*/new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfiler)(injectorProfilerEventHandler);
}
function injectorProfilerEventHandler(injectorProfilerEvent) {
  const {
    context,
    type
  } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);
  } else if (type === 3) {
    handleEffectCreatedEvent(context, injectorProfilerEvent.effect);
  } else if (type === 4) {
    handleEffectCreatedEvent(context, injectorProfilerEvent.effectPhase);
  }
}
function handleEffectCreatedEvent(context, effect) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('An EffectCreated event must be run within an injection context.');
  }
  const {
    resolverToEffects
  } = frameworkDIDebugData;
  const cleanupContainer = effect instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EffectRefImpl ? effect[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL] : effect.sequence;
  let trackedEffects = resolverToEffects.get(diResolver);
  if (!trackedEffects) {
    trackedEffects = [];
    resolverToEffects.set(diResolver, trackedEffects);
  }
  trackedEffects.push(effect);
  cleanupContainer.onDestroyFns ??= [];
  cleanupContainer.onDestroyFns.push(() => {
    const index = trackedEffects.indexOf(effect);
    if (index > -1) {
      trackedEffects.splice(index, 1);
    }
  });
}
function handleInjectEvent(context, data) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('An Inject event must be run within an injection context.');
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, new WeakMap());
  }
  if (!canBeHeldWeakly(context.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context.token)) {
    instantiatedTokenToDependencies.set(context.token, []);
  }
  const {
    token,
    value,
    flags
  } = data;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(context.token, 'Injector profiler context token is undefined.');
  const dependencies = instantiatedTokenToDependencies.get(context.token);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(dependencies, 'Could not resolve dependencies for token.');
  if (context.injector instanceof NodeInjector) {
    dependencies.push({
      token,
      value,
      flags,
      injectedIn: getNodeInjectorContext(context.injector)
    });
  } else {
    dependencies.push({
      token,
      value,
      flags
    });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getNodeInjectorContext must be called with a NodeInjector');
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
  return {
    lView,
    tNode
  };
}
function handleInstanceCreatedByInjectorEvent(context, data) {
  const {
    value
  } = data;
  if (data.value == null) {
    return;
  }
  if (getDIResolver(context.injector) === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('An InjectorCreatedInstance event must be run within an injection context.');
  }
  let standaloneComponent = undefined;
  if (typeof value === 'object') {
    standaloneComponent = value?.constructor;
  }
  if (standaloneComponent == undefined || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context.injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector, null, {
    optional: true
  });
  if (environmentInjector === null) {
    return;
  }
  const {
    standaloneInjectorToComponent
  } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(value);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context, data) {
  const {
    resolverToProviders
  } = frameworkDIDebugData;
  let diResolver;
  if (context?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context.injector);
  } else {
    diResolver = context.injector;
  }
  if (diResolver === null) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('A ProviderConfigured event must be run within an injection context.');
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === undefined) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === 'object' || typeof value === 'function' || typeof value === 'symbol');
}
function isSignal(value) {
  return typeof value === 'function' && value[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL] !== undefined;
}
function isWritableSignal(value) {
  return isSignal(value) && typeof value.set === 'function';
}
function applyChanges(component) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(component, 'component');
  markViewDirty(getComponentViewByInstance(component), 3);
  getRootComponents(component).forEach(rootComponent => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDeferBlocks$1(lView, deferBlocks) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(lView[i])) {
      const lContainer = lView[i];
      const isLast = i === tView.bindingStartIndex - 1;
      if (!isLast) {
        const tNode = tView.data[i];
        const tDetails = getTDeferBlockDetails(tView, tNode);
        if (isTDeferBlockDetails(tDetails)) {
          deferBlocks.push({
            lContainer,
            lView,
            tNode,
            tDetails
          });
          continue;
        }
      }
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST])) {
        getDeferBlocks$1(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST], deferBlocks);
      }
      for (let j = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; j < lContainer.length; j++) {
        getDeferBlocks$1(lContainer[j], deferBlocks);
      }
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(lView[i])) {
      getDeferBlocks$1(lView[i], deferBlocks);
    }
  }
}
function getDeferBlocks(node) {
  const results = [];
  const lView = getLContext(node)?.lView;
  if (lView) {
    findDeferBlocks(node, lView, results);
  }
  return results;
}
function findDeferBlocks(node, lView, results) {
  const viewInjector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const registry = viewInjector.get(DEHYDRATED_BLOCK_REGISTRY, null, {
    optional: true
  });
  const blocks = [];
  getDeferBlocks$1(lView, blocks);
  const transferState = viewInjector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  for (const details of blocks) {
    const native = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(details.tNode, details.lView);
    const lDetails = getLDeferBlockDetails(details.lView, details.tNode);
    if (!node.contains(native)) {
      continue;
    }
    const tDetails = details.tDetails;
    const renderedLView = getRendererLView(details);
    const rootNodes = [];
    const hydrationState = inferHydrationState(tDetails, lDetails, registry);
    if (renderedLView !== null) {
      collectNativeNodes(renderedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], renderedLView, renderedLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild, rootNodes);
    } else if (hydrationState === 'dehydrated') {
      const deferId = lDetails[SSR_UNIQUE_ID];
      const deferData = deferBlockParents[deferId];
      const numberOfRootNodes = deferData[NUM_ROOT_NODES];
      let collectedNodeCount = 0;
      const deferBlockCommentNode = details.lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE];
      let currentNode = deferBlockCommentNode.previousSibling;
      while (collectedNodeCount < numberOfRootNodes && currentNode) {
        rootNodes.unshift(currentNode);
        currentNode = currentNode.previousSibling;
        collectedNodeCount++;
      }
    }
    const data = {
      state: stringifyState(lDetails[DEFER_BLOCK_STATE]),
      incrementalHydrationState: hydrationState,
      hasErrorBlock: tDetails.errorTmplIndex !== null,
      loadingBlock: {
        exists: tDetails.loadingTmplIndex !== null,
        minimumTime: tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null,
        afterTime: tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null
      },
      placeholderBlock: {
        exists: tDetails.placeholderTmplIndex !== null,
        minimumTime: tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null
      },
      triggers: tDetails.debug?.triggers ? Array.from(tDetails.debug.triggers).sort() : [],
      rootNodes
    };
    results.push(data);
    if (renderedLView !== null) {
      findDeferBlocks(node, renderedLView, results);
    }
  }
}
function stringifyState(state) {
  switch (state) {
    case DeferBlockState.Complete:
      return 'complete';
    case DeferBlockState.Loading:
      return 'loading';
    case DeferBlockState.Placeholder:
      return 'placeholder';
    case DeferBlockState.Error:
      return 'error';
    case DeferBlockInternalState.Initial:
      return 'initial';
    default:
      throw new Error(`Unrecognized state ${state}`);
  }
}
function inferHydrationState(tDetails, lDetails, registry) {
  if (registry === null || lDetails[SSR_UNIQUE_ID] === null || tDetails.hydrateTriggers === null || tDetails.hydrateTriggers.has(7)) {
    return 'not-configured';
  }
  return registry.has(lDetails[SSR_UNIQUE_ID]) ? 'dehydrated' : 'hydrated';
}
function getRendererLView(details) {
  if (details.lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) {
    return null;
  }
  const lView = details.lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  return lView;
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, {
    self: true,
    optional: true
  });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map(dep => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector) {
        break;
      }
      const instance = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, {
            ...formattedDependency.flags,
            optional: true
          });
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token) formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return {
    instance,
    dependencies
  };
}
function getDependenciesForTokenInInjector(token, injector) {
  const {
    resolverToTokenToDependencies
  } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter(dependency => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === undefined) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(dependencyNode);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const {
    standaloneInjectorToComponent
  } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, {
    self: true,
    optional: true
  });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const {
    resolverToProviders
  } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = new Map();
  const visitedContainers = new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.walkProviderTree)(providerImportsContainer, visitor, [], new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getInjectorDef)(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getInjectorDef)(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.deepForEach)(containerDef.imports, moduleImport => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT_INITIALIZER || token === _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(providerImportsContainer);
    const isStandaloneComponent = !!def?.standalone;
    if (isStandaloneComponent) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push({
      ...providerRecord,
      importPath
    });
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector && injector.scopes.has('platform');
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getInjectorProviders only supports NodeInjector and EnvironmentInjector');
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
    return {
      type: 'element',
      source: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView)
    };
  }
  if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector) {
    return {
      type: 'environment',
      source: injector.source ?? null
    };
  }
  if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NullInjector) {
    return {
      type: 'null',
      source: null
    };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('NodeInjector must have some connection to the module injector tree');
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector) {
    return injector.parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector');
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const parentTNode = parentTView.data[parentInjectorIndex + 8];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getModuleInjectorOfNodeInjector must be called with a NodeInjector');
  }
  const inj = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('NodeInjector must have some connection to the module injector tree');
  }
  return moduleInjector;
}
function isComputedNode(node) {
  return node.kind === 'computed';
}
function isTemplateEffectNode(node) {
  return node.kind === 'template';
}
function isSignalNode(node) {
  return node.kind === 'signal';
}
function getTemplateConsumer(injector) {
  const tNode = getNodeInjectorTNode(injector);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(tNode);
  const lView = getNodeInjectorLView(injector);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(lView);
  const templateLView = lView[tNode.index];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(templateLView)) {
    return templateLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.REACTIVE_TEMPLATE_CONSUMER] ?? null;
  }
  return null;
}
const signalDebugMap = /*#__PURE__*/new WeakMap();
let counter$1 = 0;
function getNodesAndEdgesFromSignalMap(signalMap) {
  const nodes = Array.from(signalMap.keys());
  const debugSignalGraphNodes = [];
  const edges = [];
  for (const [consumer, producers] of signalMap.entries()) {
    const consumerIndex = nodes.indexOf(consumer);
    let id = signalDebugMap.get(consumer);
    if (!id) {
      counter$1++;
      id = counter$1.toString();
      signalDebugMap.set(consumer, id);
    }
    if (isComputedNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.computation,
        id
      });
    } else if (isSignalNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        id
      });
    } else if (isTemplateEffectNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName ?? consumer.lView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]?.tagName?.toLowerCase?.(),
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.lView?.[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]?.constructor,
        id
      });
    } else {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        kind: consumer.kind,
        epoch: consumer.version,
        id
      });
    }
    for (const producer of producers) {
      edges.push({
        consumer: consumerIndex,
        producer: nodes.indexOf(producer)
      });
    }
  }
  return {
    nodes: debugSignalGraphNodes,
    edges
  };
}
function extractEffectsFromInjector(injector) {
  let diResolver = injector;
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    diResolver = lView;
  }
  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects;
  const effects = resolverToEffects.get(diResolver) ?? [];
  return effects.map(effect => {
    if (effect instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EffectRefImpl) {
      return effect[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
    } else {
      return effect.signal[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
    }
  });
}
function extractSignalNodesAndEdgesFromRoots(nodes, signalDependenciesMap = new Map()) {
  for (const node of nodes) {
    if (signalDependenciesMap.has(node)) {
      continue;
    }
    const producerNodes = [];
    for (let link = node.producers; link !== undefined; link = link.nextProducer) {
      const producer = link.producer;
      producerNodes.push(producer);
    }
    signalDependenciesMap.set(node, producerNodes);
    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);
  }
  return signalDependenciesMap;
}
function getSignalGraph(injector) {
  let templateConsumer = null;
  if (!(injector instanceof NodeInjector) && !(injector instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.R3Injector)) {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('getSignalGraph must be called with a NodeInjector or R3Injector');
  }
  if (injector instanceof NodeInjector) {
    templateConsumer = getTemplateConsumer(injector);
  }
  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);
  const signalNodes = templateConsumer ? [templateConsumer, ...nonTemplateEffectNodes] : nonTemplateEffectNodes;
  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);
  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);
}
let changeDetectionRuns = 0;
let changeDetectionSyncRuns = 0;
let counter = 0;
const eventsStack = [];
function measureStart(startEvent) {
  eventsStack.push([startEvent, counter]);
  console.timeStamp('Event_' + startEvent + '_' + counter++);
}
function measureEnd(startEvent, entryName, color) {
  let top;
  do {
    top = eventsStack.pop();
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(top, 'Profiling error: could not find start event entry ' + startEvent);
  } while (top[0] !== startEvent);
  console.timeStamp(entryName, 'Event_' + top[0] + '_' + top[1], undefined, '\u{1F170}\uFE0F Angular', undefined, color);
}
const chromeDevToolsInjectorProfiler = event => {
  const eventType = event.type;
  if (eventType === 5) {
    measureStart(100);
  } else if (eventType === 1) {
    const token = event.context.token;
    measureEnd(100, getProviderTokenMeasureName(token), 'tertiary-dark');
  }
};
const devToolsProfiler = (event, instance, eventFn) => {
  switch (event) {
    case ProfilerEvent.BootstrapApplicationStart:
    case ProfilerEvent.BootstrapComponentStart:
    case ProfilerEvent.ChangeDetectionStart:
    case ProfilerEvent.ChangeDetectionSyncStart:
    case ProfilerEvent.AfterRenderHooksStart:
    case ProfilerEvent.ComponentStart:
    case ProfilerEvent.DeferBlockStateStart:
    case ProfilerEvent.DynamicComponentStart:
    case ProfilerEvent.TemplateCreateStart:
    case ProfilerEvent.LifecycleHookStart:
    case ProfilerEvent.TemplateUpdateStart:
    case ProfilerEvent.HostBindingsUpdateStart:
    case ProfilerEvent.OutputStart:
      {
        measureStart(event);
        break;
      }
    case ProfilerEvent.BootstrapApplicationEnd:
      {
        measureEnd(ProfilerEvent.BootstrapApplicationStart, 'Bootstrap application', 'primary-dark');
        break;
      }
    case ProfilerEvent.BootstrapComponentEnd:
      {
        measureEnd(ProfilerEvent.BootstrapComponentStart, 'Bootstrap component', 'primary-dark');
        break;
      }
    case ProfilerEvent.ChangeDetectionEnd:
      {
        changeDetectionSyncRuns = 0;
        measureEnd(ProfilerEvent.ChangeDetectionStart, 'Change detection ' + changeDetectionRuns++, 'primary-dark');
        break;
      }
    case ProfilerEvent.ChangeDetectionSyncEnd:
      {
        measureEnd(ProfilerEvent.ChangeDetectionSyncStart, 'Synchronization ' + changeDetectionSyncRuns++, 'primary');
        break;
      }
    case ProfilerEvent.AfterRenderHooksEnd:
      {
        measureEnd(ProfilerEvent.AfterRenderHooksStart, 'After render hooks', 'primary');
        break;
      }
    case ProfilerEvent.ComponentEnd:
      {
        const typeName = getComponentMeasureName(instance);
        measureEnd(ProfilerEvent.ComponentStart, typeName, 'primary-light');
        break;
      }
    case ProfilerEvent.DeferBlockStateEnd:
      {
        measureEnd(ProfilerEvent.DeferBlockStateStart, 'Defer block', 'primary-dark');
        break;
      }
    case ProfilerEvent.DynamicComponentEnd:
      {
        measureEnd(ProfilerEvent.DynamicComponentStart, 'Dynamic component creation', 'primary-dark');
        break;
      }
    case ProfilerEvent.TemplateUpdateEnd:
      {
        measureEnd(ProfilerEvent.TemplateUpdateStart, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn) + ' (update)', 'secondary-dark');
        break;
      }
    case ProfilerEvent.TemplateCreateEnd:
      {
        measureEnd(ProfilerEvent.TemplateCreateStart, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn) + ' (create)', 'secondary');
        break;
      }
    case ProfilerEvent.HostBindingsUpdateEnd:
      {
        measureEnd(ProfilerEvent.HostBindingsUpdateStart, 'HostBindings', 'secondary-dark');
        break;
      }
    case ProfilerEvent.LifecycleHookEnd:
      {
        const typeName = getComponentMeasureName(instance);
        measureEnd(ProfilerEvent.LifecycleHookStart, `${typeName}:${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn)}`, 'tertiary');
        break;
      }
    case ProfilerEvent.OutputEnd:
      {
        measureEnd(ProfilerEvent.OutputStart, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(eventFn), 'tertiary-light');
        break;
      }
    default:
      {
        throw new Error('Unexpected profiling event type: ' + event);
      }
  }
};
function getComponentMeasureName(instance) {
  return instance.constructor.name;
}
function getProviderTokenMeasureName(token) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(token)) {
    return token.name;
  } else if (token.provide != null) {
    return getProviderTokenMeasureName(token.provide);
  }
  return token.toString();
}
function enableProfiling() {
  performanceMarkFeature('Chrome DevTools profiling');
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const removeInjectorProfiler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfiler)(chromeDevToolsInjectorProfiler);
    const removeProfiler = setProfiler(devToolsProfiler);
    return () => {
      removeInjectorProfiler();
      removeProfiler();
    };
  }
  return () => {};
}
function getTransferState(injector) {
  const doc = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT);
  const appId = injector.get(APP_ID);
  const transferState = retrieveTransferredState(doc, appId);
  const filteredEntries = {};
  for (const [key, value] of Object.entries(transferState)) {
    if (!isInternalHydrationTransferStateKey(key)) {
      filteredEntries[key] = value;
    }
  }
  return filteredEntries;
}
const GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';
const globalUtilsFunctions = {
  'ɵgetDependenciesFromInjectable': getDependenciesFromInjectable,
  'ɵgetInjectorProviders': getInjectorProviders,
  'ɵgetInjectorResolutionPath': getInjectorResolutionPath,
  'ɵgetInjectorMetadata': getInjectorMetadata,
  'ɵsetProfiler': setProfiler,
  'ɵgetSignalGraph': getSignalGraph,
  'ɵgetDeferBlocks': getDeferBlocks,
  'ɵgetTransferState': getTransferState,
  'getDirectiveMetadata': getDirectiveMetadata$1,
  'getComponent': getComponent,
  'getContext': getContext,
  'getListeners': getListeners,
  'getOwningComponent': getOwningComponent,
  'getHostElement': getHostElement,
  'getInjector': getInjector,
  'getRootComponents': getRootComponents,
  'getDirectives': getDirectives,
  'applyChanges': applyChanges,
  'isSignal': isSignal,
  'enableProfiling': enableProfiling
};
let _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== 'undefined') {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishExternalGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishUtil(name, fn) {
  if (typeof COMPILED === 'undefined' || !COMPILED) {
    const w = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global;
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(fn, 'function not defined');
    w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
const TESTABILITY = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('');
const TESTABILITY_GETTER = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('');
let Testability = /*#__PURE__*/(() => {
  class Testability {
    _ngZone;
    registry;
    _isZoneStable = true;
    _callbacks = [];
    _taskTrackingZone = null;
    _destroyRef;
    constructor(_ngZone, registry, testabilityGetter) {
      this._ngZone = _ngZone;
      this.registry = registry;
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInInjectionContext)()) {
        this._destroyRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef, {
          optional: true
        }) ?? undefined;
      }
      if (!_testabilityGetter) {
        setTestabilityGetter(testabilityGetter);
        testabilityGetter.addToWindow(registry);
      }
      this._watchAngularEvents();
      _ngZone.run(() => {
        this._taskTrackingZone = typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
      });
    }
    _watchAngularEvents() {
      const onUnstableSubscription = this._ngZone.onUnstable.subscribe({
        next: () => {
          this._isZoneStable = false;
        }
      });
      const onStableSubscription = this._ngZone.runOutsideAngular(() => this._ngZone.onStable.subscribe({
        next: () => {
          _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone.assertNotInAngularZone();
          queueMicrotask(() => {
            this._isZoneStable = true;
            this._runCallbacksIfReady();
          });
        }
      }));
      this._destroyRef?.onDestroy(() => {
        onUnstableSubscription.unsubscribe();
        onStableSubscription.unsubscribe();
      });
    }
    isStable() {
      return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
    }
    _runCallbacksIfReady() {
      if (this.isStable()) {
        queueMicrotask(() => {
          while (this._callbacks.length !== 0) {
            let cb = this._callbacks.pop();
            clearTimeout(cb.timeoutId);
            cb.doneCb();
          }
        });
      } else {
        let pending = this.getPendingTasks();
        this._callbacks = this._callbacks.filter(cb => {
          if (cb.updateCb && cb.updateCb(pending)) {
            clearTimeout(cb.timeoutId);
            return false;
          }
          return true;
        });
      }
    }
    getPendingTasks() {
      if (!this._taskTrackingZone) {
        return [];
      }
      return this._taskTrackingZone.macroTasks.map(t => {
        return {
          source: t.source,
          creationLocation: t.creationLocation,
          data: t.data
        };
      });
    }
    addCallback(cb, timeout, updateCb) {
      let timeoutId = -1;
      if (timeout && timeout > 0) {
        timeoutId = setTimeout(() => {
          this._callbacks = this._callbacks.filter(cb => cb.timeoutId !== timeoutId);
          cb();
        }, timeout);
      }
      this._callbacks.push({
        doneCb: cb,
        timeoutId: timeoutId,
        updateCb: updateCb
      });
    }
    whenStable(doneCb, timeout, updateCb) {
      if (updateCb && !this._taskTrackingZone) {
        throw new Error('Task tracking zone is required when passing an update callback to ' + 'whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
      }
      this.addCallback(doneCb, timeout, updateCb);
      this._runCallbacksIfReady();
    }
    registerApplication(token) {
      this.registry.registerApplication(token, this);
    }
    unregisterApplication(token) {
      this.registry.unregisterApplication(token);
    }
    findProviders(using, provider, exactMatch) {
      return [];
    }
    static ɵfac = function Testability_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || Testability)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(TestabilityRegistry), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(TESTABILITY_GETTER));
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: Testability,
      factory: Testability.ɵfac
    });
  }
  return Testability;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{
    type: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone
  }, {
    type: TestabilityRegistry
  }, {
    type: undefined,
    decorators: [{
      type: Inject,
      args: [TESTABILITY_GETTER]
    }]
  }], null);
})();
let TestabilityRegistry = /*#__PURE__*/(() => {
  class TestabilityRegistry {
    _applications = new Map();
    registerApplication(token, testability) {
      this._applications.set(token, testability);
    }
    unregisterApplication(token) {
      this._applications.delete(token);
    }
    unregisterAllApplications() {
      this._applications.clear();
    }
    getTestability(elem) {
      return this._applications.get(elem) || null;
    }
    getAllTestabilities() {
      return Array.from(this._applications.values());
    }
    getAllRootElements() {
      return Array.from(this._applications.keys());
    }
    findTestabilityInTree(elem, findInAncestors = true) {
      return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
    }
    static ɵfac = function TestabilityRegistry_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || TestabilityRegistry)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: TestabilityRegistry,
      factory: TestabilityRegistry.ɵfac,
      providedIn: 'platform'
    });
  }
  return TestabilityRegistry;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{
      providedIn: 'platform'
    }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
let _testabilityGetter;
function isPromise(obj) {
  return !!obj && typeof obj.then === 'function';
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === 'function';
}
const APP_INITIALIZER = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(ngDevMode ? 'Application Initializer' : '');
function provideAppInitializer(initializerFn) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([{
    provide: APP_INITIALIZER,
    multi: true,
    useValue: initializerFn
  }]);
}
let ApplicationInitStatus = /*#__PURE__*/(() => {
  class ApplicationInitStatus {
    resolve;
    reject;
    initialized = false;
    done = false;
    donePromise = new Promise((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
    appInits = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(APP_INITIALIZER, {
      optional: true
    }) ?? [];
    injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector);
    constructor() {
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && !Array.isArray(this.appInits)) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-209, 'Unexpected type of the `APP_INITIALIZER` token value ' + `(expected an array, but got ${typeof this.appInits}). ` + 'Please check that the `APP_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
      }
    }
    runInitializers() {
      if (this.initialized) {
        return;
      }
      const asyncInitPromises = [];
      for (const appInits of this.appInits) {
        const initResult = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.runInInjectionContext)(this.injector, appInits);
        if (isPromise(initResult)) {
          asyncInitPromises.push(initResult);
        } else if (isSubscribable(initResult)) {
          const observableAsPromise = new Promise((resolve, reject) => {
            initResult.subscribe({
              complete: resolve,
              error: reject
            });
          });
          asyncInitPromises.push(observableAsPromise);
        }
      }
      const complete = () => {
        this.done = true;
        this.resolve();
      };
      Promise.all(asyncInitPromises).then(() => {
        complete();
      }).catch(e => {
        this.reject(e);
      });
      if (asyncInitPromises.length === 0) {
        complete();
      }
      this.initialized = true;
    }
    static ɵfac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ApplicationInitStatus)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: ApplicationInitStatus,
      factory: ApplicationInitStatus.ɵfac,
      providedIn: 'root'
    });
  }
  return ApplicationInitStatus;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
const APP_BOOTSTRAP_LISTENER = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(ngDevMode ? 'appBootstrapListener' : '');
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setThrowInvalidWriteToSignalError)(() => {
    let errorMessage = '';
    if (ngDevMode) {
      const activeConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getActiveConsumer)();
      errorMessage = activeConsumer && isReactiveLViewConsumer(activeConsumer) ? 'Writing to signals is not allowed while Angular renders the template (eg. interpolations)' : 'Writing to signals is not allowed in a `computed`';
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(600, errorMessage);
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
const MAXIMUM_REFRESH_RERUNS = 10;
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return {
    ...dst,
    ...objs
  };
}
let ApplicationRef = /*#__PURE__*/(() => {
  class ApplicationRef {
    _runningTick = false;
    _destroyed = false;
    _destroyListeners = [];
    _views = [];
    internalErrorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER);
    afterRenderManager = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(AfterRenderManager);
    zonelessEnabled = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ZONELESS_ENABLED);
    rootEffectScheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EffectScheduler);
    dirtyFlags = 0;
    tracingSnapshot = null;
    allTestViews = new Set();
    autoDetectTestViews = new Set();
    includeAllTestViews = false;
    afterTick = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
    get allViews() {
      return [...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(), ...this._views];
    }
    get destroyed() {
      return this._destroyed;
    }
    componentTypes = [];
    components = [];
    internalPendingTask = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
    get isStable() {
      return this.internalPendingTask.hasPendingTasksObservable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.map)(pending => !pending));
    }
    constructor() {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(TracingService, {
        optional: true
      });
    }
    whenStable() {
      let subscription;
      return new Promise(resolve => {
        subscription = this.isStable.subscribe({
          next: stable => {
            if (stable) {
              resolve();
            }
          }
        });
      }).finally(() => {
        subscription.unsubscribe();
      });
    }
    _injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EnvironmentInjector);
    _rendererFactory = null;
    get injector() {
      return this._injector;
    }
    bootstrap(componentOrFactory, rootSelectorOrNode) {
      return this.bootstrapImpl(componentOrFactory, rootSelectorOrNode);
    }
    bootstrapImpl(componentOrFactory, rootSelectorOrNode, injector = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector.NULL) {
      const ngZone = this._injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
      return ngZone.run(() => {
        profiler(ProfilerEvent.BootstrapComponentStart);
        (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
        const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
        const initStatus = this._injector.get(ApplicationInitStatus);
        if (!initStatus.done) {
          let errorMessage = '';
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
            const standalone = !isComponentFactory && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(componentOrFactory);
            errorMessage = 'Cannot bootstrap as there are still asynchronous initializers running.' + (standalone ? '' : ' Bootstrap components in the `ngDoBootstrap` method of the root module.');
          }
          throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(405, errorMessage);
        }
        let componentFactory;
        if (isComponentFactory) {
          componentFactory = componentOrFactory;
        } else {
          const resolver = this._injector.get(ComponentFactoryResolver$1);
          componentFactory = resolver.resolveComponentFactory(componentOrFactory);
        }
        this.componentTypes.push(componentFactory.componentType);
        const ngModule = isBoundToModule(componentFactory) ? undefined : this._injector.get(NgModuleRef$1);
        const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
        const compRef = componentFactory.create(injector, [], selectorOrNode, ngModule);
        const nativeElement = compRef.location.nativeElement;
        const testability = compRef.injector.get(TESTABILITY, null);
        testability?.registerApplication(nativeElement);
        compRef.onDestroy(() => {
          this.detachView(compRef.hostView);
          remove(this.components, compRef);
          testability?.unregisterApplication(nativeElement);
        });
        this._loadComponent(compRef);
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          const _console = this._injector.get(Console);
          _console.log(`Angular is running in development mode.`);
        }
        profiler(ProfilerEvent.BootstrapComponentEnd, compRef);
        return compRef;
      });
    }
    tick() {
      if (!this.zonelessEnabled) {
        this.dirtyFlags |= 1;
      }
      this._tick();
    }
    _tick() {
      profiler(ProfilerEvent.ChangeDetectionStart);
      if (this.tracingSnapshot !== null) {
        this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);
      } else {
        this.tickImpl();
      }
    }
    tickImpl = () => {
      (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
      if (this._runningTick) {
        profiler(ProfilerEvent.ChangeDetectionEnd);
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(101, ngDevMode && 'ApplicationRef.tick is called recursively');
      }
      const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
      try {
        this._runningTick = true;
        this.synchronize();
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          for (let view of this.allViews) {
            view.checkNoChanges();
          }
        }
      } finally {
        this._runningTick = false;
        this.tracingSnapshot?.dispose();
        this.tracingSnapshot = null;
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
        this.afterTick.next();
        profiler(ProfilerEvent.ChangeDetectionEnd);
      }
    };
    synchronize() {
      if (this._rendererFactory === null && !this._injector.destroyed) {
        this._rendererFactory = this._injector.get(RendererFactory2, null, {
          optional: true
        });
      }
      let runs = 0;
      while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {
        profiler(ProfilerEvent.ChangeDetectionSyncStart);
        try {
          this.synchronizeOnce();
        } finally {
          profiler(ProfilerEvent.ChangeDetectionSyncEnd);
        }
      }
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(103, ngDevMode && 'Infinite change detection while refreshing application views. ' + 'Ensure views are not calling `markForCheck` on every template execution or ' + 'that afterRender hooks always mark views for check.');
      }
    }
    synchronizeOnce() {
      if (this.dirtyFlags & 16) {
        this.dirtyFlags &= ~16;
        this.rootEffectScheduler.flush();
      }
      let ranDetectChanges = false;
      if (this.dirtyFlags & 7) {
        const useGlobalCheck = Boolean(this.dirtyFlags & 1);
        this.dirtyFlags &= ~7;
        this.dirtyFlags |= 8;
        for (let {
          _lView
        } of this.allViews) {
          if (!useGlobalCheck && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(_lView)) {
            continue;
          }
          const mode = useGlobalCheck && !this.zonelessEnabled ? 0 : 1;
          detectChangesInternal(_lView, mode);
          ranDetectChanges = true;
        }
        this.dirtyFlags &= ~4;
        this.syncDirtyFlagsWithViews();
        if (this.dirtyFlags & (7 | 16)) {
          return;
        }
      }
      if (!ranDetectChanges) {
        this._rendererFactory?.begin?.();
        this._rendererFactory?.end?.();
      }
      if (this.dirtyFlags & 8) {
        this.dirtyFlags &= ~8;
        this.afterRenderManager.execute();
      }
      this.syncDirtyFlagsWithViews();
    }
    syncDirtyFlagsWithViews() {
      if (this.allViews.some(({
        _lView
      }) => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.requiresRefreshOrTraversal)(_lView))) {
        this.dirtyFlags |= 2;
        return;
      } else {
        this.dirtyFlags &= ~7;
      }
    }
    attachView(viewRef) {
      (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
      const view = viewRef;
      this._views.push(view);
      view.attachToAppRef(this);
    }
    detachView(viewRef) {
      (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
      const view = viewRef;
      remove(this._views, view);
      view.detachFromAppRef();
    }
    _loadComponent(componentRef) {
      this.attachView(componentRef.hostView);
      try {
        this.tick();
      } catch (e) {
        this.internalErrorHandler(e);
      }
      this.components.push(componentRef);
      const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
      if (ngDevMode && !Array.isArray(listeners)) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-209, 'Unexpected type of the `APP_BOOTSTRAP_LISTENER` token value ' + `(expected an array, but got ${typeof listeners}). ` + 'Please check that the `APP_BOOTSTRAP_LISTENER` token is configured as a ' + '`multi: true` provider.');
      }
      listeners.forEach(listener => listener(componentRef));
    }
    ngOnDestroy() {
      if (this._destroyed) return;
      try {
        this._destroyListeners.forEach(listener => listener());
        this._views.slice().forEach(view => view.destroy());
      } finally {
        this._destroyed = true;
        this._views = [];
        this._destroyListeners = [];
      }
    }
    onDestroy(callback) {
      (typeof ngDevMode === 'undefined' || ngDevMode) && warnIfDestroyed(this._destroyed);
      this._destroyListeners.push(callback);
      return () => remove(this._destroyListeners, callback);
    }
    destroy() {
      if (this._destroyed) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(406, ngDevMode && 'This instance of the `ApplicationRef` has already been destroyed.');
      }
      const injector = this._injector;
      if (injector.destroy && !injector.destroyed) {
        injector.destroy();
      }
    }
    get viewCount() {
      return this._views.length;
    }
    static ɵfac = function ApplicationRef_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ApplicationRef)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: ApplicationRef,
      factory: ApplicationRef.ɵfac,
      providedIn: 'root'
    });
  }
  return ApplicationRef;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function warnIfDestroyed(destroyed) {
  if (destroyed) {
    console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(406, 'This instance of the `ApplicationRef` has already been destroyed.'));
  }
}
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  renderPlaceholder(lView, tNode);
  if (!shouldTriggerDeferBlock(0, lView)) return;
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const cleanupFn = scheduleFn(() => triggerDeferBlock(0, lView, tNode), injector);
  storeTriggerCleanupFn(0, lDetails, cleanupFn);
}
function scheduleDelayedPrefetching(scheduleFn) {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) return;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
    const cleanupFn = scheduleFn(prefetch, injector);
    storeTriggerCleanupFn(1, lDetails, cleanupFn);
  }
}
function scheduleDelayedHydrating(scheduleFn, lView, tNode) {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) return;
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
  ngDevMode && assertSsrIdDefined(ssrUniqueId);
  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);
  storeTriggerCleanupFn(2, lDetails, cleanupFn);
}
function triggerPrefetching(tDetails, lView, tNode) {
  triggerResourceLoading(tDetails, lView, tNode);
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const removeTask = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasks).add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      removeTask();
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then(results => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === 'fulfilled') {
        const dependency = result.value;
        const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(dependency) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : '';
        const error = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-750, ngDevMode && 'Loading dependencies for `@defer` block failed, ' + `but no \`@error\` block was configured${templateLocation}. ` + 'Consider using the `@error` block to render an error state.');
        handleUncaughtError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map(def => def.type);
        const providers = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.internalImportProvidersFrom)(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise.finally(() => {
    tDetails.loadingPromise = null;
    removeTask();
  });
}
function shouldTriggerDeferBlock(triggerType, lView) {
  if (triggerType === 0 && typeof ngServerMode !== 'undefined' && ngServerMode) {
    return false;
  }
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const config = injector.get(DEFER_BLOCK_CONFIG, null, {
    optional: true
  });
  if (config?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return true;
}
function triggerDeferBlock(triggerType, lView, tNode) {
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const lContainer = lView[tNode.index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  if (!shouldTriggerDeferBlock(triggerType, lView)) return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Unknown defer block state');
      }
  }
}
function triggerHydrationFromBlockName(_x4, _x5, _x6) {
  return _triggerHydrationFromBlockName.apply(this, arguments);
}
function _triggerHydrationFromBlockName() {
  _triggerHydrationFromBlockName = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (injector, blockName, replayQueuedEventsFn) {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    if (blocksBeingHydrated.has(blockName)) {
      return;
    }
    const {
      parentBlockPromise,
      hydrationQueue
    } = getParentBlockHydrationQueue(blockName, injector);
    if (hydrationQueue.length === 0) return;
    if (parentBlockPromise !== null) {
      hydrationQueue.shift();
    }
    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);
    if (parentBlockPromise !== null) {
      yield parentBlockPromise;
    }
    const topmostParentBlock = hydrationQueue[0];
    if (dehydratedBlockRegistry.has(topmostParentBlock)) {
      yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
    } else {
      dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock, /*#__PURE__*/(0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        return yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
      }));
    }
  });
  return _triggerHydrationFromBlockName.apply(this, arguments);
}
function triggerHydrationForBlockQueue(_x7, _x8, _x9) {
  return _triggerHydrationForBlockQueue.apply(this, arguments);
}
function _triggerHydrationForBlockQueue() {
  _triggerHydrationForBlockQueue = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (injector, hydrationQueue, replayQueuedEventsFn) {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    const pendingTasks = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
    const taskId = pendingTasks.add();
    for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {
      const dehydratedBlockId = hydrationQueue[blockQueueIdx];
      const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);
      if (dehydratedDeferBlock != null) {
        yield triggerResourceLoadingForHydration(dehydratedDeferBlock);
        yield nextRender(injector);
        if (deferBlockHasErrored(dehydratedDeferBlock)) {
          removeDehydratedViewList(dehydratedDeferBlock);
          cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
          break;
        }
        blocksBeingHydrated.get(dehydratedBlockId).resolve();
      } else {
        cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);
        cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
        break;
      }
    }
    const lastBlockName = hydrationQueue[hydrationQueue.length - 1];
    yield blocksBeingHydrated.get(lastBlockName)?.promise;
    pendingTasks.remove(taskId);
    if (replayQueuedEventsFn) {
      replayQueuedEventsFn(hydrationQueue);
    }
    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));
  });
  return _triggerHydrationForBlockQueue.apply(this, arguments);
}
function deferBlockHasErrored(deferBlock) {
  return getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] === DeferBlockState.Error;
}
function cleanupParentContainer(currentBlockIdx, hydrationQueue, dehydratedBlockRegistry) {
  const parentDeferBlockIdx = currentBlockIdx - 1;
  const parentDeferBlock = parentDeferBlockIdx > -1 ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]) : null;
  if (parentDeferBlock) {
    cleanupLContainer(parentDeferBlock.lContainer);
  }
}
function cleanupRemainingHydrationQueue(hydrationQueue, dehydratedBlockRegistry) {
  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
  for (const dehydratedBlockId in hydrationQueue) {
    blocksBeingHydrated.get(dehydratedBlockId)?.reject();
  }
  dehydratedBlockRegistry.cleanup(hydrationQueue);
}
function populateHydratingStateForQueue(registry, queue) {
  for (let blockId of queue) {
    registry.hydrating.set(blockId, promiseWithResolvers());
  }
}
function nextRender(injector) {
  return new Promise(resolveFn => afterNextRender(resolveFn, {
    injector
  }));
}
function triggerResourceLoadingForHydration(_x0) {
  return _triggerResourceLoadingForHydration.apply(this, arguments);
}
function _triggerResourceLoadingForHydration() {
  _triggerResourceLoadingForHydration = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (dehydratedBlock) {
    const {
      tNode,
      lView
    } = dehydratedBlock;
    const lDetails = getLDeferBlockDetails(lView, tNode);
    return new Promise(resolve => {
      onDeferBlockCompletion(lDetails, resolve);
      triggerDeferBlock(2, lView, tNode);
    });
  });
  return _triggerResourceLoadingForHydration.apply(this, arguments);
}
function onDeferBlockCompletion(lDetails, callback) {
  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {
    lDetails[ON_COMPLETE_FNS] = [];
  }
  lDetails[ON_COMPLETE_FNS].push(callback);
}
function shouldAttachTrigger(triggerType, lView, tNode) {
  if (triggerType === 0) {
    return shouldAttachRegularTrigger(lView, tNode);
  } else if (triggerType === 2) {
    return !shouldAttachRegularTrigger(lView, tNode);
  }
  return !(typeof ngServerMode !== 'undefined' && ngServerMode);
}
function hasHydrateTriggers(flags) {
  return flags != null && (flags & 1) === 1;
}
function shouldAttachRegularTrigger(lView, tNode) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const tDetails = getTDeferBlockDetails(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode);
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  const _hasHydrateTriggers = hasHydrateTriggers(tDetails.flags);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return !incrementalHydrationEnabled || !_hasHydrateTriggers;
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;
  if (_hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {
    return false;
  }
  return true;
}
function getHydrateTriggers(tView, tNode) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  return tDetails.hydrateTriggers ??= new Map();
}
function processAndInitTriggers(injector, blockData, nodes) {
  const idleElements = [];
  const timerElements = [];
  const viewportElements = [];
  const immediateElements = [];
  for (let [blockId, blockSummary] of blockData) {
    const commentNode = nodes.get(blockId);
    if (commentNode !== undefined) {
      const numRootNodes = blockSummary.data[NUM_ROOT_NODES];
      let currentNode = commentNode;
      for (let i = 0; i < numRootNodes; i++) {
        currentNode = currentNode.previousSibling;
        if (currentNode.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        const elementTrigger = {
          el: currentNode,
          blockName: blockId
        };
        if (blockSummary.hydrate.idle) {
          idleElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.immediate) {
          immediateElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.timer !== null) {
          elementTrigger.delay = blockSummary.hydrate.timer;
          timerElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.viewport) {
          if (typeof blockSummary.hydrate.viewport !== 'boolean') {
            elementTrigger.intersectionObserverOptions = blockSummary.hydrate.viewport;
          }
          viewportElements.push(elementTrigger);
        }
      }
    }
  }
  setIdleTriggers(injector, idleElements);
  setImmediateTriggers(injector, immediateElements);
  setViewportTriggers(injector, viewportElements);
  setTimerTriggers(injector, timerElements);
}
function setIdleTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);
    const cleanupFn = onIdle(onInvoke, injector);
    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
  }
}
function setViewportTriggers(injector, elementTriggers) {
  if (elementTriggers.length > 0) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    for (let elementTrigger of elementTriggers) {
      const cleanupFn = onViewportWrapper(elementTrigger.el, () => triggerHydrationFromBlockName(injector, elementTrigger.blockName), injector, elementTrigger.intersectionObserverOptions);
      registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
    }
  }
}
function setTimerTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);
    const timerFn = onTimer(elementTrigger.delay);
    const cleanupFn = timerFn(onInvoke, injector);
    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
  }
}
function setImmediateTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    triggerHydrationFromBlockName(injector, elementTrigger.blockName);
  }
}
let _hmrWarningProduced = false;
function logHmrWarning(injector) {
  if (!_hmrWarningProduced) {
    _hmrWarningProduced = true;
    const console = injector.get(Console);
    console.log((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-751, 'Angular has detected that this application contains `@defer` blocks ' + 'and the hot module replacement (HMR) mode is enabled. All `@defer` ' + 'block dependencies will be loaded eagerly.'));
  }
}
function ɵɵdefer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling, flags) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = declareNoDirectiveHostTemplate(lView, tView, index, null, 0, 0);
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  if (tView.firstCreatePass) {
    performanceMarkFeature('NgDefer');
    if (ngDevMode) {
      if (typeof ngHmrMode !== 'undefined' && ngHmrMode) {
        logHmrWarning(injector);
      }
      if (hasHydrateTriggers(flags) && !incrementalHydrationEnabled) {
        warnIncrementalHydrationNotConfigured();
      }
    }
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null,
      hydrateTriggers: null,
      debug: null,
      flags: flags ?? 0
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  let ssrBlockState = null;
  let ssrUniqueId = null;
  if (lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS]?.length > 0) {
    const info = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DEHYDRATED_VIEWS][0].data;
    ssrUniqueId = info[DEFER_BLOCK_ID] ?? null;
    ssrBlockState = info[DEFER_BLOCK_STATE$1];
  }
  const lDetails = [null, DeferBlockInternalState.Initial, null, null, null, null, ssrUniqueId, ssrBlockState, null, null];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  let registry = null;
  if (ssrUniqueId !== null && incrementalHydrationEnabled) {
    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    registry.add(ssrUniqueId, {
      lView,
      tNode,
      lContainer
    });
  }
  const onLViewDestroy = () => {
    invokeAllTriggerCleanupFns(lDetails);
    if (ssrUniqueId !== null) {
      registry?.cleanup([ssrUniqueId]);
    }
  };
  storeTriggerCleanupFn(0, lDetails, () => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.removeLViewOnDestroy)(lView, onLViewDestroy));
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeLViewOnDestroy)(lView, onLViewDestroy);
}
function ɵɵdeferWhen(rawValue) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'when <expression>');
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const value = Boolean(rawValue);
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(0, lView, tNode);
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function ɵɵdeferPrefetchWhen(rawValue) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'prefetch when <expression>');
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
      const tDetails = getTDeferBlockDetails(tView, tNode);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode);
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  }
}
function ɵɵdeferHydrateWhen(rawValue) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate when <expression>');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const hydrateTriggers = getHydrateTriggers(tView, tNode);
  hydrateTriggers.set(6, null);
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      triggerDeferBlock(2, lView, tNode);
    } else {
      const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
      const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
      try {
        const value = Boolean(rawValue);
        if (value === true) {
          const lDetails = getLDeferBlockDetails(lView, tNode);
          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
          ngDevMode && assertSsrIdDefined(ssrUniqueId);
          triggerHydrationFromBlockName(injector, ssrUniqueId);
        }
      } finally {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
      }
    }
  }
}
function ɵɵdeferHydrateNever() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate never');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(7, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵdeferOnIdle() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'on idle');
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  scheduleDelayedTrigger(onIdle);
}
function ɵɵdeferPrefetchOnIdle() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'prefetch on idle');
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  scheduleDelayedPrefetching(onIdle);
}
function ɵɵdeferHydrateOnIdle() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on idle');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(0, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onIdle, lView, tNode);
  }
}
function ɵɵdeferOnImmediate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'on immediate');
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  const tDetails = getTDeferBlockDetails(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode);
  if (tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(0, lView, tNode);
}
function ɵɵdeferPrefetchOnImmediate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'prefetch on immediate');
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function ɵɵdeferHydrateOnImmediate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on immediate');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(1, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
    ngDevMode && assertSsrIdDefined(ssrUniqueId);
    triggerHydrationFromBlockName(injector, ssrUniqueId);
  }
}
function ɵɵdeferOnTimer(delay) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  scheduleDelayedTrigger(onTimer(delay));
}
function ɵɵdeferPrefetchOnTimer(delay) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  scheduleDelayedPrefetching(onTimer(delay));
}
function ɵɵdeferHydrateOnTimer(delay) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `hydrate on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(5, {
    type: 5,
    delay
  });
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onTimer(delay), lView, tNode);
  }
}
function ɵɵdeferOnHover(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on hover${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== 'undefined' && ngServerMode)) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onHover, () => triggerDeferBlock(0, lView, tNode), 0);
  }
}
function ɵɵdeferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on hover${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onHover, () => triggerPrefetching(tDetails, lView, tNode), 1);
  }
}
function ɵɵdeferHydrateOnHover() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on hover');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(4, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵdeferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on interaction${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== 'undefined' && ngServerMode)) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onInteraction, () => triggerDeferBlock(0, lView, tNode), 0);
  }
}
function ɵɵdeferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on interaction${walkUpTimes === -1 ? '' : '(<target>)'}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onInteraction, () => triggerPrefetching(tDetails, lView, tNode), 1);
  }
}
function ɵɵdeferHydrateOnInteraction() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, 'hydrate on interaction');
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(3, null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵdeferOnViewport(triggerIndex, walkUpTimes, options) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    const args = [];
    if (walkUpTimes !== undefined && walkUpTimes !== -1) {
      args.push('<target>');
    }
    if (options) {
      args.push(JSON.stringify(options));
    }
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `on viewport${args.length === 0 ? '' : `(${args.join(', ')})`}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode)) return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== 'undefined' && ngServerMode)) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onViewportWrapper, () => triggerDeferBlock(0, lView, tNode), 0, options);
  }
}
function ɵɵdeferPrefetchOnViewport(triggerIndex, walkUpTimes, options) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    const args = [];
    if (walkUpTimes !== undefined && walkUpTimes !== -1) {
      args.push('<target>');
    }
    if (options) {
      args.push(JSON.stringify(options));
    }
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `prefetch on viewport${args.length === 0 ? '' : `(${args.join(', ')})`}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode)) return;
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(lView, tNode, triggerIndex, walkUpTimes, onViewportWrapper, () => triggerPrefetching(tDetails, lView, tNode), 1, options);
  }
}
function ɵɵdeferHydrateOnViewport(options) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], tNode, `hydrate on viewport${options ? `(${JSON.stringify(options)})` : ''}`);
  }
  if (!shouldAttachTrigger(2, lView, tNode)) return;
  const hydrateTriggers = getHydrateTriggers((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), tNode);
  hydrateTriggers.set(2, options ? {
    type: 2,
    intersectionObserverOptions: options
  } : null);
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function ɵɵariaProperty(name, value) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    const hasSetInput = setAllInputsForProperty(tNode, tView, lView, name, value);
    if (hasSetInput) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && markDirtyIfOnPush(lView, tNode.index);
      ngDevMode && setNgReflectProperties(lView, tView, tNode, name, value);
    } else {
      ngDevMode && assertTNodeType(tNode, 2);
      const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
      setElementAttribute(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], element, null, tNode.value, name, value, null);
    }
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, name, bindingIndex);
  }
  return ɵɵariaProperty;
}
function ɵɵattribute(name, value, sanitizer, namespace) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);
  }
  return ɵɵattribute;
}
const ANIMATIONS_DISABLED = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'AnimationsDisabled' : '', {
  factory: () => false
});
const MAX_ANIMATION_TIMEOUT = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'MaxAnimationTimeout' : '', {
  factory: () => MAX_ANIMATION_TIMEOUT_DEFAULT
});
const MAX_ANIMATION_TIMEOUT_DEFAULT = 4000;
const DEFAULT_ANIMATIONS_DISABLED = false;
const areAnimationSupported = (typeof ngServerMode === 'undefined' || !ngServerMode) && typeof document !== 'undefined' && typeof document?.documentElement?.getAnimations === 'function';
function areAnimationsDisabled(lView) {
  const injector = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
  return injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);
}
function assertAnimationTypes(value, instruction) {
  if (value == null || typeof value !== 'string' && typeof value !== 'function') {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(650, `'${instruction}' value must be a string of CSS classes or an animation function, got ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(value)}`);
  }
}
function assertElementNodes(nativeElement, instruction) {
  if (nativeElement.nodeType !== Node.ELEMENT_NODE) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(650, `'${instruction}' can only be used on an element node, got ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(nativeElement.nodeType)}`);
  }
}
function trackEnterClasses(el, classList, cleanupFns) {
  const elementData = enterClassMap.get(el);
  if (elementData) {
    for (const klass of classList) {
      elementData.classList.push(klass);
    }
    for (const fn of cleanupFns) {
      elementData.cleanupFns.push(fn);
    }
  } else {
    enterClassMap.set(el, {
      classList,
      cleanupFns
    });
  }
}
function cleanupEnterClassData(element) {
  const elementData = enterClassMap.get(element);
  if (elementData) {
    for (const fn of elementData.cleanupFns) {
      fn();
    }
    enterClassMap.delete(element);
  }
  longestAnimations.delete(element);
}
const noOpAnimationComplete = () => {};
const enterClassMap = /*#__PURE__*/new WeakMap();
const longestAnimations = /*#__PURE__*/new WeakMap();
const leavingNodes = /*#__PURE__*/new WeakMap();
function clearLeavingNodes(tNode, el) {
  const nodes = leavingNodes.get(tNode);
  if (nodes && nodes.length > 0) {
    const ix = nodes.findIndex(node => node === el);
    if (ix > -1) nodes.splice(ix, 1);
  }
  if (nodes?.length === 0) {
    leavingNodes.delete(tNode);
  }
}
function cancelLeavingNodes(tNode, lView) {
  const leavingEl = leavingNodes.get(tNode)?.shift();
  const lContainer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_LCONTAINER];
  if (lContainer) {
    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);
    const previousNode = beforeNode?.previousSibling;
    if (leavingEl && previousNode && leavingEl === previousNode) {
      leavingEl.dispatchEvent(new CustomEvent('animationend', {
        detail: {
          cancel: true
        }
      }));
    }
  }
}
function trackLeavingNodes(tNode, el) {
  if (leavingNodes.has(tNode)) {
    leavingNodes.get(tNode)?.push(el);
  } else {
    leavingNodes.set(tNode, [el]);
  }
}
function getLViewEnterAnimations(lView) {
  const animationData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] ??= {};
  return animationData.enter ??= new Map();
}
function getLViewLeaveAnimations(lView) {
  const animationData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] ??= {};
  return animationData.leave ??= new Map();
}
function getClassListFromValue(value) {
  const classes = typeof value === 'function' ? value() : value;
  let classList = Array.isArray(classes) ? classes : null;
  if (typeof classes === 'string') {
    classList = classes.trim().split(/\s+/).filter(k => k);
  }
  return classList;
}
function cancelAnimationsIfRunning(element, renderer) {
  if (!areAnimationSupported) return;
  const elementData = enterClassMap.get(element);
  if (elementData && elementData.classList.length > 0 && elementHasClassList(element, elementData.classList)) {
    for (const klass of elementData.classList) {
      renderer.removeClass(element, klass);
    }
  }
  cleanupEnterClassData(element);
}
function elementHasClassList(element, classList) {
  for (const className of classList) {
    if (element.classList.contains(className)) return true;
  }
  return false;
}
function isLongestAnimation(event, nativeElement) {
  const longestAnimation = longestAnimations.get(nativeElement);
  if (longestAnimation === undefined) return true;
  return nativeElement === event.target && (longestAnimation.animationName !== undefined && event.animationName === longestAnimation.animationName || longestAnimation.propertyName !== undefined && event.propertyName === longestAnimation.propertyName);
}
function addAnimationToLView(animations, tNode, fn) {
  const nodeAnimations = animations.get(tNode.index) ?? {
    animateFns: []
  };
  nodeAnimations.animateFns.push(fn);
  animations.set(tNode.index, nodeAnimations);
}
function cleanupAfterLeaveAnimations(resolvers, cleanupFns) {
  if (resolvers) {
    for (const fn of resolvers) {
      fn();
    }
  }
  for (const fn of cleanupFns) {
    fn();
  }
}
function clearLViewNodeAnimationResolvers(lView, tNode) {
  const nodeAnimations = getLViewLeaveAnimations(lView).get(tNode.index);
  if (nodeAnimations) nodeAnimations.resolvers = undefined;
}
function leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns) {
  clearLeavingNodes(tNode, nativeElement);
  cleanupAfterLeaveAnimations(resolvers, cleanupFns);
  clearLViewNodeAnimationResolvers(lView, tNode);
}
function ɵɵanimateEnter(value) {
  performanceMarkFeature('NgAnimateEnter');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateEnter;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.enter');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (areAnimationsDisabled(lView)) {
    return ɵɵanimateEnter;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewEnterAnimations(lView), tNode, () => runEnterAnimation(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  queueEnterAnimations(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], getLViewEnterAnimations(lView));
  return ɵɵanimateEnter;
}
function runEnterAnimation(lView, tNode, value) {
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.enter');
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const ngZone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  const activeClasses = getClassListFromValue(value);
  const cleanupFns = [];
  const handleEnterAnimationStart = event => {
    if (event.target !== nativeElement) return;
    const eventName = event instanceof AnimationEvent ? 'animationend' : 'transitionend';
    ngZone.runOutsideAngular(() => {
      renderer.listen(nativeElement, eventName, handleEnterAnimationEnd);
    });
  };
  const handleEnterAnimationEnd = event => {
    if (event.target !== nativeElement) return;
    enterAnimationEnd(event, nativeElement, renderer);
  };
  if (activeClasses && activeClasses.length > 0) {
    ngZone.runOutsideAngular(() => {
      cleanupFns.push(renderer.listen(nativeElement, 'animationstart', handleEnterAnimationStart));
      cleanupFns.push(renderer.listen(nativeElement, 'transitionstart', handleEnterAnimationStart));
    });
    trackEnterClasses(nativeElement, activeClasses, cleanupFns);
    for (const klass of activeClasses) {
      renderer.addClass(nativeElement, klass);
    }
    ngZone.runOutsideAngular(() => {
      requestAnimationFrame(() => {
        determineLongestAnimation(nativeElement, longestAnimations, areAnimationSupported);
        if (!longestAnimations.has(nativeElement)) {
          for (const klass of activeClasses) {
            renderer.removeClass(nativeElement, klass);
          }
          cleanupEnterClassData(nativeElement);
        }
      });
    });
  }
}
function enterAnimationEnd(event, nativeElement, renderer) {
  const elementData = enterClassMap.get(nativeElement);
  if (event.target !== nativeElement || !elementData) return;
  if (isLongestAnimation(event, nativeElement)) {
    event.stopImmediatePropagation();
    for (const klass of elementData.classList) {
      renderer.removeClass(nativeElement, klass);
    }
    cleanupEnterClassData(nativeElement);
  }
}
function ɵɵanimateEnterListener(value) {
  performanceMarkFeature('NgAnimateEnter');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateEnterListener;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.enter');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (areAnimationsDisabled(lView)) {
    return ɵɵanimateEnterListener;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewEnterAnimations(lView), tNode, () => runEnterAnimationFunction(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  queueEnterAnimations(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1], getLViewEnterAnimations(lView));
  return ɵɵanimateEnterListener;
}
function runEnterAnimationFunction(lView, tNode, value) {
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.enter');
  value.call(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT], {
    target: nativeElement,
    animationComplete: noOpAnimationComplete
  });
}
function ɵɵanimateLeave(value) {
  performanceMarkFeature('NgAnimateLeave');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateLeave;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.leave');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const animationsDisabled = areAnimationsDisabled(lView);
  if (animationsDisabled) {
    return ɵɵanimateLeave;
  }
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewLeaveAnimations(lView), tNode, () => runLeaveAnimations(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  return ɵɵanimateLeave;
}
function runLeaveAnimations(lView, tNode, value) {
  const {
    promise,
    resolve
  } = promiseWithResolvers();
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.leave');
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const ngZone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  allLeavingAnimations.add(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
  (getLViewLeaveAnimations(lView).get(tNode.index).resolvers ??= []).push(resolve);
  const activeClasses = getClassListFromValue(value);
  if (activeClasses && activeClasses.length > 0) {
    animateLeaveClassRunner(nativeElement, tNode, lView, activeClasses, renderer, ngZone);
  } else {
    resolve();
  }
  return {
    promise,
    resolve
  };
}
function animateLeaveClassRunner(el, tNode, lView, classList, renderer, ngZone) {
  cancelAnimationsIfRunning(el, renderer);
  const cleanupFns = [];
  const resolvers = getLViewLeaveAnimations(lView).get(tNode.index)?.resolvers;
  const handleOutAnimationEnd = event => {
    if (event.target !== el) return;
    if (event instanceof CustomEvent || isLongestAnimation(event, el)) {
      event.stopImmediatePropagation();
      longestAnimations.delete(el);
      clearLeavingNodes(tNode, el);
      if (Array.isArray(tNode.projection)) {
        for (const item of classList) {
          renderer.removeClass(el, item);
        }
      }
      cleanupAfterLeaveAnimations(resolvers, cleanupFns);
      clearLViewNodeAnimationResolvers(lView, tNode);
    }
  };
  ngZone.runOutsideAngular(() => {
    cleanupFns.push(renderer.listen(el, 'animationend', handleOutAnimationEnd));
    cleanupFns.push(renderer.listen(el, 'transitionend', handleOutAnimationEnd));
  });
  trackLeavingNodes(tNode, el);
  for (const item of classList) {
    renderer.addClass(el, item);
  }
  ngZone.runOutsideAngular(() => {
    requestAnimationFrame(() => {
      determineLongestAnimation(el, longestAnimations, areAnimationSupported);
      if (!longestAnimations.has(el)) {
        clearLeavingNodes(tNode, el);
        cleanupAfterLeaveAnimations(resolvers, cleanupFns);
        clearLViewNodeAnimationResolvers(lView, tNode);
      }
    });
  });
}
function ɵɵanimateLeaveListener(value) {
  performanceMarkFeature('NgAnimateLeave');
  if (typeof ngServerMode !== 'undefined' && ngServerMode || !areAnimationSupported) {
    return ɵɵanimateLeaveListener;
  }
  ngDevMode && assertAnimationTypes(value, 'animate.leave');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  allLeavingAnimations.add(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
  addAnimationToLView(getLViewLeaveAnimations(lView), tNode, () => runLeaveAnimationFunction(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1]);
  return ɵɵanimateLeaveListener;
}
function runLeaveAnimationFunction(lView, tNode, value) {
  const {
    promise,
    resolve
  } = promiseWithResolvers();
  const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, 'animate.leave');
  const cleanupFns = [];
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const animationsDisabled = areAnimationsDisabled(lView);
  const ngZone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
  const maxAnimationTimeout = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(MAX_ANIMATION_TIMEOUT);
  (getLViewLeaveAnimations(lView).get(tNode.index).resolvers ??= []).push(resolve);
  const resolvers = getLViewLeaveAnimations(lView).get(tNode.index)?.resolvers;
  if (animationsDisabled) {
    leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
  } else {
    const timeoutId = setTimeout(() => leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns), maxAnimationTimeout);
    const event = {
      target: nativeElement,
      animationComplete: () => {
        leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
        clearTimeout(timeoutId);
      }
    };
    trackLeavingNodes(tNode, nativeElement);
    ngZone.runOutsideAngular(() => {
      cleanupFns.push(renderer.listen(nativeElement, 'animationend', () => {
        leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
        clearTimeout(timeoutId);
      }, {
        once: true
      }));
    });
    value.call(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT], event);
  }
  return {
    promise,
    resolve
  };
}
function ɵɵcomponentInstance() {
  const instance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(instance, 'Expected component instance to be defined');
  return instance;
}
function ɵɵcontrolCreate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (tView.firstCreatePass) {
    initializeControlFirstCreatePass(tView, tNode, lView);
  }
  const fieldDirective = getFieldDirective(tNode, lView);
  if (!fieldDirective) {
    return;
  }
  performanceMarkFeature('NgSignalForms');
  if (tNode.flags & 1024) {
    initializeCustomControl(lView, tNode, fieldDirective, 'value');
  } else if (tNode.flags & 2048) {
    initializeCustomControl(lView, tNode, fieldDirective, 'checked');
  } else if (tNode.flags & 4096) {
    initializeInteropControl(fieldDirective);
  } else if (tNode.flags & 8192) {
    initializeNativeControl(lView, tNode, fieldDirective);
  }
  fieldDirective.ɵregister();
}
function ɵɵcontrol(value, name, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    setPropertyAndInputs(tNode, lView, name, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, name, bindingIndex);
  }
  updateControl(lView, tNode);
}
function ɵcontrolUpdate() {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
  updateControl(lView, tNode);
}
function updateControl(lView, tNode) {
  const fieldDirective = getFieldDirective(tNode, lView);
  if (fieldDirective) {
    updateControlClasses(lView, tNode, fieldDirective);
    if (tNode.flags & 1024) {
      updateCustomControl(tNode, lView, fieldDirective, 'value');
    } else if (tNode.flags & 2048) {
      updateCustomControl(tNode, lView, fieldDirective, 'checked');
    } else if (tNode.flags & 4096) {
      updateInteropControl(tNode, lView, fieldDirective);
    } else {
      updateNativeControl(tNode, lView, fieldDirective);
    }
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
}
function initializeControlFirstCreatePass(tView, tNode, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstCreatePass)(tView);
  const directiveIndices = tNode.inputs?.['formField'];
  if (!directiveIndices) {
    return;
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode) && directiveIndices.includes(tNode.directiveStart + tNode.componentOffset)) {
    return;
  }
  const controlIndex = directiveIndices.find(index => ɵCONTROL in lView[index]);
  if (controlIndex === undefined) {
    return;
  }
  tNode.fieldIndex = controlIndex;
  const foundControl = isInteropControlFirstCreatePass(tNode, lView) || isCustomControlFirstCreatePass(tView, tNode);
  if (isNativeControlFirstCreatePass(tNode) || foundControl) {
    return;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(318, ngDevMode && `${describeElement(tView, tNode)} is an invalid [formField] directive host. The host must be a native form control ` + `(such as <input>', '<select>', or '<textarea>') or a custom form control with a 'value' or ` + `'checked' model.`);
}
function describeElement(tView, tNode) {
  if (ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
    const componentIndex = tNode.directiveStart + tNode.componentOffset;
    const componentDef = tView.data[componentIndex];
    return `Component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.debugStringifyTypeForError)(componentDef.type)}`;
  }
  return `<${tNode.value}>`;
}
function isInteropControlFirstCreatePass(tNode, lView) {
  const control = lView[tNode.fieldIndex];
  if (control.ɵinteropControl) {
    tNode.flags |= 4096;
    return true;
  }
  return false;
}
function isCustomControlFirstCreatePass(tView, tNode) {
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveDef = tView.data[i];
    if (hasModelInput(directiveDef, 'value')) {
      tNode.flags |= 1024;
      tNode.customControlIndex = i;
      return true;
    }
    if (hasModelInput(directiveDef, 'checked')) {
      tNode.flags |= 2048;
      tNode.customControlIndex = i;
      return true;
    }
  }
  return false;
}
function isNativeControlFirstCreatePass(tNode) {
  if (!isNativeControl(tNode)) {
    return false;
  }
  tNode.flags |= 8192;
  if (isNumericInput(tNode)) {
    tNode.flags |= 16384;
  }
  if (isTextControl(tNode)) {
    tNode.flags |= 32768;
  }
  return true;
}
function getFieldDirective(tNode, lView) {
  const index = tNode.fieldIndex;
  return index === -1 ? null : lView[index];
}
function hasModelInput(directiveDef, name) {
  return hasInput(directiveDef, name) && hasOutput(directiveDef, name + 'Change');
}
function hasInput(directiveDef, name) {
  return name in directiveDef.inputs;
}
function hasOutput(directiveDef, name) {
  return name in directiveDef.outputs;
}
function initializeCustomControl(lView, tNode, fieldDirective, modelName) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const directiveIndex = tNode.customControlIndex;
  const outputName = modelName + 'Change';
  listenToOutput(tNode, lView, directiveIndex, outputName, outputName, wrapListener(tNode, lView, value => fieldDirective.state().setControlValue(value)));
  const directiveDef = tView.data[directiveIndex];
  const touchedOutputName = 'touchedChange';
  if (hasOutput(directiveDef, touchedOutputName)) {
    listenToOutput(tNode, lView, directiveIndex, touchedOutputName, touchedOutputName, wrapListener(tNode, lView, () => fieldDirective.state().markAsTouched()));
  }
  const customControl = lView[directiveIndex];
  fieldDirective.focus = () => customControl.focus ? customControl.focus() : fieldDirective.element.focus();
}
function initializeInteropControl(fieldDirective) {
  const interopControl = fieldDirective.ɵinteropControl;
  interopControl.registerOnChange(value => fieldDirective.state().setControlValue(value));
  interopControl.registerOnTouched(() => fieldDirective.state().markAsTouched());
  fieldDirective.focus = () => fieldDirective.element.focus();
}
function isNativeControl(tNode) {
  if (tNode.type !== 2) {
    return false;
  }
  const tagName = tNode.value;
  return tagName === 'input' || tagName === 'textarea' || tagName === 'select';
}
function initializeNativeControl(lView, tNode, fieldDirective) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  const inputListener = () => {
    const state = fieldDirective.state();
    state.setControlValue(getNativeControlValue(element, state.value));
  };
  listenToDomEvent(tNode, tView, lView, undefined, renderer, 'input', inputListener, wrapListener(tNode, lView, inputListener));
  const blurListener = () => {
    fieldDirective.state().markAsTouched();
  };
  listenToDomEvent(tNode, tView, lView, undefined, renderer, 'blur', blurListener, wrapListener(tNode, lView, blurListener));
  if (tNode.type === 2 && tNode.value === 'select' && typeof MutationObserver === 'function') {
    const observer = observeSelectMutations(element, fieldDirective);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.storeCleanupWithContext)(tView, lView, observer, observer.disconnect);
  }
  fieldDirective.focus = () => element.focus();
}
function observeSelectMutations(select, controlDirective) {
  const observer = new MutationObserver(mutations => {
    if (mutations.some(m => isRelevantSelectMutation(m))) {
      select.value = controlDirective.state().value();
    }
  });
  observer.observe(select, {
    attributes: true,
    attributeFilter: ['value'],
    characterData: true,
    childList: true,
    subtree: true
  });
  return observer;
}
function isRelevantSelectMutation(mutation) {
  if (mutation.type === 'childList' || mutation.type === 'characterData') {
    if (mutation.target instanceof Comment) {
      return false;
    }
    for (const node of mutation.addedNodes) {
      if (!(node instanceof Comment)) {
        return true;
      }
    }
    for (const node of mutation.removedNodes) {
      if (!(node instanceof Comment)) {
        return true;
      }
    }
    return false;
  }
  if (mutation.type === 'attributes' && mutation.target instanceof HTMLOptionElement) {
    return true;
  }
  return false;
}
function updateControlClasses(lView, tNode, control) {
  if (control.classes) {
    const bindings = getControlBindings(lView);
    bindings.classes ??= {};
    control.state();
    const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
    const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
    for (const [className, enabled] of control.classes) {
      const isEnabled = enabled();
      if (controlClassBindingUpdated(bindings.classes, className, isEnabled)) {
        if (isEnabled) {
          renderer.addClass(element, className);
        } else {
          renderer.removeClass(element, className);
        }
      }
    }
  }
}
function updateCustomControl(tNode, lView, control, modelName) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const directiveIndex = tNode.customControlIndex;
  const directive = lView[directiveIndex];
  const directiveDef = tView.data[directiveIndex];
  const state = control.state();
  const bindings = getControlBindings(lView);
  const controlValue = state.controlValue();
  if (controlBindingUpdated(bindings, CONTROL_VALUE, controlValue)) {
    writeToDirectiveInput(directiveDef, directive, modelName, controlValue);
  }
  const isNative = (tNode.flags & 8192) !== 0;
  const element = isNative ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView) : null;
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  for (const key of CONTROL_BINDING_KEYS) {
    const value = state[key]?.();
    if (controlBindingUpdated(bindings, key, value)) {
      const inputName = CONTROL_BINDING_NAMES[key];
      updateDirectiveInputs(tNode, lView, inputName, value);
      if (isNative && !(inputName in directiveDef.inputs)) {
        updateNativeProperty(tNode, renderer, element, key, value, inputName);
      }
    }
  }
}
function updateInteropControl(tNode, lView, control) {
  const interopControl = control.ɵinteropControl;
  const bindings = getControlBindings(lView);
  const state = control.state();
  const isNative = (tNode.flags & 8192) !== 0;
  const element = isNative ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView) : null;
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const value = state.value();
  if (controlBindingUpdated(bindings, CONTROL_VALUE, value)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => interopControl.writeValue(value));
  }
  for (const key of CONTROL_BINDING_KEYS) {
    const value = state[key]?.();
    if (controlBindingUpdated(bindings, key, value)) {
      const inputName = CONTROL_BINDING_NAMES[key];
      const didUpdateInput = updateDirectiveInputs(tNode, lView, inputName, value);
      if (key === DISABLED) {
        if (interopControl.setDisabledState) {
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => interopControl.setDisabledState(value));
        }
      } else if (isNative && !didUpdateInput) {
        updateNativeProperty(tNode, renderer, element, key, value, inputName);
      }
    }
  }
}
function updateNativeControl(tNode, lView, control) {
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNode)(tNode, lView);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const state = control.state();
  const bindings = getControlBindings(lView);
  const controlValue = state.controlValue();
  if (controlBindingUpdated(bindings, CONTROL_VALUE, controlValue)) {
    setNativeControlValue(element, controlValue);
  }
  for (const key of CONTROL_BINDING_KEYS) {
    const value = state[key]?.();
    if (controlBindingUpdated(bindings, key, value)) {
      const inputName = CONTROL_BINDING_NAMES[key];
      updateNativeProperty(tNode, renderer, element, key, value, inputName);
      updateDirectiveInputs(tNode, lView, inputName, value);
    }
  }
}
function updateDirectiveInputs(tNode, lView, inputName, value) {
  const directiveIndices = tNode.inputs?.[inputName];
  if (directiveIndices) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    for (const index of directiveIndices) {
      const directiveDef = tView.data[index];
      const directive = lView[index];
      writeToDirectiveInput(directiveDef, directive, inputName, value);
    }
    return true;
  }
  return false;
}
function updateNativeProperty(tNode, renderer, element, key, value, name) {
  switch (key) {
    case NAME:
      renderer.setAttribute(element, name, value);
      break;
    case DISABLED:
    case READONLY:
    case REQUIRED:
      setBooleanAttribute(renderer, element, name, value);
      break;
    case MAX:
    case MIN:
      if (tNode.flags & 16384) {
        setOptionalAttribute(renderer, element, name, value);
      }
      break;
    case MAX_LENGTH:
    case MIN_LENGTH:
      if (tNode.flags & 32768) {
        setOptionalAttribute(renderer, element, name, value);
      }
      break;
  }
}
function isDateOrNull(value) {
  return value === null || value instanceof Date;
}
function isNumericInput(tNode) {
  if (!tNode.attrs || tNode.value !== 'input') {
    return false;
  }
  for (let i = 0; i < tNode.attrs.length; i += 2) {
    const name = tNode.attrs[i];
    if (isNameOnlyAttributeMarker(name)) {
      break;
    }
    if (name === 'type') {
      const value = tNode.attrs[i + 1];
      return value === 'date' || value === 'datetime-local' || value === 'month' || value === 'number' || value === 'range' || value === 'time' || value === 'week';
    }
  }
  return false;
}
function isTextControl(tNode) {
  return tNode.value !== 'select';
}
function getNativeControlValue(element, currentValue) {
  switch (element.type) {
    case 'checkbox':
      return element.checked;
    case 'number':
    case 'range':
    case 'datetime-local':
      if (typeof currentValue() === 'number') {
        return element.valueAsNumber;
      }
      break;
    case 'date':
    case 'month':
    case 'time':
    case 'week':
      const value = currentValue();
      if (isDateOrNull(value)) {
        return element.valueAsDate;
      } else if (typeof value === 'number') {
        return element.valueAsNumber;
      }
      break;
  }
  return element.value;
}
function setNativeControlValue(element, value) {
  switch (element.type) {
    case 'checkbox':
      element.checked = value;
      return;
    case 'radio':
      element.checked = value === element.value;
      return;
    case 'number':
    case 'range':
    case 'datetime-local':
      if (typeof value === 'number') {
        setNativeNumberControlValue(element, value);
        return;
      }
      break;
    case 'date':
    case 'month':
    case 'time':
    case 'week':
      if (isDateOrNull(value)) {
        element.valueAsDate = value;
        return;
      } else if (typeof value === 'number') {
        setNativeNumberControlValue(element, value);
        return;
      }
  }
  element.value = value;
}
function setNativeNumberControlValue(element, value) {
  if (isNaN(value)) {
    element.value = '';
  } else {
    element.valueAsNumber = value;
  }
}
const DISABLED = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  disabled: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MAX = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  max: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MAX_LENGTH = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  maxLength: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MIN = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  min: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const MIN_LENGTH = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  minLength: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const NAME = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  name: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const READONLY = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  readonly: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const REQUIRED = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  required: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const CONTROL_VALUE = /* @__PURE__ */(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty)({
  controlValue: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getClosureSafeProperty
});
const CONTROL_BINDING_NAMES = {
  disabled: 'disabled',
  disabledReasons: 'disabledReasons',
  dirty: 'dirty',
  errors: 'errors',
  hidden: 'hidden',
  invalid: 'invalid',
  max: 'max',
  maxLength: 'maxLength',
  min: 'min',
  minLength: 'minLength',
  name: 'name',
  pattern: 'pattern',
  pending: 'pending',
  readonly: 'readonly',
  required: 'required',
  touched: 'touched'
};
const CONTROL_BINDING_KEYS = /* @__PURE__ */(() => Object.keys(CONTROL_BINDING_NAMES))();
function getControlBindings(lView) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let bindings = lView[bindingIndex];
  if (bindings === NO_CHANGE) {
    bindings = lView[bindingIndex] = {};
  }
  return bindings;
}
function controlBindingUpdated(bindings, key, value) {
  const oldValue = bindings[key];
  if (Object.is(oldValue, value)) {
    return false;
  }
  bindings[key] = value;
  return true;
}
function controlClassBindingUpdated(bindings, className, value) {
  const oldValue = bindings[className];
  if (Object.is(oldValue, value)) {
    return false;
  }
  bindings[className] = value;
  return true;
}
function setBooleanAttribute(renderer, element, name, value) {
  if (value) {
    renderer.setAttribute(element, name, '');
  } else {
    renderer.removeAttribute(element, name);
  }
}
function setOptionalAttribute(renderer, element, name, value) {
  if (value !== undefined) {
    renderer.setAttribute(element, name, value.toString());
  } else {
    renderer.removeAttribute(element, name);
  }
}
class LiveCollection {
  destroy(item) {}
  updateValue(index, value) {}
  swap(index1, index2) {
    const startIdx = Math.min(index1, index2);
    const endIdx = Math.max(index1, index2);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
}
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== undefined) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn, reactiveConsumer) {
  let detachedItems = undefined;
  let liveKeysInTheFuture = undefined;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? new Map() : undefined;
  if (Array.isArray(newCollection)) {
    (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__.setActiveConsumer)(reactiveConsumer);
    let newEndIdx = newCollection.length - 1;
    (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__.setActiveConsumer)(null);
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__.setActiveConsumer)(reactiveConsumer);
    const newCollectionIterator = newCollection[Symbol.iterator]();
    (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__.setActiveConsumer)(null);
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach(item => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-955, 'The provided track expression resulted in duplicated keys for a given collection. ' + 'Adjust the tracking expression such that it uniquely identifies all the items in the collection. ' + 'Duplicated keys were: \n' + duplicatedKeysMsg.join(', \n') + '.');
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== undefined && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = new Set();
  for (let i = start; i <= end; i++) {
    keys.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys;
}
class UniqueValueMultiKeyMap {
  kvMap = /*#__PURE__*/new Map();
  _vMap = undefined;
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key)) return false;
    const value = this.kvMap.get(key);
    if (this._vMap !== undefined && this._vMap.has(value)) {
      this.kvMap.set(key, this._vMap.get(value));
      this._vMap.delete(value);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      if (ngDevMode && prevValue === value) {
        throw new Error(`Detected a duplicated value ${value} for the key ${key}`);
      }
      if (this._vMap === undefined) {
        this._vMap = new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value);
    } else {
      this.kvMap.set(key, value);
    }
  }
  forEach(cb) {
    for (let [key, value] of this.kvMap) {
      cb(value, key);
      if (this._vMap !== undefined) {
        const vMap = this._vMap;
        while (vMap.has(value)) {
          value = vMap.get(value);
          cb(value, key);
        }
      }
    }
  }
}
function ɵɵconditionalCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature('NgControlFlow');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 256, localRefsIndex, localRefExtractor);
  return ɵɵconditionalBranchCreate;
}
function ɵɵconditionalBranchCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature('NgControlFlow');
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 512, localRefsIndex, localRefExtractor);
  return ɵɵconditionalBranchCreate;
}
function ɵɵconditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature('NgControlFlow');
  const hostLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + prevMatchingTemplateIndex) : undefined;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      if (prevContainer !== undefined) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], nextLContainerIndex);
        const dehydratedView = findAndReconcileMatchingDehydratedViews(nextContainer, templateTNode, hostLView);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
    }
  } else if (prevContainer !== undefined) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== undefined) {
      lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT] = contextValue;
    }
  }
}
class RepeaterContext {
  lContainer;
  $implicit;
  $index;
  constructor(lContainer, $implicit, $index) {
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET;
  }
}
function ɵɵrepeaterTrackByIndex(index) {
  return index;
}
function ɵɵrepeaterTrackByIdentity(_, value) {
  return value;
}
class RepeaterMetadata {
  hasEmptyBlock;
  trackByFn;
  liveCollection;
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
}
function ɵɵrepeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature('NgControlFlow');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFunction)(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const hasEmptyBlock = emptyTemplateFn !== undefined;
  const hostLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const boundTrackBy = trackByUsesComponentInstance ? trackByFn.bind(hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT]) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index] = metadata;
  declareNoDirectiveHostTemplate(lView, tView, index + 1, templateFn, decls, vars, tagName, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex), 256);
  if (hasEmptyBlock) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(emptyDecls, 'Missing number of declarations for the empty repeater block.');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(emptyVars, 'Missing number of bindings for the empty repeater block.');
    declareNoDirectiveHostTemplate(lView, tView, index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, emptyAttrsIndex), 512);
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET > 2;
}
class OperationsCounter {
  created = 0;
  destroyed = 0;
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
}
class LiveCollectionLContainerImpl extends LiveCollection {
  lContainer;
  hostLView;
  templateTNode;
  operationsCounter = ngDevMode ? /*#__PURE__*/new OperationsCounter() : undefined;
  needsIndexUpdate = false;
  constructor(lContainer, hostLView, templateTNode) {
    super();
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
  }
  get length() {
    return this.lContainer.length - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET;
  }
  at(index) {
    return this.getLView(index)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT].$implicit;
  }
  attach(index, lView) {
    const dehydratedView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
    this.needsIndexUpdate ||= index !== this.length;
    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
    clearDetachAnimationList(this.lContainer, index);
  }
  detach(index) {
    this.needsIndexUpdate ||= index !== this.length - 1;
    maybeInitDetachAnimationList(this.lContainer, index);
    return detachExistingView(this.lContainer, index);
  }
  create(index, value) {
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), {
      dehydratedView
    });
    ngDevMode && this.operationsCounter?.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    destroyLView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
    ngDevMode && this.operationsCounter?.recordDestroy();
  }
  updateValue(index, value) {
    this.getLView(index)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT].$implicit = value;
  }
  reset() {
    this.needsIndexUpdate = false;
    ngDevMode && this.operationsCounter?.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i = 0; i < this.length; i++) {
        this.getLView(i)[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT].$index = i;
      }
    }
  }
  getLView(index) {
    return getExistingLViewFromLContainer(this.lContainer, index);
  }
}
function ɵɵrepeater(collection) {
  const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
  const metadataSlotIdx = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)();
  try {
    const hostLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
    const hostTView = hostLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === undefined) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn, prevConsumer);
    if (ngDevMode && metadata.trackByFn === ɵɵrepeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. ` + 'This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. ' + 'Please review the "track expression" and make sure that it uniquely identifies items in a collection.');
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findAndReconcileMatchingDehydratedViews(lContainerForEmpty, emptyTemplateTNode, hostLView);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, undefined, {
            dehydratedView
          });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          if (hostTView.firstUpdatePass) {
            removeDehydratedViews(lContainerForEmpty);
          }
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(lContainer);
  return lContainer;
}
function clearDetachAnimationList(lContainer, index) {
  if (lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  const viewToDetach = lContainer[indexInContainer];
  const animations = viewToDetach ? viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] : undefined;
  if (viewToDetach && animations && animations.detachedLeaveAnimationFns && animations.detachedLeaveAnimationFns.length > 0) {
    const injector = viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1];
    removeFromAnimationQueue(injector, animations);
    allLeavingAnimations.delete(viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ID]);
    animations.detachedLeaveAnimationFns = undefined;
  }
}
function maybeInitDetachAnimationList(lContainer, index) {
  if (lContainer.length <= _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET + index;
  const viewToDetach = lContainer[indexInContainer];
  const animations = viewToDetach ? viewToDetach[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ANIMATIONS] : undefined;
  if (animations && animations.leave && animations.leave.size > 0) {
    animations.detachedLeaveAnimationFns = [];
  }
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(tView, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(tNode);
  return tNode;
}
function ɵɵproperty(propName, value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    setPropertyAndInputs(tNode, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵproperty;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  setAllInputsForProperty(tNode, tView, lView, isClassBased ? 'class' : 'style', value);
}
function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 2, name, findDirectiveDefMatches, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingsEnabled)(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return ɵɵelementStart;
}
function ɵɵelementEnd() {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(currentTNode, 3);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isSkipHydrationRootTNode)(currentTNode)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveSkipHydrationBlock)();
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.decreaseElementDepthCount)();
  if (currentTNode.classesWithoutHost != null && hasClassInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), currentTNode.classesWithoutHost, true);
  }
  if (currentTNode.stylesWithoutHost != null && hasStyleInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), currentTNode.stylesWithoutHost, false);
  }
  return ɵɵelementEnd;
}
function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);
  ɵɵelementEnd();
  return ɵɵelement;
}
function ɵɵdomElementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 2, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return ɵɵdomElementStart;
}
function ɵɵdomElementEnd() {
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(currentTNode, 3);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isSkipHydrationRootTNode)(currentTNode)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.leaveSkipHydrationBlock)();
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.decreaseElementDepthCount)();
  return ɵɵdomElementEnd;
}
function ɵɵdomElement(index, name, attrsIndex, localRefsIndex) {
  ɵɵdomElementStart(index, name, attrsIndex, localRefsIndex);
  ɵɵdomElementEnd();
  return ɵɵdomElement;
}
let _locateOrCreateElementNode = (tView, lView, tNode, name, index) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createElementNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], name, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNamespace)());
};
function locateOrCreateElementNodeImpl(tView, lView, tNode, name, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createElementNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], name, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNamespace)());
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const native = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(native, Node.ELEMENT_NODE, name, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(native);
  if (getSerializedContainerViews(hydrationInfo, index)) {
    ngDevMode && validateNodeExists(native.nextSibling, lView, tNode);
    setSegmentHead(hydrationInfo, index, native.nextSibling);
  }
  if (hydrationInfo && (hasSkipHydrationAttrOnTNode(tNode) || hasSkipHydrationAttrOnRElement(native))) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.enterSkipHydrationBlock)(tNode);
      clearElementContents(native);
      ngDevMode && markRNodeAsSkippedByHydration(native);
    } else if (ngDevMode) {
      throw invalidSkipHydrationHost(native);
    }
  }
  return native;
}
function enableLocateOrCreateElementNodeImpl() {
  _locateOrCreateElementNode = locateOrCreateElementNodeImpl;
}
function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 8, 'ng-container', findDirectiveDefMatches, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingsEnabled)(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, 'ng-container', _locateOrCreateElementContainerNode);
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isDirectiveHost)(tNode)) {
    const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵelementContainerStart;
}
function ɵɵelementContainerEnd() {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  ngDevMode && assertTNodeType(currentTNode, 8);
  return ɵɵelementContainerEnd;
}
function ɵɵelementContainer(index, attrsIndex, localRefsIndex) {
  ɵɵelementContainerStart(index, attrsIndex, localRefsIndex);
  ɵɵelementContainerEnd();
  return ɵɵelementContainer;
}
function ɵɵdomElementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 8, 'ng-container', attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, 'ng-container', _locateOrCreateElementContainerNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return ɵɵdomElementContainerStart;
}
function ɵɵdomElementContainerEnd() {
  const initialTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(initialTNode, 'No parent node to close.');
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(currentTNode, 8);
  return ɵɵelementContainerEnd;
}
function ɵɵdomElementContainer(index, attrsIndex, localRefsIndex) {
  ɵɵdomElementContainerStart(index, attrsIndex, localRefsIndex);
  ɵɵdomElementContainerEnd();
  return ɵɵdomElementContainer;
}
let _locateOrCreateElementContainerNode = (tView, lView, tNode, commentText, index) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createCommentNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], ngDevMode ? commentText : '');
};
function locateOrCreateElementContainerNode(tView, lView, tNode, commentText, index) {
  let comment;
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createCommentNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], ngDevMode ? commentText : '');
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  const ngContainerSize = getNgContainerSize(hydrationInfo, index);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(ngContainerSize, 'Unexpected state: hydrating an <ng-container>, ' + 'but no hydration info is available.');
  setSegmentHead(hydrationInfo, index, currentRNode);
  comment = siblingAfter(ngContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateElementContainerNodeImpl() {
  _locateOrCreateElementContainerNode = locateOrCreateElementContainerNode;
}
function ɵɵgetCurrentView() {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
}
function ɵɵdomProperty(propName, value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    setDomProperty(tNode, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵdomProperty;
}
function ɵɵsyntheticHostProperty(propName, value, sanitizer) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    const currentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveDef)(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵsyntheticHostProperty;
}
const u = undefined;
function plural(val) {
  const i = Math.floor(Math.abs(val)),
    v = val.toString().replace(/^[^.]*\.?/, '').length;
  if (i === 1 && v === 0) return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"]], [["AM", "PM"]], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, u, u], [".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":"], ["#,##0.###", "#,##0%", "¤#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
let LOCALE_DATA = {};
function registerLocaleData(data, localeId, extraData) {
  if (typeof localeId !== 'string') {
    extraData = localeId;
    localeId = data[LocaleDataIndex.LocaleId];
  }
  localeId = localeId.toLowerCase().replace(/_/g, '-');
  LOCALE_DATA[localeId] = data;
  if (extraData) {
    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
  }
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match = getLocaleData(normalizedLocale);
  if (match) {
    return match;
  }
  const parentLocale = normalizedLocale.split('-')[0];
  match = getLocaleData(parentLocale);
  if (match) {
    return match;
  }
  if (parentLocale === 'en') {
    return localeEn;
  }
  throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocaleCurrencyCode(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencyCode] || null;
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng && _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng.common && _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng.common.locales && _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__._global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function unregisterAllLocaleData() {
  LOCALE_DATA = {};
}
var LocaleDataIndex = /*#__PURE__*/function (LocaleDataIndex) {
  LocaleDataIndex[LocaleDataIndex["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex[LocaleDataIndex["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex[LocaleDataIndex["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex[LocaleDataIndex["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex[LocaleDataIndex["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex[LocaleDataIndex["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex[LocaleDataIndex["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex[LocaleDataIndex["Eras"] = 7] = "Eras";
  LocaleDataIndex[LocaleDataIndex["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex[LocaleDataIndex["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex[LocaleDataIndex["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex[LocaleDataIndex["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex[LocaleDataIndex["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex[LocaleDataIndex["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex[LocaleDataIndex["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex[LocaleDataIndex["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex[LocaleDataIndex["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex[LocaleDataIndex["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex[LocaleDataIndex["Currencies"] = 18] = "Currencies";
  LocaleDataIndex[LocaleDataIndex["Directionality"] = 19] = "Directionality";
  LocaleDataIndex[LocaleDataIndex["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex[LocaleDataIndex["ExtraData"] = 21] = "ExtraData";
  return LocaleDataIndex;
}(LocaleDataIndex || {});
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, '-');
}
const pluralMapping = ['zero', 'one', 'two', 'few', 'many'];
function getPluralCase(value, locale) {
  const plural = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural];
  return result !== undefined ? result : 'other';
}
const DEFAULT_LOCALE_ID = 'en-US';
const USD_CURRENCY_CODE = 'USD';
const ELEMENT_MARKER = {
  marker: 'element'
};
const ICU_MARKER = {
  marker: 'ICU'
};
var I18nCreateOpCode = /*#__PURE__*/function (I18nCreateOpCode) {
  I18nCreateOpCode[I18nCreateOpCode["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode[I18nCreateOpCode["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode[I18nCreateOpCode["COMMENT"] = 2] = "COMMENT";
  return I18nCreateOpCode;
}(I18nCreateOpCode || {});
let LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(localeId, `Expected localeId to be defined`);
  if (typeof localeId === 'string') {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, '-');
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
let changeMask = 0b0;
let changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0b0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
let _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function locateOrCreateNodeImpl(lView, index, textOrName, nodeType) {
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const noOffsetIndex = index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const isNodeCreationMode = !isI18nHydrationSupportEnabled() || !hydrationInfo || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)() || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createNodeWithoutHydration(lView, textOrName, nodeType);
  }
  const native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(native, 'expected native element');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(native.nodeType, nodeType, 'expected matching nodeType');
  ngDevMode && nodeType === Node.ELEMENT_NODE && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(native.tagName.toLowerCase(), textOrName.toLowerCase(), 'expecting matching tagName');
  ngDevMode && markRNodeAsClaimedByHydration(native);
  return native;
}
function enableLocateOrCreateI18nNodeImpl() {
  _locateOrCreateNode = locateOrCreateNodeImpl;
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(anchorRNode);
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == 'string') {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == 'number') {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = renderer.parentNode(anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.unwrapRNode)(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThan)(refIdx, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Missing ref');
            const child = lView[refIdx];
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === 'object') {
              ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTIcu)(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof commentValue, 'string', `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInExpandoRange)(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof tagName, 'string', `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInExpandoRange)(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask) {
      let value = '';
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == 'string') {
          value += opCode;
        } else if (typeof opCode == 'number') {
          if (opCode < 0) {
            value += (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNodeOrTagName, 'Experting TNode or string');
                if (typeof tNodeOrTagName === 'string') {
                  setElementAttribute(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  setPropertyAndInputs(tNodeOrTagName, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizeFn);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1:
        {
          const resolvedCase = getPluralCase(bindingValue, getLocaleId());
          index = icuExpression.cases.indexOf(resolvedCase);
          if (index === -1 && resolvedCase !== 'other') {
            index = icuExpression.cases.indexOf('other');
          }
          break;
        }
      case 0:
        {
          index = icuExpression.cases.indexOf('other');
          break;
        }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error('unexpected OpCode');
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = '';
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === 'string') {
        statement += value;
      } else if (value < 0) {
        statement += '${lView[i' + value + ']}';
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');
        statement = '';
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === 'string') {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === 'number') {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error('Unexpected value');
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
class OpCodeParser {
  i = 0;
  codes;
  constructor(codes) {
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value = this.codes[this.i++];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(value, 'expecting number in OpCode');
    return value;
  }
  consumeString() {
    let value = this.codes[this.i++];
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(value, 'expecting string in OpCode');
    return value;
  }
  consumeFunction() {
    let value = this.codes[this.i++];
    if (value === null || typeof value === 'function') {
      return value;
    }
    throw new Error('expecting function in OpCode');
  }
  consumeNumberOrString() {
    let value = this.codes[this.i++];
    if (typeof value === 'string') {
      return value;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(value, 'expecting number or string in OpCode');
    return value;
  }
  consumeNumberStringOrMarker() {
    let value = this.codes[this.i++];
    if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER || value == ELEMENT_MARKER) {
      return value;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');
    return value;
  }
}
const BINDING_REGEXP = /�(\d+):?\d*�/gi;
const ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
const NESTED_ICU = /�(\d+)�/;
const ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
const MARKER = `�`;
const SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
const PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
const NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, ' ');
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, 'debug', {
      get: debugGetter,
      enumerable: false
    });
  } else {
    throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(text, 'Parsed ICU part should be string');
          if (text !== '') {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== 'object') {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(icuNodeIndex, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Index must be in absolute LView offset');
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertOneOf)(type, 42, 35);
      const index = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);
        existingTNodeStack.unshift([]);
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, true);
        const placeholderNode = {
          kind: 2,
          index,
          children: [],
          type: type === 35 ? 0 : 1
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? '' : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? '{{?}}' : '' : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({
    kind: 0,
    index
  });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== '') {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertGreaterThanOrEqual)(destinationNode, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, 'Index must be in absolute LView offset');
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== '') {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === 'number' && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match;
  let res = '';
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match.index + match[0].length);
      tagMatched = match[1];
      inTemplate = true;
    } else {
      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(icuExpression, 'ICU expression must be defined');
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== 'string') {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--�${icuIndex}�-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {
    if (type === 'select') {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return '';
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length;) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, '$1');
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return {
    type: icuType,
    mainBinding: mainBinding,
    cases,
    values
  };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match;
  while (match = braces.exec(pattern)) {
    const pos = match.index;
    if (match[0] == '}') {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring = pattern.substring(prevPos, pos);
        results.push(substring);
        prevPos = pos + 1;
      }
      braceStack.push('{');
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove);
  tIcu.update.push(update);
  const inertBodyHelper = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(inertBodyElement, 'Unable to generate inert body element');
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ` + `${lowerAttrName} on element ${tagName} ` + `(see ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || '';
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);
        addRemoveNode(remove, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove, index, depth) {
  if (depth === 0) {
    remove.push(index);
  }
}
function addRemoveNestedIcu(remove, index, depth) {
  if (depth === 0) {
    remove.push(~index);
    remove.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(bindingMask, 1, index << 2 | 3);
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
const ROOT_TEMPLATE_ID = 0;
const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
const PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
const PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
const PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
const PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
const PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split('|').forEach(placeholder => {
          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);
          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);
          placeholders.push([templateId, isCloseTemplateTag, placeholder]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match;
  });
  result = result.replace(PP_ICUS_REGEXP, (match, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
      }
      return list.shift();
    }
    return match;
  });
  return result;
}
function ɵɵi18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView, `tView should be defined`);
  const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, messageIndex);
  const parentTNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentParentTNode)();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 32;
  } else {
    lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInI18nBlock)(true);
}
function ɵɵi18nEnd() {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInI18nBlock)(false);
}
function ɵɵi18n(index, messageIndex, subTemplateIndex) {
  ɵɵi18nStart(index, messageIndex, subTemplateIndex);
  ɵɵi18nEnd();
}
function ɵɵi18nAttributes(index, attrsIndex) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tView, `tView should be defined`);
  const attrs = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getConstant)(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, attrs);
}
function ɵɵi18nExp(value) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  setMaskBit(bindingUpdated(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)(), value));
  return ɵɵi18nExp;
}
function ɵɵi18nApply(index) {
  applyI18n((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
}
function ɵɵi18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
function ɵɵlistener(eventName, listenerFn, eventTargetResolver) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  listenerInternal(tView, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return ɵɵlistener;
}
function ɵɵsyntheticHostListener(eventName, listenerFn) {
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const currentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveDef)(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return ɵɵsyntheticHostListener;
}
function ɵɵdomListener(eventName, listenerFn, eventTargetResolver) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  if (tNode.type & 3 || eventTargetResolver) {
    listenToDomEvent(tNode, tView, lView, eventTargetResolver, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], eventName, listenerFn, wrapListener(tNode, lView, listenerFn));
  }
  return ɵɵdomListener;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  ngDevMode && assertTNodeType(tNode, 3 | 12);
  let processOutputs = true;
  let wrappedListener = null;
  if (tNode.type & 3 || eventTargetResolver) {
    wrappedListener ??= wrapListener(tNode, lView, listenerFn);
    const hasCoalescedDomEvent = listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, listenerFn, wrappedListener);
    if (hasCoalescedDomEvent) {
      processOutputs = false;
    }
  }
  if (processOutputs) {
    const outputConfig = tNode.outputs?.[eventName];
    const hostDirectiveOutputConfig = tNode.hostDirectiveOutputs?.[eventName];
    if (hostDirectiveOutputConfig && hostDirectiveOutputConfig.length) {
      for (let i = 0; i < hostDirectiveOutputConfig.length; i += 2) {
        const index = hostDirectiveOutputConfig[i];
        const lookupName = hostDirectiveOutputConfig[i + 1];
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, lookupName, eventName, wrappedListener);
      }
    }
    if (outputConfig && outputConfig.length) {
      for (const index of outputConfig) {
        wrappedListener ??= wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, eventName, eventName, wrappedListener);
      }
    }
  }
}
function ɵɵnextContext(level = 1) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextContextImpl)(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === '*') {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function ɵɵprojectionDef(projectionSlots) {
  const componentNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.newArray)(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareNoDirectiveHostTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNodeAsNotParent)();
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const isNodeCreationMode = !hydrationInfo || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isInSkipHydrationBlock)();
  const componentHostNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNode)(fallbackTNode);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLContainer)(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, undefined, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function ɵɵcontentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
  return ɵɵcontentQuery;
}
function ɵɵviewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
  return ɵɵviewQuery;
}
function ɵɵqueryRefresh(queryList) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const queryIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentQueryIndex)();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isCreationMode)(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function ɵɵloadQuery() {
  return loadQueryInternal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentQueryIndex)());
}
function ɵɵcontentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
  return ɵɵcontentQuerySignal;
}
function ɵɵviewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
  return ɵɵviewQuerySignal;
}
function ɵɵqueryAdvance(indexOffset = 1) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentQueryIndex)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentQueryIndex)() + indexOffset);
}
function ɵɵreference(index) {
  const contextLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getContextLView)();
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(contextLView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index);
}
function toTStylingRange(prev, next) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(prev, 0, 32767);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(next, 0, 32767);
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(previous, 0, 32767);
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumberInRange)(next, 0, 32767);
  return tStylingRange & ~131068 | next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(tStylingRange, 'expected number');
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstUpdatePass)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayIndexOf)(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == 'string' && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayIndexOf)(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {
    return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayIndexOf)(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
const parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(text, index, end, 58);
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(text, index, end, 59);
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(typeof text === 'string', true, 'String expected here');
  throw (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' + text.substring(index, index + 1) + '<<]' + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function ɵɵstyleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return ɵɵstyleProp;
}
function ɵɵclassProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return ɵɵclassProp;
}
function ɵɵstyleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function ɵɵclassMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)()];
    updateStyling(tView, tNode, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(staticPrefix.endsWith(';'), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.concatStringsWithSpace)(staticPrefix, value ? value : '');
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertFirstUpdatePass)(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)()];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(tNode, 'TNode expected');
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentDirectiveDef)(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== undefined) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return undefined;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = undefined;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(currentDirective, 'expected to be defined');
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef) break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === 'number') {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === undefined ? [] : ['', stylingKey];
          }
          (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === undefined ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet, stringParser, value) {
  if (value == null || value === '') return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === 'object') {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === 'string') {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.throwError)('Unsupported styling type: ' + typeof unwrappedValue + ' (' + unwrappedValue + ')');
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== '' && !stringKey.includes(' ')) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArraySet)(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(oldIndex, 999, 'Are we stuck in infinite loop?');
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(newIndex, 999, 'Are we stuck in infinite loop?');
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;
    let setKey = null;
    let setValue = undefined;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(newKey, 'Expecting to have a valid key');
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : undefined;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = undefined;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY : undefined;
    }
    let currentValue = isStylingMap ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayGet)(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : undefined;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayGet)(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.keyValueArrayGet)(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== undefined;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === '') ;else if (typeof suffix === 'string') {
    value = value + suffix;
  } else if (typeof value === 'object') {
    value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringify)(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function ɵɵtext(index, value = '') {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeCreationIndex)(lView, index);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.wasLastNodeCreated)()) {
    appendChild(tView, lView, textNative, tNode);
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
}
let _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(true);
  return createTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], value);
};
function locateOrCreateTextNodeImpl(tView, lView, tNode, value, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], value);
  }
  const hydrationInfo = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HYDRATION];
  const textNative = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(textNative, Node.TEXT_NODE, null, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(textNative);
  return textNative;
}
function enableLocateOrCreateTextNodeImpl() {
  _locateOrCreateTextNode = locateOrCreateTextNodeImpl;
}
function interpolationV(lView, values) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLessThan)(2, values.length, 'should have at least 3 values');
  let isBindingUpdated = false;
  let bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setBindingIndex)(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(values[i]) + (i + 1 !== values.length ? values[i + 1] : '');
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix = '') {
  const different = bindingUpdated(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)(), v0);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(2);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(3);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(4);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(5);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(6);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + i4 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(7);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + i4 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v5) + i5 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = '') {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.incrementBindingIndex)(8);
  return different ? prefix + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) + i0 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v1) + i1 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v2) + i2 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v3) + i3 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v4) + i4 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v5) + i5 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v6) + i6 + (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v7) + suffix : NO_CHANGE;
}
function ɵɵtextInterpolate(v0) {
  ɵɵtextInterpolate1('', v0);
  return ɵɵtextInterpolate;
}
function ɵɵtextInterpolate1(prefix, v0, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate1;
}
function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate2;
}
function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate3;
}
function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate4;
}
function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate5;
}
function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate6;
}
function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate7;
}
function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolate8;
}
function ɵɵtextInterpolateV(values) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)(), interpolated);
  }
  return ɵɵtextInterpolateV;
}
function textBindingInternal(lView, index, value) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertString)(value, 'Value should be a string');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotSame)(value, NO_CHANGE, 'value should not be NO_CHANGE');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, index);
  const element = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(index, lView);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(element, 'native element should exist');
  updateTextNode(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], element, value);
}
function ɵɵtwoWayProperty(propName, value, sanitizer) {
  if (isWritableSignal(value)) {
    value = value();
  }
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedTNode)();
    setPropertyAndInputs(tNode, lView, propName, value, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return ɵɵtwoWayProperty;
}
function ɵɵtwoWayBindingSet(target, value) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value);
  return canWrite;
}
function ɵɵtwoWayListener(eventName, listenerFn) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
  listenerInternal(tView, lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER], tNode, eventName, listenerFn);
  return ɵɵtwoWayListener;
}
const UNINITIALIZED_LET = {};
function ɵɵdeclareLet(index) {
  performanceMarkFeature('NgLet');
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setCurrentTNode)(tNode, false);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.store)(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return ɵɵdeclareLet;
}
function ɵɵstoreLet(value) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const index = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getSelectedIndex)();
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.store)(tView, lView, index, value);
  return value;
}
function ɵɵreadContextLet(index) {
  const contextLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getContextLView)();
  const value = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(contextLView, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(314, ngDevMode && 'Attempting to access a @let declaration whose value is not available yet');
  }
  return value;
}
function ɵɵattachSourceLocations(templatePath, locations) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER];
  const attributeName = 'data-ng-source-location';
  for (const [index, offset, line, column] of locations) {
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTNode)(tView, index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET);
    ngDevMode && assertTNodeType(tNode, 2);
    const node = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByIndex)(index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET, lView);
    if (!node.hasAttribute(attributeName)) {
      const attributeValue = `${templatePath}@o:${offset},l:${line},c:${column}`;
      renderer.setAttribute(node, attributeName, attributeValue);
    }
  }
}
function ɵɵinterpolate(v0) {
  return bindingUpdated((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.nextBindingIndex)(), v0) ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(v0) : NO_CHANGE;
}
function ɵɵinterpolate1(prefix, v0, suffix = '') {
  return interpolation1((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, suffix);
}
function ɵɵinterpolate2(prefix, v0, i0, v1, suffix = '') {
  return interpolation2((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, suffix);
}
function ɵɵinterpolate3(prefix, v0, i0, v1, i1, v2, suffix = '') {
  return interpolation3((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, suffix);
}
function ɵɵinterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix = '') {
  return interpolation4((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
}
function ɵɵinterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = '') {
  return interpolation5((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
}
function ɵɵinterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = '') {
  return interpolation6((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
}
function ɵɵinterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = '') {
  return interpolation7((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
}
function ɵɵinterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = '') {
  return interpolation8((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
}
function ɵɵinterpolateV(values) {
  return interpolationV((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), values);
}
function providersResolver(def, providers, isViewProviders) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  if (tView.firstCreatePass) {
    resolveProvider(providers, tView.data, tView.blueprint, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentDef)(def), isViewProviders);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
  provider = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
    }
  } else {
    const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
    const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)();
    let token = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider) ? provider : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(provider.provide);
    const providerFactory = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.providerToFactory)(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.runInInjectorProfilerContext)(injector, token, () => {
        (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.emitProviderConfiguredEvent)(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject, ngDevMode ? providerName(provider) : null);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory, provider);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider);
  const providerIsClassProvider = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isClassProvider)(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(indexInFactory, 'indexInFactory when registering multi factory destroy hook');
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory.componentProviders++;
  }
  return multiFactory.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item) return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, flags, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, _flags, _tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent, f, provider) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject, ngDevMode ? providerName(provider) : null);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent && !isViewProvider);
  return factory;
}
function providerName(provider) {
  if (Array.isArray(provider)) {
    return null;
  }
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isTypeProvider)(provider)) {
    return provider.name;
  } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isClassProvider)(provider)) {
    if (provider.provide instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken) {
      return `('${provider.provide.toString()}':${provider.useClass.name})`;
    }
    return provider.useClass.name;
  } else if (provider.provide instanceof _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken) {
    return provider.provide.toString();
  } else if (typeof provider.provide === 'string') {
    return provider.provide;
  } else {
    return null;
  }
}
function ɵɵProvidersFeature(providers, viewProviders) {
  return definition => {
    definition.providersResolver = (def, processProvidersFn) => providersResolver(def, processProvidersFn ? processProvidersFn(providers) : providers, false);
    if (viewProviders) {
      definition.viewProvidersResolver = (def, processProvidersFn) => providersResolver(def, processProvidersFn ? processProvidersFn(viewProviders) : viewProviders, true);
    }
  };
}
function ɵɵExternalStylesFeature(styleUrls) {
  return definition => {
    if (styleUrls.length < 1) {
      return;
    }
    definition.getExternalStyles = encapsulationId => {
      const urls = styleUrls.map(value => value + '?ngcomp' + (encapsulationId ? '=' + encodeURIComponent(encapsulationId) : '') + '&e=' + definition.encapsulation);
      return urls;
    };
  };
}
function ɵɵsetComponentScope(type, directives, pipes) {
  const def = type.ɵcmp;
  def.directiveDefs = extractDefListOrFactory(directives, extractDirectiveDef);
  def.pipeDefs = extractDefListOrFactory(pipes, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef);
}
function ɵɵsetNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(type);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === 'function') {
    return values;
  }
  const flattenValues = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(values);
  if (flattenValues.some(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isForwardRef)) {
    return () => flattenValues.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function ɵɵpureFunction0(slotOffset, pureFn) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, pureFn()) : getBinding(lView, bindingIndex);
}
function ɵɵpureFunction1(slotOffset, pureFn, exp) {
  return pureFunction1Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp);
}
function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2) {
  return pureFunction2Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp1, exp2);
}
function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3) {
  return pureFunction3Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, exp3);
}
function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, exp3, exp4);
}
function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) {
  const bindingIndex = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)() + slotOffset;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function ɵɵpureFunctionV(slotOffset, pureFn, exps) {
  return pureFunctionVInternal((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pureFn, exps);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertIndexInRange)(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function ɵɵpipe(index, pipeName) {
  const tView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getTView)();
  let pipeDef;
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getFactoryDef)(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)({
      injector: new NodeInjector((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(ɵɵdirectiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.store)(tView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectImplementation)(previousInjectImplementation);
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.setInjectorProfilerContext)(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter(pipe => pipe.name === name);
      if (pipes.length > 1) {
        console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const declarationLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : 'the imports of this module'}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const declarationLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : 'declared or imported in this module'}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function ɵɵpipeBind1(index, offset, v1) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function ɵɵpipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function ɵɵpipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET;
  const lView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getLView)();
  const pipeInstance = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getBindingRoot)(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[index].pure;
}
function ɵɵtemplateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function ɵɵgetComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function ɵsetClassDebugInfo(type, debugInfo) {
  const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
function ɵɵgetReplaceMetadataURL(id, timestamp, base) {
  const url = `./@ng/component?c=${id}&t=${encodeURIComponent(timestamp)}`;
  return new URL(url, base).href;
}
function ɵɵreplaceMetadata(type, applyMetadata, namespaces, locals, importMeta = null, id = null) {
  ngDevMode && assertComponentDef(type);
  const currentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type);
  applyMetadata.apply(null, [type, namespaces, ...locals]);
  const {
    newDef,
    oldDef
  } = mergeWithExistingDefinition(currentDef, (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type));
  type[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF] = newDef;
  if (oldDef.tView) {
    const trackedViews = getTrackedLViews().values();
    for (const root of trackedViews) {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isRootView)(root) && root[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT] === null) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, root);
      }
    }
  }
}
function mergeWithExistingDefinition(currentDef, newDef) {
  const clone = {
    ...currentDef
  };
  const replacement = Object.assign(currentDef, newDef, {
    directiveDefs: clone.directiveDefs,
    pipeDefs: clone.pipeDefs,
    setInput: clone.setInput,
    type: clone.type
  });
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertEqual)(replacement, currentDef, 'Expected definition to be merged in place');
  return {
    newDef: replacement,
    oldDef: clone
  };
}
function recreateMatchingLViews(importMeta, id, newDef, oldDef, rootLView) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(oldDef.tView, 'Expected a component definition that has been instantiated at least once');
  const tView = rootLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW];
  if (tView === oldDef.tView) {
    ngDevMode && assertComponentDef(oldDef.type);
    recreateLView(importMeta, id, newDef, oldDef, rootLView);
    return;
  }
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const current = rootLView[i];
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(current)) {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST])) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST]);
      }
      for (let j = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; j < current.length; j++) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[j]);
      }
    } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(current)) {
      recreateMatchingLViews(importMeta, id, newDef, oldDef, current);
    }
  }
}
function clearRendererCache(factory, def) {
  factory.componentReplaced?.(def.id);
}
function recreateLView(importMeta, id, newDef, oldDef, lView) {
  const instance = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTEXT];
  let host = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HOST];
  const parentLView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertLView)(parentLView);
  const tNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
  ngDevMode && assertTNodeType(tNode, 2);
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertNotEqual)(newDef, oldDef, 'Expected different component definition');
  const zone = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INJECTOR$1].get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone, null);
  const recreate = () => {
    if (oldDef.encapsulation === ViewEncapsulation.ShadowDom || oldDef.encapsulation === ViewEncapsulation.ExperimentalIsolatedShadowDom) {
      const newHost = host.cloneNode(false);
      host.replaceWith(newHost);
      host = newHost;
    }
    const newTView = getOrCreateComponentTView(newDef);
    const newLView = createLView(parentLView, newTView, instance, getInitialLViewFlagsFromDef(newDef), host, tNode, null, null, null, null, null);
    replaceLViewInTree(parentLView, lView, newLView, tNode.index);
    destroyLView(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
    const rendererFactory = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT].rendererFactory;
    clearRendererCache(rendererFactory, oldDef);
    newLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RENDERER] = rendererFactory.createRenderer(host, newDef);
    removeViewFromDOM(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW], lView);
    resetProjectionState(tNode);
    renderView(newTView, newLView, instance);
    refreshView(newTView, newLView, newTView.template, instance);
  };
  if (zone === null) {
    executeWithInvalidateFallback(importMeta, id, recreate);
  } else {
    zone.run(() => executeWithInvalidateFallback(importMeta, id, recreate));
  }
}
function executeWithInvalidateFallback(importMeta, id, callback) {
  try {
    callback();
  } catch (e) {
    const error = e;
    if (id !== null && error.message) {
      const toLog = error.message + (error.stack ? '\n' + error.stack : '');
      importMeta?.hot?.send?.('angular:invalidate', {
        id,
        message: toLog,
        error: true
      });
    }
    throw e;
  }
}
function replaceLViewInTree(parentLView, oldLView, newLView, index) {
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.HEADER_OFFSET; i < parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].bindingStartIndex; i++) {
    const current = parentLView[i];
    if (((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLView)(current) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(current)) && current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] === oldLView) {
      current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = newLView;
      break;
    }
  }
  if (parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD] === oldLView) {
    parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_HEAD] = newLView;
  }
  if (parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL] === oldLView) {
    parentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CHILD_TAIL] = newLView;
  }
  newLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = oldLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT];
  oldLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NEXT] = null;
  parentLView[index] = newLView;
}
function resetProjectionState(tNode) {
  if (tNode.projection !== null) {
    for (const current of tNode.projection) {
      if (isTNodeShape(current)) {
        current.projectionNext = null;
        current.flags &= ~2;
      }
    }
    tNode.projection = null;
  }
}
const angularCoreEnv = /*#__PURE__*/(() => ({
  'ɵɵanimateEnter': ɵɵanimateEnter,
  'ɵɵanimateEnterListener': ɵɵanimateEnterListener,
  'ɵɵanimateLeave': ɵɵanimateLeave,
  'ɵɵanimateLeaveListener': ɵɵanimateLeaveListener,
  'ɵɵattribute': ɵɵattribute,
  'ɵɵdefineComponent': ɵɵdefineComponent,
  'ɵɵdefineDirective': ɵɵdefineDirective,
  'ɵɵdefineInjectable': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"],
  'ɵɵdefineInjector': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"],
  'ɵɵdefineNgModule': ɵɵdefineNgModule,
  'ɵɵdefinePipe': ɵɵdefinePipe,
  'ɵɵdirectiveInject': ɵɵdirectiveInject,
  'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,
  'ɵɵinject': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"],
  'ɵɵinjectAttribute': ɵɵinjectAttribute,
  'ɵɵinvalidFactory': ɵɵinvalidFactory,
  'ɵɵinvalidFactoryDep': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵinvalidFactoryDep"],
  'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,
  'ɵɵresetView': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵresetView"],
  'ɵɵHostDirectivesFeature': ɵɵHostDirectivesFeature,
  'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,
  'ɵɵProvidersFeature': ɵɵProvidersFeature,
  'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,
  'ɵɵExternalStylesFeature': ɵɵExternalStylesFeature,
  'ɵɵnextContext': ɵɵnextContext,
  'ɵɵnamespaceHTML': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceHTML"],
  'ɵɵnamespaceMathML': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceMathML"],
  'ɵɵnamespaceSVG': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵnamespaceSVG"],
  'ɵɵenableBindings': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵenableBindings"],
  'ɵɵdisableBindings': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdisableBindings"],
  'ɵɵelementStart': ɵɵelementStart,
  'ɵɵelementEnd': ɵɵelementEnd,
  'ɵɵelement': ɵɵelement,
  'ɵɵelementContainerStart': ɵɵelementContainerStart,
  'ɵɵelementContainerEnd': ɵɵelementContainerEnd,
  'ɵɵdomElement': ɵɵdomElement,
  'ɵɵdomElementStart': ɵɵdomElementStart,
  'ɵɵdomElementEnd': ɵɵdomElementEnd,
  'ɵɵdomElementContainer': ɵɵdomElementContainer,
  'ɵɵdomElementContainerStart': ɵɵdomElementContainerStart,
  'ɵɵdomElementContainerEnd': ɵɵdomElementContainerEnd,
  'ɵɵdomTemplate': ɵɵdomTemplate,
  'ɵɵdomListener': ɵɵdomListener,
  'ɵɵelementContainer': ɵɵelementContainer,
  'ɵɵpureFunction0': ɵɵpureFunction0,
  'ɵɵpureFunction1': ɵɵpureFunction1,
  'ɵɵpureFunction2': ɵɵpureFunction2,
  'ɵɵpureFunction3': ɵɵpureFunction3,
  'ɵɵpureFunction4': ɵɵpureFunction4,
  'ɵɵpureFunction5': ɵɵpureFunction5,
  'ɵɵpureFunction6': ɵɵpureFunction6,
  'ɵɵpureFunction7': ɵɵpureFunction7,
  'ɵɵpureFunction8': ɵɵpureFunction8,
  'ɵɵpureFunctionV': ɵɵpureFunctionV,
  'ɵɵgetCurrentView': ɵɵgetCurrentView,
  'ɵɵrestoreView': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵrestoreView"],
  'ɵɵlistener': ɵɵlistener,
  'ɵɵprojection': ɵɵprojection,
  'ɵɵsyntheticHostProperty': ɵɵsyntheticHostProperty,
  'ɵɵsyntheticHostListener': ɵɵsyntheticHostListener,
  'ɵɵpipeBind1': ɵɵpipeBind1,
  'ɵɵpipeBind2': ɵɵpipeBind2,
  'ɵɵpipeBind3': ɵɵpipeBind3,
  'ɵɵpipeBind4': ɵɵpipeBind4,
  'ɵɵpipeBindV': ɵɵpipeBindV,
  'ɵɵprojectionDef': ɵɵprojectionDef,
  'ɵɵdomProperty': ɵɵdomProperty,
  'ɵɵariaProperty': ɵɵariaProperty,
  'ɵɵproperty': ɵɵproperty,
  'ɵɵcontrol': ɵɵcontrol,
  'ɵɵcontrolCreate': ɵɵcontrolCreate,
  'ɵɵpipe': ɵɵpipe,
  'ɵɵqueryRefresh': ɵɵqueryRefresh,
  'ɵɵqueryAdvance': ɵɵqueryAdvance,
  'ɵɵviewQuery': ɵɵviewQuery,
  'ɵɵviewQuerySignal': ɵɵviewQuerySignal,
  'ɵɵloadQuery': ɵɵloadQuery,
  'ɵɵcontentQuery': ɵɵcontentQuery,
  'ɵɵcontentQuerySignal': ɵɵcontentQuerySignal,
  'ɵɵreference': ɵɵreference,
  'ɵɵclassMap': ɵɵclassMap,
  'ɵɵstyleMap': ɵɵstyleMap,
  'ɵɵstyleProp': ɵɵstyleProp,
  'ɵɵclassProp': ɵɵclassProp,
  'ɵɵadvance': ɵɵadvance,
  'ɵɵtemplate': ɵɵtemplate,
  'ɵɵconditional': ɵɵconditional,
  'ɵɵconditionalCreate': ɵɵconditionalCreate,
  'ɵɵconditionalBranchCreate': ɵɵconditionalBranchCreate,
  'ɵɵdefer': ɵɵdefer,
  'ɵɵdeferWhen': ɵɵdeferWhen,
  'ɵɵdeferOnIdle': ɵɵdeferOnIdle,
  'ɵɵdeferOnImmediate': ɵɵdeferOnImmediate,
  'ɵɵdeferOnTimer': ɵɵdeferOnTimer,
  'ɵɵdeferOnHover': ɵɵdeferOnHover,
  'ɵɵdeferOnInteraction': ɵɵdeferOnInteraction,
  'ɵɵdeferOnViewport': ɵɵdeferOnViewport,
  'ɵɵdeferPrefetchWhen': ɵɵdeferPrefetchWhen,
  'ɵɵdeferPrefetchOnIdle': ɵɵdeferPrefetchOnIdle,
  'ɵɵdeferPrefetchOnImmediate': ɵɵdeferPrefetchOnImmediate,
  'ɵɵdeferPrefetchOnTimer': ɵɵdeferPrefetchOnTimer,
  'ɵɵdeferPrefetchOnHover': ɵɵdeferPrefetchOnHover,
  'ɵɵdeferPrefetchOnInteraction': ɵɵdeferPrefetchOnInteraction,
  'ɵɵdeferPrefetchOnViewport': ɵɵdeferPrefetchOnViewport,
  'ɵɵdeferHydrateWhen': ɵɵdeferHydrateWhen,
  'ɵɵdeferHydrateNever': ɵɵdeferHydrateNever,
  'ɵɵdeferHydrateOnIdle': ɵɵdeferHydrateOnIdle,
  'ɵɵdeferHydrateOnImmediate': ɵɵdeferHydrateOnImmediate,
  'ɵɵdeferHydrateOnTimer': ɵɵdeferHydrateOnTimer,
  'ɵɵdeferHydrateOnHover': ɵɵdeferHydrateOnHover,
  'ɵɵdeferHydrateOnInteraction': ɵɵdeferHydrateOnInteraction,
  'ɵɵdeferHydrateOnViewport': ɵɵdeferHydrateOnViewport,
  'ɵɵdeferEnableTimerScheduling': ɵɵdeferEnableTimerScheduling,
  'ɵɵrepeater': ɵɵrepeater,
  'ɵɵrepeaterCreate': ɵɵrepeaterCreate,
  'ɵɵrepeaterTrackByIndex': ɵɵrepeaterTrackByIndex,
  'ɵɵrepeaterTrackByIdentity': ɵɵrepeaterTrackByIdentity,
  'ɵɵcomponentInstance': ɵɵcomponentInstance,
  'ɵɵtext': ɵɵtext,
  'ɵɵtextInterpolate': ɵɵtextInterpolate,
  'ɵɵtextInterpolate1': ɵɵtextInterpolate1,
  'ɵɵtextInterpolate2': ɵɵtextInterpolate2,
  'ɵɵtextInterpolate3': ɵɵtextInterpolate3,
  'ɵɵtextInterpolate4': ɵɵtextInterpolate4,
  'ɵɵtextInterpolate5': ɵɵtextInterpolate5,
  'ɵɵtextInterpolate6': ɵɵtextInterpolate6,
  'ɵɵtextInterpolate7': ɵɵtextInterpolate7,
  'ɵɵtextInterpolate8': ɵɵtextInterpolate8,
  'ɵɵtextInterpolateV': ɵɵtextInterpolateV,
  'ɵɵi18n': ɵɵi18n,
  'ɵɵi18nAttributes': ɵɵi18nAttributes,
  'ɵɵi18nExp': ɵɵi18nExp,
  'ɵɵi18nStart': ɵɵi18nStart,
  'ɵɵi18nEnd': ɵɵi18nEnd,
  'ɵɵi18nApply': ɵɵi18nApply,
  'ɵɵi18nPostprocess': ɵɵi18nPostprocess,
  'ɵɵresolveWindow': ɵɵresolveWindow,
  'ɵɵresolveDocument': ɵɵresolveDocument,
  'ɵɵresolveBody': ɵɵresolveBody,
  'ɵɵsetComponentScope': ɵɵsetComponentScope,
  'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,
  'ɵɵregisterNgModuleType': registerNgModuleType,
  'ɵɵgetComponentDepsFactory': ɵɵgetComponentDepsFactory,
  'ɵsetClassDebugInfo': ɵsetClassDebugInfo,
  'ɵɵdeclareLet': ɵɵdeclareLet,
  'ɵɵstoreLet': ɵɵstoreLet,
  'ɵɵreadContextLet': ɵɵreadContextLet,
  'ɵɵattachSourceLocations': ɵɵattachSourceLocations,
  'ɵɵinterpolate': ɵɵinterpolate,
  'ɵɵinterpolate1': ɵɵinterpolate1,
  'ɵɵinterpolate2': ɵɵinterpolate2,
  'ɵɵinterpolate3': ɵɵinterpolate3,
  'ɵɵinterpolate4': ɵɵinterpolate4,
  'ɵɵinterpolate5': ɵɵinterpolate5,
  'ɵɵinterpolate6': ɵɵinterpolate6,
  'ɵɵinterpolate7': ɵɵinterpolate7,
  'ɵɵinterpolate8': ɵɵinterpolate8,
  'ɵɵinterpolateV': ɵɵinterpolateV,
  'ɵɵsanitizeHtml': ɵɵsanitizeHtml,
  'ɵɵsanitizeStyle': ɵɵsanitizeStyle,
  'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,
  'ɵɵsanitizeScript': ɵɵsanitizeScript,
  'ɵɵvalidateAttribute': ɵɵvalidateAttribute,
  'ɵɵsanitizeUrl': ɵɵsanitizeUrl,
  'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl,
  'ɵɵtrustConstantHtml': ɵɵtrustConstantHtml,
  'ɵɵtrustConstantResourceUrl': ɵɵtrustConstantResourceUrl,
  'forwardRef': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.forwardRef,
  'resolveForwardRef': _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef,
  'ɵɵtwoWayProperty': ɵɵtwoWayProperty,
  'ɵɵtwoWayBindingSet': ɵɵtwoWayBindingSet,
  'ɵɵtwoWayListener': ɵɵtwoWayListener,
  'ɵɵreplaceMetadata': ɵɵreplaceMetadata,
  'ɵɵgetReplaceMetadataURL': ɵɵgetReplaceMetadataURL
}))();
let jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error('Provided value for `defaultEncapsulation` can not be changed once it has been set.');
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error('Provided value for `preserveWhitespaces` can not be changed once it has been set.');
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function resetJitOptions() {
  jitOptions = null;
}
const moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({
    moduleType,
    ngModule
  });
}
let flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const {
          moduleType,
          ngModule
        } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== undefined) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(moduleType, 'Required value moduleType');
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDefined)(ngModule, 'Required value ngModule');
  const declarations = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'NgModule',
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/ɵmod.js`, {
          type: moduleType,
          bootstrap: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.bootstrap || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef),
          declarations: declarations.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef),
          imports: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef).map(expandModuleWithProviders),
          exports: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'NgModule',
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/ɵfac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
          imports: [(ngModule.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef), (ngModule.exports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'NgModule',
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/ɵinj.js`, meta);
      }
      return ngInjectorDef;
    },
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location) {
  const prefix = `Unexpected "${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}" found in the "declarations" array of the`;
  const suffix = `"${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}" is marked as standalone and can't be declared ` + 'in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?';
  return `${prefix} ${location}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType)) return;
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(moduleType)) return;
  verifiedNgModule.set(moduleType, true);
  moduleType = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(moduleType);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach(declarationType => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [...declarations.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef), ...(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(imports.map(computeCombinedExports)).map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, 'NgModule');
  if (ngModule) {
    ngModule.imports && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.deepForEach)(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.deepForEach)(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join('\n'));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (!def) {
      errors.push(`Unexpected value '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}' declared by the module '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (def?.standalone) {
      const location = `"${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const kind = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) && 'component' || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type) && 'directive' || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type) && 'pipe';
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} from ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules = [existingModule, moduleType].map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError).sort();
        errors.push(`Type ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` + `Please consider moving ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` + `You can also create a new NgModule that exports and includes ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(type)) {
      errors.push(`Component ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type)) {
      errors.push(`${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} cannot be used as an entry component.`);
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(type)) {
      errors.push(`The \`${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}\` class is a standalone component, which can ` + `not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` ` + `function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule) {
    type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
    const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto = Object.getPrototypeOf(decorator.type);
        if (proto.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
let ownerNgModule = /*#__PURE__*/new WeakMap();
let verifiedNgModule = /*#__PURE__*/new WeakMap();
function resetCompiledComponents() {
  ownerNgModule = new WeakMap();
  verifiedNgModule = new WeakMap();
  moduleQueue.length = 0;
  GENERATED_COMP_IDS.clear();
}
function computeCombinedExports(type) {
  type = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(type);
  const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(maybeUnwrapFn(ngModuleDef.exports).map(type => {
    const ngModuleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(type);
    if (ngModuleDef) {
      verifySemanticsOfNgModuleDef(type, false);
      return computeCombinedExports(type);
    } else {
      return type;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(ngModule.declarations || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach(declaration => {
    declaration = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(declaration);
    if (declaration.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_DIR_DEF) && !declaration.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map(dir => dir.hasOwnProperty(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF) ? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(dir) : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(dir)).filter(def => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(pipe));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    const scope = depsTracker.getNgModuleScope(type);
    const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDefOrThrow)(type);
    return {
      schemas: def.schemas || null,
      ...scope
    };
  } else if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isStandalone)(type)) {
    const directiveDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(type) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: new Set(),
          pipes: new Set()
        },
        exported: {
          directives: new Set([type]),
          pipes: new Set()
        }
      };
    }
    const pipeDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: new Set(),
          pipes: new Set()
        },
        exported: {
          directives: new Set(),
          pipes: new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (ɵmod property)`);
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
let compilationDepth = 0;
function compileComponent(type, metadata) {
  (typeof ngDevMode === 'undefined' || ngDevMode) && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.initNgDevMode)();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'component',
          type: type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join('\n'));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === undefined) {
          if (options !== null && options.preserveWhitespaces !== undefined) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === undefined) {
          if (options !== null && options.defaultEncapsulation !== undefined) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const baseMeta = directiveMetadata(type, metadata);
        const meta = {
          ...baseMeta,
          typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),
          template: metadata.template || '',
          preserveWhitespaces,
          styles: typeof metadata.styles === 'string' ? [metadata.styles] : metadata.styles || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
          animations: metadata.animations,
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          viewProviders: metadata.viewProviders || null,
          hasDirectiveDependencies: !baseMeta.isStandalone || metadata.imports != null && metadata.imports.length > 0
        };
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (meta.isStandalone) {
            const imports = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.flatten)(metadata.imports || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY);
            const {
              directiveDefs,
              pipeDefs
            } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (meta.isStandalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)} but is only valid on a component that is standalone.`);
          }
        } else if (meta.isStandalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    set: def => {
      ngComponentDef = def;
    },
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  const directiveDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.directives].map(p => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(p) || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(p)).filter(d => d !== null);
  };
  const pipeDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.pipes].map(p => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getPipeDef)(p)).filter(d => d !== null);
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== undefined;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'directive',
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/ɵdir.js`;
  const compiler = getCompilerFacade({
    usage: 0,
    kind: 'directive',
    type
  });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return {
    metadata: facade,
    sourceMapUrl
  };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'directive',
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/ɵfac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type: type,
    selector: metadata.selector !== undefined ? metadata.selector : null,
    host: metadata.host || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    propMetadata: propMetadata,
    inputs: metadata.inputs || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
    outputs: metadata.outputs || _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: {
      usesOnChanges: reflect.hasLifecycleHook(type, 'ngOnChanges')
    },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: metadata.standalone === undefined ? true : !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map(directive => typeof directive === 'function' ? {
      directive
    } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getDirectiveDef)(parent) && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === 'string' ? splitByComma(selector) : (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveForwardRef)(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName: propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach(ann => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of ` + `"${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.stringifyForError)(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === undefined ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === 'ContentChild' || name === 'ContentChildren';
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === 'ViewChild' || name === 'ViewChildren';
}
function isInputAnnotation(value) {
  return value.ngMetadataName === 'Input';
}
function splitByComma(value) {
  return value.split(',').map(piece => piece.trim());
}
const LIFECYCLE_HOOKS = ['ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked', 'ngAfterContentInit', 'ngAfterContentChecked'];
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === 'Output' || metadataName === 'HostBinding' || metadataName === 'HostListener') {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'pipe',
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/ɵfac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: 'pipe',
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/ɵpipe.js`, metadata);
      }
      return ngPipeDef;
    },
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type: type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== undefined ? meta.pure : true,
    isStandalone: meta.standalone === undefined ? true : !!meta.standalone
  };
}
const Directive = /*#__PURE__*/makeDecorator('Directive', (dir = {}) => dir, undefined, undefined, (type, meta) => compileDirective(type, meta));
const Component = /*#__PURE__*/makeDecorator('Component', (c = {}) => ({
  changeDetection: ChangeDetectionStrategy.Default,
  ...c
}), Directive, undefined, (type, meta) => compileComponent(type, meta));
const Pipe = /*#__PURE__*/makeDecorator('Pipe', p => ({
  pure: true,
  ...p
}), undefined, undefined, (type, meta) => compilePipe(type, meta));
const Input = /*#__PURE__*/makePropDecorator('Input', arg => {
  if (!arg) {
    return {};
  }
  return typeof arg === 'string' ? {
    alias: arg
  } : arg;
});
const Output = /*#__PURE__*/makePropDecorator('Output', alias => ({
  alias
}));
const HostBinding = /*#__PURE__*/makePropDecorator('HostBinding', hostPropertyName => ({
  hostPropertyName
}));
const HostListener = /*#__PURE__*/makePropDecorator('HostListener', (eventName, args) => ({
  eventName,
  args
}));
const NgModule = /*#__PURE__*/makeDecorator('NgModule', ngModule => ngModule, undefined, undefined, (type, meta) => compileNgModule(type, meta));
class ModuleWithComponentFactories {
  ngModuleFactory;
  componentFactories;
  constructor(ngModuleFactory, componentFactories) {
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
}
let Compiler = /*#__PURE__*/(() => {
  class Compiler {
    compileModuleSync(moduleType) {
      return new NgModuleFactory(moduleType);
    }
    compileModuleAsync(moduleType) {
      return Promise.resolve(this.compileModuleSync(moduleType));
    }
    compileModuleAndAllComponentsSync(moduleType) {
      const ngModuleFactory = this.compileModuleSync(moduleType);
      const moduleDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNgModuleDef)(moduleType);
      const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
        const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentDef)(declaration);
        componentDef && factories.push(new ComponentFactory(componentDef));
        return factories;
      }, []);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    compileModuleAndAllComponentsAsync(moduleType) {
      return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
    }
    clearCache() {}
    clearCacheFor(type) {}
    getModuleId(moduleType) {
      return undefined;
    }
    static ɵfac = function Compiler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || Compiler)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: Compiler,
      factory: Compiler.ɵfac,
      providedIn: 'root'
    });
  }
  return Compiler;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const COMPILER_OPTIONS = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'compilerOptions' : '');
class CompilerFactory {}
const CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
let consecutiveMicrotaskNotifications = 0;
let stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(103, 'Angular could not stabilize because there were endless change notifications within the browser event loop. ' + 'The stack from the last several notifications: \n' + stackFromLastFewNotifications.join('\n'));
  }
}
let ChangeDetectionSchedulerImpl = /*#__PURE__*/(() => {
  class ChangeDetectionSchedulerImpl {
    applicationErrorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_APPLICATION_ERROR_HANDLER);
    appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(ApplicationRef);
    taskService = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasksInternal);
    ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone);
    zonelessEnabled = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ZONELESS_ENABLED);
    tracing = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(TracingService, {
      optional: true
    });
    zoneIsDefined = typeof Zone !== 'undefined' && !!Zone.root.run;
    schedulerTickApplyArgs = [{
      data: {
        '__scheduler_tick__': true
      }
    }];
    subscriptions = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subscription();
    angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.angularZoneInstanceIdProperty) : null;
    scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SCHEDULE_IN_ROOT_ZONE, {
      optional: true
    }) ?? false);
    cancelScheduledCallback = null;
    useMicrotaskScheduler = false;
    runningTick = false;
    pendingRenderTaskId = null;
    constructor() {
      this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
        const task = this.taskService.add();
        if (!this.runningTick) {
          this.cleanup();
          if (!this.zonelessEnabled || this.appRef.includeAllTestViews) {
            this.taskService.remove(task);
            return;
          }
        }
        this.switchToMicrotaskScheduler();
        this.taskService.remove(task);
      }));
      this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
        if (!this.runningTick) {
          this.cleanup();
        }
      }));
    }
    switchToMicrotaskScheduler() {
      this.ngZone.runOutsideAngular(() => {
        const task = this.taskService.add();
        this.useMicrotaskScheduler = true;
        queueMicrotask(() => {
          this.useMicrotaskScheduler = false;
          this.taskService.remove(task);
        });
      });
    }
    notify(source) {
      if (!this.zonelessEnabled && source === 5) {
        return;
      }
      switch (source) {
        case 0:
          {
            this.appRef.dirtyFlags |= 2;
            break;
          }
        case 3:
        case 2:
        case 4:
        case 5:
        case 1:
          {
            this.appRef.dirtyFlags |= 4;
            break;
          }
        case 6:
          {
            this.appRef.dirtyFlags |= 2;
            break;
          }
        case 12:
          {
            this.appRef.dirtyFlags |= 16;
            break;
          }
        case 13:
          {
            this.appRef.dirtyFlags |= 2;
            break;
          }
        case 11:
          {
            break;
          }
        case 9:
        case 8:
        case 7:
        case 10:
        default:
          {
            this.appRef.dirtyFlags |= 8;
          }
      }
      this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;
      if (!this.shouldScheduleTick()) {
        return;
      }
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (this.useMicrotaskScheduler) {
          trackMicrotaskNotificationForDebugging();
        } else {
          consecutiveMicrotaskNotifications = 0;
          stackFromLastFewNotifications.length = 0;
        }
      }
      const scheduleCallback = this.useMicrotaskScheduler ? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.scheduleCallbackWithMicrotask : _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.scheduleCallbackWithRafRace;
      this.pendingRenderTaskId = this.taskService.add();
      if (this.scheduleInRootZone) {
        this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));
      } else {
        this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));
      }
    }
    shouldScheduleTick() {
      if (this.appRef.destroyed) {
        return false;
      }
      if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
        return false;
      }
      if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.angularZoneInstanceIdProperty + this.angularZoneId)) {
        return false;
      }
      return true;
    }
    tick() {
      if (this.runningTick || this.appRef.destroyed) {
        return;
      }
      if (this.appRef.dirtyFlags === 0) {
        this.cleanup();
        return;
      }
      if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {
        this.appRef.dirtyFlags |= 1;
      }
      const task = this.taskService.add();
      try {
        this.ngZone.run(() => {
          this.runningTick = true;
          this.appRef._tick();
        }, undefined, this.schedulerTickApplyArgs);
      } catch (e) {
        this.applicationErrorHandler(e);
      } finally {
        this.taskService.remove(task);
        this.cleanup();
      }
    }
    ngOnDestroy() {
      this.subscriptions.unsubscribe();
      this.cleanup();
    }
    cleanup() {
      this.runningTick = false;
      this.cancelScheduledCallback?.();
      this.cancelScheduledCallback = null;
      if (this.pendingRenderTaskId !== null) {
        const taskId = this.pendingRenderTaskId;
        this.pendingRenderTaskId = null;
        this.taskService.remove(taskId);
      }
    }
    static ɵfac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ChangeDetectionSchedulerImpl)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      token: ChangeDetectionSchedulerImpl,
      factory: ChangeDetectionSchedulerImpl.ɵfac,
      providedIn: 'root'
    });
  }
  return ChangeDetectionSchedulerImpl;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [], null);
})();
function provideZonelessChangeDetection() {
  performanceMarkFeature('NgZoneless');
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && typeof Zone !== 'undefined' && Zone) {
    const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(914, `The application is using zoneless change detection, but is still loading Zone.js. ` + `Consider removing Zone.js to get the full benefits of zoneless. ` + `In applications using the Angular CLI, Zone.js is typically included in the "polyfills" section of the angular.json file.`);
    console.warn(message);
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([...provideZonelessChangeDetectionInternal(), typeof ngDevMode === 'undefined' || ngDevMode ? [{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PROVIDED_ZONELESS,
    useValue: true
  }] : []]);
}
function provideZonelessChangeDetectionInternal() {
  return [{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectionScheduler,
    useExisting: ChangeDetectionSchedulerImpl
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NgZone,
    useClass: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NoopNgZone
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ZONELESS_ENABLED,
    useValue: true
  }];
}
function getGlobalLocale() {
  if (typeof ngI18nClosureMode !== 'undefined' && ngI18nClosureMode && typeof goog !== 'undefined' && goog.LOCALE !== 'en') {
    return goog.LOCALE;
  } else {
    return typeof $localize !== 'undefined' && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
const LOCALE_ID = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'LocaleId' : '', {
  factory: () => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(LOCALE_ID, {
    optional: true,
    skipSelf: true
  }) || getGlobalLocale()
});
const DEFAULT_CURRENCY_CODE = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DefaultCurrencyCode' : '', {
  factory: () => USD_CURRENCY_CODE
});
const TRANSLATIONS = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Translations' : '');
const TRANSLATIONS_FORMAT = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'TranslationsFormat' : '');
var MissingTranslationStrategy = /*#__PURE__*/function (MissingTranslationStrategy) {
  MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
  MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
  MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
  return MissingTranslationStrategy;
}(MissingTranslationStrategy || {});
class DebugEventListener {
  name;
  callback;
  constructor(name, callback) {
    this.name = name;
    this.callback = callback;
  }
}
function asNativeElements(debugEls) {
  return debugEls.map(el => el.nativeElement);
}
class DebugNode {
  nativeNode;
  constructor(nativeNode) {
    this.nativeNode = nativeNode;
  }
  get parent() {
    const parent = this.nativeNode.parentNode;
    return parent ? new DebugElement(parent) : null;
  }
  get injector() {
    return getInjector(this.nativeNode);
  }
  get componentInstance() {
    const nativeElement = this.nativeNode;
    return nativeElement && (getComponent(nativeElement) || getOwningComponent(nativeElement));
  }
  get context() {
    return getComponent(this.nativeNode) || getContext(this.nativeNode);
  }
  get listeners() {
    return getListeners(this.nativeNode).filter(listener => listener.type === 'dom');
  }
  get references() {
    return getLocalRefs(this.nativeNode);
  }
  get providerTokens() {
    return getInjectionTokens(this.nativeNode);
  }
}
class DebugElement extends DebugNode {
  constructor(nativeNode) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertDomNode)(nativeNode);
    super(nativeNode);
  }
  get nativeElement() {
    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
  }
  get name() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView !== null) {
      const tData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
      const tNode = tData[context.nodeIndex];
      return tNode.value;
    } else {
      return this.nativeNode.nodeName;
    }
  }
  get properties() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tData = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data;
    const tNode = tData[context.nodeIndex];
    const properties = {};
    copyDomProperties(this.nativeElement, properties);
    collectPropertyBindings(properties, tNode, lView, tData);
    return properties;
  }
  get attributes() {
    const attributes = {};
    const element = this.nativeElement;
    if (!element) {
      return attributes;
    }
    const context = getLContext(element);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tNodeAttrs = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[context.nodeIndex].attrs;
    const lowercaseTNodeAttrs = [];
    if (tNodeAttrs) {
      let i = 0;
      while (i < tNodeAttrs.length) {
        const attrName = tNodeAttrs[i];
        if (typeof attrName !== 'string') break;
        const attrValue = tNodeAttrs[i + 1];
        attributes[attrName] = attrValue;
        lowercaseTNodeAttrs.push(attrName.toLowerCase());
        i += 2;
      }
    }
    for (const attr of element.attributes) {
      if (!lowercaseTNodeAttrs.includes(attr.name)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  get styles() {
    const element = this.nativeElement;
    return element?.style ?? {};
  }
  get classes() {
    const result = {};
    const element = this.nativeElement;
    const className = element.className;
    const classes = typeof className !== 'string' ? className.baseVal.split(' ') : className.split(' ');
    classes.forEach(value => result[value] = true);
    return result;
  }
  get childNodes() {
    const childNodes = this.nativeNode.childNodes;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  get children() {
    const nativeElement = this.nativeElement;
    if (!nativeElement) return [];
    const childNodes = nativeElement.children;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  query(predicate) {
    const results = this.queryAll(predicate);
    return results[0] || null;
  }
  queryAll(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, true);
    return matches;
  }
  queryAllNodes(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, false);
    return matches;
  }
  triggerEventHandler(eventName, eventObj) {
    const node = this.nativeNode;
    const invokedListeners = [];
    this.listeners.forEach(listener => {
      if (listener.name === eventName) {
        const callback = listener.callback;
        callback.call(node, eventObj);
        invokedListeners.push(callback);
      }
    });
    if (typeof node.eventListeners === 'function') {
      node.eventListeners(eventName).forEach(listener => {
        if (listener.toString().indexOf('__ngUnwrap__') !== -1) {
          const unwrappedListener = listener('__ngUnwrap__');
          return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
        }
      });
    }
  }
}
function copyDomProperties(element, properties) {
  if (element) {
    let obj = Object.getPrototypeOf(element);
    const NodePrototype = Node.prototype;
    while (obj !== null && obj !== NodePrototype) {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      for (let key in descriptors) {
        if (!key.startsWith('__') && !key.startsWith('on')) {
          const value = element[key];
          if (isPrimitiveValue(value)) {
            properties[key] = value;
          }
        }
      }
      obj = Object.getPrototypeOf(obj);
    }
  }
}
function isPrimitiveValue(value) {
  return typeof value === 'string' || typeof value === 'boolean' || typeof value === 'number' || value === null;
}
function _queryAll(parentElement, predicate, matches, elementsOnly) {
  const context = getLContext(parentElement.nativeNode);
  const lView = context ? context.lView : null;
  if (lView !== null) {
    const parentTNode = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[context.nodeIndex];
    _queryNodeChildren(parentTNode, lView, predicate, matches, elementsOnly, parentElement.nativeNode);
  } else {
    _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
  }
}
function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertTNodeForLView)(tNode, lView);
  const nativeNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getNativeByTNodeOrNull)(tNode, lView);
  if (tNode.type & (3 | 8)) {
    _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isComponentHost)(tNode)) {
      const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.getComponentLViewByIndex)(tNode.index, lView);
      if (componentView && componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild) {
        _queryNodeChildren(componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else {
      if (tNode.child) {
        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
      nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
    }
    const nodeOrContainer = lView[tNode.index];
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.isLContainer)(nodeOrContainer)) {
      _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.type & 4) {
    const lContainer = lView[tNode.index];
    _addQueryMatch(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.NATIVE], predicate, matches, elementsOnly, rootNativeNode);
    _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
  } else if (tNode.type & 16) {
    const componentView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.T_HOST];
    const head = componentHost.projection[tNode.projection];
    if (Array.isArray(head)) {
      for (let nativeNode of head) {
        _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (head) {
      const nextLView = componentView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PARENT];
      const nextTNode = nextLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].data[head.index];
      _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.child) {
    _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
  }
  if (rootNativeNode !== nativeNode) {
    const nextTNode = tNode.flags & 2 ? tNode.projectionNext : tNode.next;
    if (nextTNode) {
      _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const childView = lContainer[i];
    const firstChild = childView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.TVIEW].firstChild;
    if (firstChild) {
      _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
  if (rootNativeNode !== nativeNode) {
    const debugNode = getDebugNode(nativeNode);
    if (!debugNode) {
      return;
    }
    if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    }
  }
}
function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
  const nodes = parentNode.childNodes;
  const length = nodes.length;
  for (let i = 0; i < length; i++) {
    const node = nodes[i];
    const debugNode = getDebugNode(node);
    if (debugNode) {
      if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
      _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
    }
  }
}
function collectPropertyBindings(properties, tNode, lView, tData) {
  let bindingIndexes = tNode.propertyBindings;
  if (bindingIndexes !== null) {
    for (let i = 0; i < bindingIndexes.length; i++) {
      const bindingIndex = bindingIndexes[i];
      const propMetadata = tData[bindingIndex];
      const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
      const propertyName = metadataParts[0];
      if (metadataParts.length > 1) {
        let value = metadataParts[1];
        for (let j = 1; j < metadataParts.length - 1; j++) {
          value += (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.renderStringify)(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
        }
        properties[propertyName] = value;
      } else {
        properties[propertyName] = lView[bindingIndex];
      }
    }
  }
}
const NG_DEBUG_PROPERTY = '__ng_debug__';
function getDebugNode(nativeNode) {
  if (nativeNode instanceof Node) {
    if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
      nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
    }
    return nativeNode[NG_DEBUG_PROPERTY];
  }
  return null;
}


/***/ },

/***/ 37580
/*!******************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/core.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ANIMATION_MODULE_TYPE: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ANIMATION_MODULE_TYPE),
/* harmony export */   APP_BOOTSTRAP_LISTENER: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER),
/* harmony export */   APP_ID: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID),
/* harmony export */   APP_INITIALIZER: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_INITIALIZER),
/* harmony export */   ApplicationInitStatus: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationInitStatus),
/* harmony export */   ApplicationModule: () => (/* binding */ ApplicationModule),
/* harmony export */   ApplicationRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef),
/* harmony export */   Attribute: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Attribute),
/* harmony export */   COMPILER_OPTIONS: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.COMPILER_OPTIONS),
/* harmony export */   CSP_NONCE: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CSP_NONCE),
/* harmony export */   CUSTOM_ELEMENTS_SCHEMA: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CUSTOM_ELEMENTS_SCHEMA),
/* harmony export */   ChangeDetectionStrategy: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy),
/* harmony export */   ChangeDetectorRef: () => (/* binding */ ChangeDetectorRef),
/* harmony export */   Compiler: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Compiler),
/* harmony export */   CompilerFactory: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CompilerFactory),
/* harmony export */   Component: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Component),
/* harmony export */   ComponentFactory: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory$1),
/* harmony export */   ComponentFactoryResolver: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactoryResolver),
/* harmony export */   ComponentRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentRef),
/* harmony export */   ContentChild: () => (/* binding */ ContentChild),
/* harmony export */   ContentChildren: () => (/* binding */ ContentChildren),
/* harmony export */   DEFAULT_CURRENCY_CODE: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CURRENCY_CODE),
/* harmony export */   DOCUMENT: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT),
/* harmony export */   DebugElement: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DebugElement),
/* harmony export */   DebugEventListener: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DebugEventListener),
/* harmony export */   DebugNode: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DebugNode),
/* harmony export */   DefaultIterableDiffer: () => (/* binding */ DefaultIterableDiffer),
/* harmony export */   DestroyRef: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DestroyRef),
/* harmony export */   Directive: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Directive),
/* harmony export */   ENVIRONMENT_INITIALIZER: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER),
/* harmony export */   ElementRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ElementRef),
/* harmony export */   EmbeddedViewRef: () => (/* binding */ EmbeddedViewRef),
/* harmony export */   EnvironmentInjector: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EnvironmentInjector),
/* harmony export */   ErrorHandler: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ErrorHandler),
/* harmony export */   EventEmitter: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EventEmitter),
/* harmony export */   HOST_TAG_NAME: () => (/* binding */ HOST_TAG_NAME),
/* harmony export */   Host: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Host),
/* harmony export */   HostAttributeToken: () => (/* binding */ HostAttributeToken),
/* harmony export */   HostBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.HostBinding),
/* harmony export */   HostListener: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.HostListener),
/* harmony export */   INJECTOR: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INJECTOR),
/* harmony export */   Inject: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Inject),
/* harmony export */   Injectable: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable),
/* harmony export */   InjectionToken: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken),
/* harmony export */   Injector: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector),
/* harmony export */   Input: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Input),
/* harmony export */   IterableDiffers: () => (/* binding */ IterableDiffers),
/* harmony export */   KeyValueDiffers: () => (/* binding */ KeyValueDiffers),
/* harmony export */   LOCALE_ID: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LOCALE_ID),
/* harmony export */   MAX_ANIMATION_TIMEOUT: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MAX_ANIMATION_TIMEOUT),
/* harmony export */   MissingTranslationStrategy: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MissingTranslationStrategy),
/* harmony export */   ModuleWithComponentFactories: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ModuleWithComponentFactories),
/* harmony export */   NO_ERRORS_SCHEMA: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NO_ERRORS_SCHEMA),
/* harmony export */   NgModule: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModule),
/* harmony export */   NgModuleFactory: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory$1),
/* harmony export */   NgModuleRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleRef$1),
/* harmony export */   NgZone: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone),
/* harmony export */   Optional: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Optional),
/* harmony export */   Output: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Output),
/* harmony export */   OutputEmitterRef: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.OutputEmitterRef),
/* harmony export */   PLATFORM_ID: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID),
/* harmony export */   PLATFORM_INITIALIZER: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_INITIALIZER),
/* harmony export */   PendingTasks: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasks),
/* harmony export */   Pipe: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Pipe),
/* harmony export */   PlatformRef: () => (/* binding */ PlatformRef),
/* harmony export */   Query: () => (/* binding */ Query),
/* harmony export */   QueryList: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.QueryList),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   REQUEST_CONTEXT: () => (/* binding */ REQUEST_CONTEXT),
/* harmony export */   RESPONSE_INIT: () => (/* binding */ RESPONSE_INIT),
/* harmony export */   Renderer2: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Renderer2),
/* harmony export */   RendererFactory2: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RendererFactory2),
/* harmony export */   RendererStyleFlags2: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RendererStyleFlags2),
/* harmony export */   Sanitizer: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Sanitizer),
/* harmony export */   SecurityContext: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SecurityContext),
/* harmony export */   Self: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Self),
/* harmony export */   SimpleChange: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SimpleChange),
/* harmony export */   SkipSelf: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SkipSelf),
/* harmony export */   TRANSLATIONS: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TRANSLATIONS),
/* harmony export */   TRANSLATIONS_FORMAT: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TRANSLATIONS_FORMAT),
/* harmony export */   TemplateRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TemplateRef),
/* harmony export */   Testability: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Testability),
/* harmony export */   TestabilityRegistry: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TestabilityRegistry),
/* harmony export */   TransferState: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TransferState),
/* harmony export */   Type: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Type),
/* harmony export */   VERSION: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION),
/* harmony export */   Version: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Version),
/* harmony export */   ViewChild: () => (/* binding */ ViewChild),
/* harmony export */   ViewChildren: () => (/* binding */ ViewChildren),
/* harmony export */   ViewContainerRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef),
/* harmony export */   ViewEncapsulation: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation),
/* harmony export */   ViewRef: () => (/* binding */ ViewRef),
/* harmony export */   afterEveryRender: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.afterEveryRender),
/* harmony export */   afterNextRender: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.afterNextRender),
/* harmony export */   afterRenderEffect: () => (/* binding */ afterRenderEffect),
/* harmony export */   asNativeElements: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.asNativeElements),
/* harmony export */   assertInInjectionContext: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext),
/* harmony export */   assertNotInReactiveContext: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertNotInReactiveContext),
/* harmony export */   assertPlatform: () => (/* binding */ assertPlatform),
/* harmony export */   booleanAttribute: () => (/* binding */ booleanAttribute),
/* harmony export */   computed: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.computed),
/* harmony export */   contentChild: () => (/* binding */ contentChild),
/* harmony export */   contentChildren: () => (/* binding */ contentChildren),
/* harmony export */   createComponent: () => (/* binding */ createComponent),
/* harmony export */   createEnvironmentInjector: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createEnvironmentInjector),
/* harmony export */   createNgModule: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createNgModule),
/* harmony export */   createNgModuleRef: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createNgModuleRef),
/* harmony export */   createPlatform: () => (/* binding */ createPlatform),
/* harmony export */   createPlatformFactory: () => (/* binding */ createPlatformFactory),
/* harmony export */   destroyPlatform: () => (/* binding */ destroyPlatform),
/* harmony export */   effect: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   enableProdMode: () => (/* binding */ enableProdMode),
/* harmony export */   enableProfiling: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableProfiling),
/* harmony export */   forwardRef: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.forwardRef),
/* harmony export */   getDebugNode: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDebugNode),
/* harmony export */   getModuleFactory: () => (/* binding */ getModuleFactory),
/* harmony export */   getNgModuleById: () => (/* binding */ getNgModuleById),
/* harmony export */   getPlatform: () => (/* binding */ getPlatform),
/* harmony export */   importProvidersFrom: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.importProvidersFrom),
/* harmony export */   inject: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   input: () => (/* binding */ input),
/* harmony export */   inputBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inputBinding),
/* harmony export */   isDevMode: () => (/* binding */ isDevMode),
/* harmony export */   isSignal: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isSignal),
/* harmony export */   isStandalone: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isStandalone),
/* harmony export */   isWritableSignal: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isWritableSignal),
/* harmony export */   linkedSignal: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignal),
/* harmony export */   makeEnvironmentProviders: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders),
/* harmony export */   makeStateKey: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makeStateKey),
/* harmony export */   mergeApplicationConfig: () => (/* binding */ mergeApplicationConfig),
/* harmony export */   model: () => (/* binding */ model),
/* harmony export */   numberAttribute: () => (/* binding */ numberAttribute),
/* harmony export */   output: () => (/* binding */ output),
/* harmony export */   outputBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.outputBinding),
/* harmony export */   platformCore: () => (/* binding */ platformCore),
/* harmony export */   provideAppInitializer: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideAppInitializer),
/* harmony export */   provideBrowserGlobalErrorListeners: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideBrowserGlobalErrorListeners),
/* harmony export */   provideCheckNoChangesConfig: () => (/* binding */ provideCheckNoChangesConfig),
/* harmony export */   provideEnvironmentInitializer: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideEnvironmentInitializer),
/* harmony export */   provideNgReflectAttributes: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideNgReflectAttributes),
/* harmony export */   providePlatformInitializer: () => (/* binding */ providePlatformInitializer),
/* harmony export */   provideStabilityDebugging: () => (/* binding */ provideStabilityDebugging),
/* harmony export */   provideZoneChangeDetection: () => (/* binding */ provideZoneChangeDetection),
/* harmony export */   provideZonelessChangeDetection: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetection),
/* harmony export */   reflectComponentType: () => (/* binding */ reflectComponentType),
/* harmony export */   resolveForwardRef: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveForwardRef),
/* harmony export */   resource: () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.resource),
/* harmony export */   runInInjectionContext: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runInInjectionContext),
/* harmony export */   setTestabilityGetter: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setTestabilityGetter),
/* harmony export */   signal: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signal),
/* harmony export */   twoWayBinding: () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.twoWayBinding),
/* harmony export */   untracked: () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.untracked),
/* harmony export */   viewChild: () => (/* binding */ viewChild),
/* harmony export */   viewChildren: () => (/* binding */ viewChildren),
/* harmony export */   "ɵANIMATIONS_DISABLED": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ANIMATIONS_DISABLED),
/* harmony export */   "ɵAcxChangeDetectionStrategy": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AcxChangeDetectionStrategy),
/* harmony export */   "ɵAcxViewEncapsulation": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AcxViewEncapsulation),
/* harmony export */   "ɵAfterRenderManager": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderManager),
/* harmony export */   "ɵCLIENT_RENDER_MODE_FLAG": () => (/* binding */ CLIENT_RENDER_MODE_FLAG),
/* harmony export */   "ɵCONTAINER_HEADER_OFFSET": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_HEADER_OFFSET),
/* harmony export */   "ɵCONTROL": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵCONTROL"]),
/* harmony export */   "ɵChangeDetectionScheduler": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionScheduler),
/* harmony export */   "ɵComponentFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory$1),
/* harmony export */   "ɵConsole": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console),
/* harmony export */   "ɵDEFAULT_LOCALE_ID": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE_ID),
/* harmony export */   "ɵDEFER_BLOCK_CONFIG": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_CONFIG),
/* harmony export */   "ɵDEFER_BLOCK_DEPENDENCY_INTERCEPTOR": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_DEPENDENCY_INTERCEPTOR),
/* harmony export */   "ɵDEHYDRATED_BLOCK_REGISTRY": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEHYDRATED_BLOCK_REGISTRY),
/* harmony export */   "ɵDeferBlockBehavior": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DeferBlockBehavior),
/* harmony export */   "ɵDeferBlockState": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DeferBlockState),
/* harmony export */   "ɵENABLE_ROOT_COMPONENT_BOOTSTRAP": () => (/* binding */ ENABLE_ROOT_COMPONENT_BOOTSTRAP),
/* harmony export */   "ɵEVENT_REPLAY_QUEUE": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EVENT_REPLAY_QUEUE),
/* harmony export */   "ɵEffectScheduler": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.EffectScheduler),
/* harmony export */   "ɵFramework": () => (/* binding */ Framework),
/* harmony export */   "ɵHydrationStatus": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.HydrationStatus),
/* harmony export */   "ɵIMAGE_CONFIG": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IMAGE_CONFIG),
/* harmony export */   "ɵIMAGE_CONFIG_DEFAULTS": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IMAGE_CONFIG_DEFAULTS),
/* harmony export */   "ɵINJECTOR_SCOPE": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INJECTOR_SCOPE),
/* harmony export */   "ɵINPUT_SIGNAL_BRAND_WRITE_TYPE": () => (/* binding */ ɵINPUT_SIGNAL_BRAND_WRITE_TYPE),
/* harmony export */   "ɵINTERNAL_APPLICATION_ERROR_HANDLER": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER),
/* harmony export */   "ɵIS_ENABLED_BLOCKING_INITIAL_NAVIGATION": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_ENABLED_BLOCKING_INITIAL_NAVIGATION),
/* harmony export */   "ɵIS_HYDRATION_DOM_REUSE_ENABLED": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED),
/* harmony export */   "ɵIS_INCREMENTAL_HYDRATION_ENABLED": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_INCREMENTAL_HYDRATION_ENABLED),
/* harmony export */   "ɵJSACTION_BLOCK_ELEMENT_MAP": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_BLOCK_ELEMENT_MAP),
/* harmony export */   "ɵJSACTION_EVENT_CONTRACT": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_EVENT_CONTRACT),
/* harmony export */   "ɵLContext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LContext),
/* harmony export */   "ɵLocaleDataIndex": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LocaleDataIndex),
/* harmony export */   "ɵNG_COMP_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_COMP_DEF),
/* harmony export */   "ɵNG_DIR_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_DIR_DEF),
/* harmony export */   "ɵNG_ELEMENT_ID": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_ELEMENT_ID),
/* harmony export */   "ɵNG_INJ_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_INJ_DEF),
/* harmony export */   "ɵNG_MOD_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_MOD_DEF),
/* harmony export */   "ɵNG_PIPE_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_PIPE_DEF),
/* harmony export */   "ɵNG_PROV_DEF": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NG_PROV_DEF),
/* harmony export */   "ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR),
/* harmony export */   "ɵNO_CHANGE": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NO_CHANGE),
/* harmony export */   "ɵNgModuleFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory),
/* harmony export */   "ɵNoopNgZone": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NoopNgZone),
/* harmony export */   "ɵPERFORMANCE_MARK_PREFIX": () => (/* binding */ PERFORMANCE_MARK_PREFIX),
/* harmony export */   "ɵPROVIDED_NG_ZONE": () => (/* binding */ PROVIDED_NG_ZONE),
/* harmony export */   "ɵPROVIDED_ZONELESS": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PROVIDED_ZONELESS),
/* harmony export */   "ɵPendingTasksInternal": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasksInternal),
/* harmony export */   "ɵProfilerEvent": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ProfilerEvent),
/* harmony export */   "ɵR3Injector": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.R3Injector),
/* harmony export */   "ɵReflectionCapabilities": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ReflectionCapabilities),
/* harmony export */   "ɵRender3ComponentFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory),
/* harmony export */   "ɵRender3ComponentRef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentRef$1),
/* harmony export */   "ɵRender3NgModuleRef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleRef),
/* harmony export */   "ɵResourceImpl": () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.ResourceImpl),
/* harmony export */   "ɵRuntimeError": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError),
/* harmony export */   "ɵSIGNAL": () => (/* reexport safe */ _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL),
/* harmony export */   "ɵSSR_CONTENT_INTEGRITY_MARKER": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SSR_CONTENT_INTEGRITY_MARKER),
/* harmony export */   "ɵTESTABILITY": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TESTABILITY),
/* harmony export */   "ɵTESTABILITY_GETTER": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TESTABILITY_GETTER),
/* harmony export */   "ɵTimerScheduler": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TimerScheduler),
/* harmony export */   "ɵTracingAction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TracingAction),
/* harmony export */   "ɵTracingService": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TracingService),
/* harmony export */   "ɵViewRef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewRef),
/* harmony export */   "ɵXSS_SECURITY_URL": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.XSS_SECURITY_URL),
/* harmony export */   "ɵZONELESS_ENABLED": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ZONELESS_ENABLED),
/* harmony export */   "ɵ_sanitizeHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__._sanitizeHtml),
/* harmony export */   "ɵ_sanitizeUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__._sanitizeUrl),
/* harmony export */   "ɵallLeavingAnimations": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.allLeavingAnimations),
/* harmony export */   "ɵallowSanitizationBypassAndThrow": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.allowSanitizationBypassAndThrow),
/* harmony export */   "ɵannotateForHydration": () => (/* binding */ annotateForHydration),
/* harmony export */   "ɵassertType": () => (/* binding */ ɵassertType),
/* harmony export */   "ɵbypassSanitizationTrustHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustHtml),
/* harmony export */   "ɵbypassSanitizationTrustResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustResourceUrl),
/* harmony export */   "ɵbypassSanitizationTrustScript": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustScript),
/* harmony export */   "ɵbypassSanitizationTrustStyle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustStyle),
/* harmony export */   "ɵbypassSanitizationTrustUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.bypassSanitizationTrustUrl),
/* harmony export */   "ɵclearResolutionOfComponentResourcesQueue": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.clearResolutionOfComponentResourcesQueue),
/* harmony export */   "ɵcompileComponent": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileComponent),
/* harmony export */   "ɵcompileDirective": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileDirective),
/* harmony export */   "ɵcompileNgModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileNgModule),
/* harmony export */   "ɵcompileNgModuleDefs": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compileNgModuleDefs),
/* harmony export */   "ɵcompileNgModuleFactory": () => (/* binding */ compileNgModuleFactory),
/* harmony export */   "ɵcompilePipe": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.compilePipe),
/* harmony export */   "ɵcontrolUpdate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵcontrolUpdate"]),
/* harmony export */   "ɵconvertToBitFlags": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToBitFlags),
/* harmony export */   "ɵcreateInjector": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createInjector),
/* harmony export */   "ɵcreateOrReusePlatformInjector": () => (/* binding */ createOrReusePlatformInjector),
/* harmony export */   "ɵdefaultIterableDiffers": () => (/* binding */ defaultIterableDiffers),
/* harmony export */   "ɵdefaultKeyValueDiffers": () => (/* binding */ defaultKeyValueDiffers),
/* harmony export */   "ɵdepsTracker": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.depsTracker),
/* harmony export */   "ɵdevModeEqual": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.devModeEqual),
/* harmony export */   "ɵdisableProfiling": () => (/* binding */ disableProfiling),
/* harmony export */   "ɵenableProfiling": () => (/* binding */ enableProfiling),
/* harmony export */   "ɵencapsulateResourceError": () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.encapsulateResourceError),
/* harmony export */   "ɵfindLocaleData": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.findLocaleData),
/* harmony export */   "ɵflushModuleScopingQueueAsMuchAsPossible": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.flushModuleScopingQueueAsMuchAsPossible),
/* harmony export */   "ɵformatRuntimeError": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError),
/* harmony export */   "ɵgenerateStandaloneInDeclarationsError": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.generateStandaloneInDeclarationsError),
/* harmony export */   "ɵgetAsyncClassMetadataFn": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getAsyncClassMetadataFn),
/* harmony export */   "ɵgetClosestComponentName": () => (/* binding */ getClosestComponentName),
/* harmony export */   "ɵgetComponentDef": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef),
/* harmony export */   "ɵgetDebugNode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDebugNode),
/* harmony export */   "ɵgetDeferBlocks": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDeferBlocks),
/* harmony export */   "ɵgetDirectives": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDirectives),
/* harmony export */   "ɵgetDocument": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDocument),
/* harmony export */   "ɵgetHostElement": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getHostElement),
/* harmony export */   "ɵgetInjectableDef": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getInjectableDef),
/* harmony export */   "ɵgetLContext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLContext),
/* harmony export */   "ɵgetLocaleCurrencyCode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLocaleCurrencyCode),
/* harmony export */   "ɵgetLocalePluralCase": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLocalePluralCase),
/* harmony export */   "ɵgetOutputDestroyRef": () => (/* reexport safe */ _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.getOutputDestroyRef),
/* harmony export */   "ɵgetSanitizationBypassType": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getSanitizationBypassType),
/* harmony export */   "ɵgetTransferState": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getTransferState),
/* harmony export */   "ɵgetUnknownElementStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵgetUnknownElementStrictMode"]),
/* harmony export */   "ɵgetUnknownPropertyStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵgetUnknownPropertyStrictMode"]),
/* harmony export */   "ɵglobal": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__._global),
/* harmony export */   "ɵinferTagNameFromDefinition": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inferTagNameFromDefinition),
/* harmony export */   "ɵinjectChangeDetectorRef": () => (/* binding */ injectChangeDetectorRef),
/* harmony export */   "ɵinternalCreateApplication": () => (/* binding */ internalCreateApplication),
/* harmony export */   "ɵinternalProvideZoneChangeDetection": () => (/* binding */ internalProvideZoneChangeDetection),
/* harmony export */   "ɵisBoundToModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isBoundToModule),
/* harmony export */   "ɵisComponentDefPendingResolution": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isComponentDefPendingResolution),
/* harmony export */   "ɵisEnvironmentProviders": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isEnvironmentProviders),
/* harmony export */   "ɵisInjectable": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isInjectable),
/* harmony export */   "ɵisNgModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isNgModule),
/* harmony export */   "ɵisPromise": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isPromise),
/* harmony export */   "ɵisSubscribable": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isSubscribable),
/* harmony export */   "ɵisViewDirty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isViewDirty),
/* harmony export */   "ɵmarkForRefresh": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.markForRefresh),
/* harmony export */   "ɵnoSideEffects": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.noSideEffects),
/* harmony export */   "ɵpatchComponentDefWithScope": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.patchComponentDefWithScope),
/* harmony export */   "ɵperformanceMarkFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature),
/* harmony export */   "ɵpromiseWithResolvers": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.promiseWithResolvers),
/* harmony export */   "ɵprovideZonelessChangeDetectionInternal": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetectionInternal),
/* harmony export */   "ɵpublishExternalGlobalUtil": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishExternalGlobalUtil),
/* harmony export */   "ɵreadHydrationInfo": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.readHydrationInfo),
/* harmony export */   "ɵregisterLocaleData": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.registerLocaleData),
/* harmony export */   "ɵrenderDeferBlockState": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.renderDeferBlockState),
/* harmony export */   "ɵresetCompiledComponents": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resetCompiledComponents),
/* harmony export */   "ɵresetIncrementalHydrationEnabledWarnedForTests": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resetIncrementalHydrationEnabledWarnedForTests),
/* harmony export */   "ɵresetJitOptions": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resetJitOptions),
/* harmony export */   "ɵresolveComponentResources": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveComponentResources),
/* harmony export */   "ɵrestoreComponentResolutionQueue": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.restoreComponentResolutionQueue),
/* harmony export */   "ɵsetAllowDuplicateNgModuleIdsForTest": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setAllowDuplicateNgModuleIdsForTest),
/* harmony export */   "ɵsetAlternateWeakRefImpl": () => (/* reexport safe */ _weak_ref_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__.setAlternateWeakRefImpl),
/* harmony export */   "ɵsetClassDebugInfo": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassDebugInfo"]),
/* harmony export */   "ɵsetClassMetadata": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata),
/* harmony export */   "ɵsetClassMetadataAsync": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadataAsync),
/* harmony export */   "ɵsetCurrentInjector": () => (/* reexport safe */ _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__.setCurrentInjector),
/* harmony export */   "ɵsetDocument": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setDocument),
/* harmony export */   "ɵsetInjectorProfilerContext": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setInjectorProfilerContext),
/* harmony export */   "ɵsetLocaleId": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setLocaleId),
/* harmony export */   "ɵsetUnknownElementStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵsetUnknownElementStrictMode"]),
/* harmony export */   "ɵsetUnknownPropertyStrictMode": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵsetUnknownPropertyStrictMode"]),
/* harmony export */   "ɵstartMeasuring": () => (/* binding */ startMeasuring),
/* harmony export */   "ɵstopMeasuring": () => (/* binding */ stopMeasuring),
/* harmony export */   "ɵstore": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.store),
/* harmony export */   "ɵstringify": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify),
/* harmony export */   "ɵtransitiveScopesFor": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.transitiveScopesFor),
/* harmony export */   "ɵtriggerResourceLoading": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.triggerResourceLoading),
/* harmony export */   "ɵtruncateMiddle": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.truncateMiddle),
/* harmony export */   "ɵunregisterLocaleData": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.unregisterAllLocaleData),
/* harmony export */   "ɵunwrapSafeValue": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.unwrapSafeValue),
/* harmony export */   "ɵunwrapWritableSignal": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵunwrapWritableSignal"]),
/* harmony export */   "ɵwithDomHydration": () => (/* binding */ withDomHydration),
/* harmony export */   "ɵwithEventReplay": () => (/* binding */ withEventReplay),
/* harmony export */   "ɵwithI18nSupport": () => (/* binding */ withI18nSupport),
/* harmony export */   "ɵwithIncrementalHydration": () => (/* binding */ withIncrementalHydration),
/* harmony export */   "ɵɵExternalStylesFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵExternalStylesFeature"]),
/* harmony export */   "ɵɵFactoryTarget": () => (/* binding */ FactoryTarget),
/* harmony export */   "ɵɵHostDirectivesFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵHostDirectivesFeature"]),
/* harmony export */   "ɵɵInheritDefinitionFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵInheritDefinitionFeature"]),
/* harmony export */   "ɵɵNgOnChangesFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]),
/* harmony export */   "ɵɵProvidersFeature": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵProvidersFeature"]),
/* harmony export */   "ɵɵadvance": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"]),
/* harmony export */   "ɵɵanimateEnter": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateEnter"]),
/* harmony export */   "ɵɵanimateEnterListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateEnterListener"]),
/* harmony export */   "ɵɵanimateLeave": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateLeave"]),
/* harmony export */   "ɵɵanimateLeaveListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵanimateLeaveListener"]),
/* harmony export */   "ɵɵariaProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵariaProperty"]),
/* harmony export */   "ɵɵattachSourceLocations": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵattachSourceLocations"]),
/* harmony export */   "ɵɵattribute": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵattribute"]),
/* harmony export */   "ɵɵclassMap": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵclassMap"]),
/* harmony export */   "ɵɵclassProp": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵclassProp"]),
/* harmony export */   "ɵɵcomponentInstance": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcomponentInstance"]),
/* harmony export */   "ɵɵconditional": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵconditional"]),
/* harmony export */   "ɵɵconditionalBranchCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵconditionalBranchCreate"]),
/* harmony export */   "ɵɵconditionalCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵconditionalCreate"]),
/* harmony export */   "ɵɵcontentQuery": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontentQuery"]),
/* harmony export */   "ɵɵcontentQuerySignal": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontentQuerySignal"]),
/* harmony export */   "ɵɵcontrol": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontrol"]),
/* harmony export */   "ɵɵcontrolCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵcontrolCreate"]),
/* harmony export */   "ɵɵdeclareLet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeclareLet"]),
/* harmony export */   "ɵɵdefer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefer"]),
/* harmony export */   "ɵɵdeferEnableTimerScheduling": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferEnableTimerScheduling"]),
/* harmony export */   "ɵɵdeferHydrateNever": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateNever"]),
/* harmony export */   "ɵɵdeferHydrateOnHover": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnHover"]),
/* harmony export */   "ɵɵdeferHydrateOnIdle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnIdle"]),
/* harmony export */   "ɵɵdeferHydrateOnImmediate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnImmediate"]),
/* harmony export */   "ɵɵdeferHydrateOnInteraction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnInteraction"]),
/* harmony export */   "ɵɵdeferHydrateOnTimer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnTimer"]),
/* harmony export */   "ɵɵdeferHydrateOnViewport": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateOnViewport"]),
/* harmony export */   "ɵɵdeferHydrateWhen": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferHydrateWhen"]),
/* harmony export */   "ɵɵdeferOnHover": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnHover"]),
/* harmony export */   "ɵɵdeferOnIdle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnIdle"]),
/* harmony export */   "ɵɵdeferOnImmediate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnImmediate"]),
/* harmony export */   "ɵɵdeferOnInteraction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnInteraction"]),
/* harmony export */   "ɵɵdeferOnTimer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnTimer"]),
/* harmony export */   "ɵɵdeferOnViewport": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferOnViewport"]),
/* harmony export */   "ɵɵdeferPrefetchOnHover": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnHover"]),
/* harmony export */   "ɵɵdeferPrefetchOnIdle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnIdle"]),
/* harmony export */   "ɵɵdeferPrefetchOnImmediate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnImmediate"]),
/* harmony export */   "ɵɵdeferPrefetchOnInteraction": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnInteraction"]),
/* harmony export */   "ɵɵdeferPrefetchOnTimer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnTimer"]),
/* harmony export */   "ɵɵdeferPrefetchOnViewport": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchOnViewport"]),
/* harmony export */   "ɵɵdeferPrefetchWhen": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferPrefetchWhen"]),
/* harmony export */   "ɵɵdeferWhen": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdeferWhen"]),
/* harmony export */   "ɵɵdefineComponent": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]),
/* harmony export */   "ɵɵdefineDirective": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]),
/* harmony export */   "ɵɵdefineInjectable": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]),
/* harmony export */   "ɵɵdefineInjector": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]),
/* harmony export */   "ɵɵdefineNgModule": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]),
/* harmony export */   "ɵɵdefinePipe": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefinePipe"]),
/* harmony export */   "ɵɵdirectiveInject": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"]),
/* harmony export */   "ɵɵdisableBindings": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdisableBindings"]),
/* harmony export */   "ɵɵdomElement": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElement"]),
/* harmony export */   "ɵɵdomElementContainer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementContainer"]),
/* harmony export */   "ɵɵdomElementContainerEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementContainerEnd"]),
/* harmony export */   "ɵɵdomElementContainerStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementContainerStart"]),
/* harmony export */   "ɵɵdomElementEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementEnd"]),
/* harmony export */   "ɵɵdomElementStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomElementStart"]),
/* harmony export */   "ɵɵdomListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomListener"]),
/* harmony export */   "ɵɵdomProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomProperty"]),
/* harmony export */   "ɵɵdomTemplate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdomTemplate"]),
/* harmony export */   "ɵɵelement": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"]),
/* harmony export */   "ɵɵelementContainer": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainer"]),
/* harmony export */   "ɵɵelementContainerEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerEnd"]),
/* harmony export */   "ɵɵelementContainerStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerStart"]),
/* harmony export */   "ɵɵelementEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]),
/* harmony export */   "ɵɵelementStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"]),
/* harmony export */   "ɵɵenableBindings": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵenableBindings"]),
/* harmony export */   "ɵɵgetComponentDepsFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetComponentDepsFactory"]),
/* harmony export */   "ɵɵgetCurrentView": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]),
/* harmony export */   "ɵɵgetInheritedFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetInheritedFactory"]),
/* harmony export */   "ɵɵgetReplaceMetadataURL": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetReplaceMetadataURL"]),
/* harmony export */   "ɵɵi18n": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18n"]),
/* harmony export */   "ɵɵi18nApply": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nApply"]),
/* harmony export */   "ɵɵi18nAttributes": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nAttributes"]),
/* harmony export */   "ɵɵi18nEnd": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nEnd"]),
/* harmony export */   "ɵɵi18nExp": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nExp"]),
/* harmony export */   "ɵɵi18nPostprocess": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nPostprocess"]),
/* harmony export */   "ɵɵi18nStart": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵi18nStart"]),
/* harmony export */   "ɵɵinject": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"]),
/* harmony export */   "ɵɵinjectAttribute": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinjectAttribute"]),
/* harmony export */   "ɵɵinterpolate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate"]),
/* harmony export */   "ɵɵinterpolate1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate1"]),
/* harmony export */   "ɵɵinterpolate2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate2"]),
/* harmony export */   "ɵɵinterpolate3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate3"]),
/* harmony export */   "ɵɵinterpolate4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate4"]),
/* harmony export */   "ɵɵinterpolate5": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate5"]),
/* harmony export */   "ɵɵinterpolate6": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate6"]),
/* harmony export */   "ɵɵinterpolate7": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate7"]),
/* harmony export */   "ɵɵinterpolate8": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolate8"]),
/* harmony export */   "ɵɵinterpolateV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinterpolateV"]),
/* harmony export */   "ɵɵinvalidFactory": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinvalidFactory"]),
/* harmony export */   "ɵɵinvalidFactoryDep": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinvalidFactoryDep"]),
/* harmony export */   "ɵɵlistener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]),
/* harmony export */   "ɵɵloadQuery": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵloadQuery"]),
/* harmony export */   "ɵɵnamespaceHTML": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceHTML"]),
/* harmony export */   "ɵɵnamespaceMathML": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceMathML"]),
/* harmony export */   "ɵɵnamespaceSVG": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵnamespaceSVG"]),
/* harmony export */   "ɵɵnextContext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]),
/* harmony export */   "ɵɵngDeclareClassMetadata": () => (/* binding */ ɵɵngDeclareClassMetadata),
/* harmony export */   "ɵɵngDeclareClassMetadataAsync": () => (/* binding */ ɵɵngDeclareClassMetadataAsync),
/* harmony export */   "ɵɵngDeclareComponent": () => (/* binding */ ɵɵngDeclareComponent),
/* harmony export */   "ɵɵngDeclareDirective": () => (/* binding */ ɵɵngDeclareDirective),
/* harmony export */   "ɵɵngDeclareFactory": () => (/* binding */ ɵɵngDeclareFactory),
/* harmony export */   "ɵɵngDeclareInjectable": () => (/* binding */ ɵɵngDeclareInjectable),
/* harmony export */   "ɵɵngDeclareInjector": () => (/* binding */ ɵɵngDeclareInjector),
/* harmony export */   "ɵɵngDeclareNgModule": () => (/* binding */ ɵɵngDeclareNgModule),
/* harmony export */   "ɵɵngDeclarePipe": () => (/* binding */ ɵɵngDeclarePipe),
/* harmony export */   "ɵɵpipe": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipe"]),
/* harmony export */   "ɵɵpipeBind1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind1"]),
/* harmony export */   "ɵɵpipeBind2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind2"]),
/* harmony export */   "ɵɵpipeBind3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind3"]),
/* harmony export */   "ɵɵpipeBind4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind4"]),
/* harmony export */   "ɵɵpipeBindV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBindV"]),
/* harmony export */   "ɵɵprojection": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵprojection"]),
/* harmony export */   "ɵɵprojectionDef": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵprojectionDef"]),
/* harmony export */   "ɵɵproperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]),
/* harmony export */   "ɵɵpureFunction0": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction0"]),
/* harmony export */   "ɵɵpureFunction1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"]),
/* harmony export */   "ɵɵpureFunction2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction2"]),
/* harmony export */   "ɵɵpureFunction3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction3"]),
/* harmony export */   "ɵɵpureFunction4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction4"]),
/* harmony export */   "ɵɵpureFunction5": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction5"]),
/* harmony export */   "ɵɵpureFunction6": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction6"]),
/* harmony export */   "ɵɵpureFunction7": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction7"]),
/* harmony export */   "ɵɵpureFunction8": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction8"]),
/* harmony export */   "ɵɵpureFunctionV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunctionV"]),
/* harmony export */   "ɵɵqueryAdvance": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵqueryAdvance"]),
/* harmony export */   "ɵɵqueryRefresh": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵqueryRefresh"]),
/* harmony export */   "ɵɵreadContextLet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵreadContextLet"]),
/* harmony export */   "ɵɵreference": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵreference"]),
/* harmony export */   "ɵɵregisterNgModuleType": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.registerNgModuleType),
/* harmony export */   "ɵɵrepeater": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeater"]),
/* harmony export */   "ɵɵrepeaterCreate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeaterCreate"]),
/* harmony export */   "ɵɵrepeaterTrackByIdentity": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeaterTrackByIdentity"]),
/* harmony export */   "ɵɵrepeaterTrackByIndex": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵrepeaterTrackByIndex"]),
/* harmony export */   "ɵɵreplaceMetadata": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵreplaceMetadata"]),
/* harmony export */   "ɵɵresetView": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵresetView"]),
/* harmony export */   "ɵɵresolveBody": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveBody"]),
/* harmony export */   "ɵɵresolveDocument": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveDocument"]),
/* harmony export */   "ɵɵresolveWindow": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveWindow"]),
/* harmony export */   "ɵɵrestoreView": () => (/* reexport safe */ _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"]),
/* harmony export */   "ɵɵsanitizeHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeHtml"]),
/* harmony export */   "ɵɵsanitizeResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeResourceUrl"]),
/* harmony export */   "ɵɵsanitizeScript": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeScript"]),
/* harmony export */   "ɵɵsanitizeStyle": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeStyle"]),
/* harmony export */   "ɵɵsanitizeUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrl"]),
/* harmony export */   "ɵɵsanitizeUrlOrResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrlOrResourceUrl"]),
/* harmony export */   "ɵɵsetComponentScope": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetComponentScope"]),
/* harmony export */   "ɵɵsetNgModuleScope": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"]),
/* harmony export */   "ɵɵstoreLet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵstoreLet"]),
/* harmony export */   "ɵɵstyleMap": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵstyleMap"]),
/* harmony export */   "ɵɵstyleProp": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵstyleProp"]),
/* harmony export */   "ɵɵsyntheticHostListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsyntheticHostListener"]),
/* harmony export */   "ɵɵsyntheticHostProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵsyntheticHostProperty"]),
/* harmony export */   "ɵɵtemplate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"]),
/* harmony export */   "ɵɵtemplateRefExtractor": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplateRefExtractor"]),
/* harmony export */   "ɵɵtext": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"]),
/* harmony export */   "ɵɵtextInterpolate": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate"]),
/* harmony export */   "ɵɵtextInterpolate1": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate1"]),
/* harmony export */   "ɵɵtextInterpolate2": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate2"]),
/* harmony export */   "ɵɵtextInterpolate3": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate3"]),
/* harmony export */   "ɵɵtextInterpolate4": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate4"]),
/* harmony export */   "ɵɵtextInterpolate5": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate5"]),
/* harmony export */   "ɵɵtextInterpolate6": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate6"]),
/* harmony export */   "ɵɵtextInterpolate7": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate7"]),
/* harmony export */   "ɵɵtextInterpolate8": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate8"]),
/* harmony export */   "ɵɵtextInterpolateV": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolateV"]),
/* harmony export */   "ɵɵtrustConstantHtml": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtrustConstantHtml"]),
/* harmony export */   "ɵɵtrustConstantResourceUrl": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtrustConstantResourceUrl"]),
/* harmony export */   "ɵɵtwoWayBindingSet": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtwoWayBindingSet"]),
/* harmony export */   "ɵɵtwoWayListener": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtwoWayListener"]),
/* harmony export */   "ɵɵtwoWayProperty": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵtwoWayProperty"]),
/* harmony export */   "ɵɵvalidateAttribute": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵvalidateAttribute"]),
/* harmony export */   "ɵɵviewQuery": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵviewQuery"]),
/* harmony export */   "ɵɵviewQuerySignal": () => (/* reexport safe */ _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵviewQuerySignal"])
/* harmony export */ });
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 11817);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/* harmony import */ var _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_debug_node-chunk.mjs */ 36124);
/* harmony import */ var _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_resource-chunk.mjs */ 52260);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 44866);
/* harmony import */ var _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./primitives-event-dispatch.mjs */ 13807);
/* harmony import */ var _weak_ref_chunk_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_weak_ref-chunk.mjs */ 6550);
/* harmony import */ var _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_not_found-chunk.mjs */ 78330);
/* harmony import */ var _angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core/primitives/signals */ 95094);
/* harmony import */ var _angular_core_primitives_di__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/core/primitives/di */ 20144);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ 32778);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

















const REQUIRED_UNSET_VALUE = /* @__PURE__ */Symbol('InputSignalNode#UNSET');
const INPUT_SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL_NODE,
    transformFn: undefined,
    applyValueToInputSignal(node, value) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalSetFn)(node, value);
    }
  };
})();
const ɵINPUT_SIGNAL_BRAND_WRITE_TYPE = /* @__PURE__ */Symbol();
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.producerAccessed)(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      let message = null;
      if (ngDevMode) {
        const name = options?.debugName ?? options?.alias;
        message = `Input${name ? ` "${name}"` : ''} is required but no value is available yet.`;
      }
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-950, message);
    }
    return node.value;
  }
  inputValueFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
    node.debugName = options?.debugName;
  }
  return inputValueFn;
}
var FactoryTarget = /*#__PURE__*/function (FactoryTarget) {
  FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
  FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
  FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
  FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
  FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
  return FactoryTarget;
}(FactoryTarget || {});
var R3TemplateDependencyKind = /*#__PURE__*/function (R3TemplateDependencyKind) {
  R3TemplateDependencyKind[R3TemplateDependencyKind["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind[R3TemplateDependencyKind["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind[R3TemplateDependencyKind["NgModule"] = 2] = "NgModule";
  return R3TemplateDependencyKind;
}(R3TemplateDependencyKind || {});
var ViewEncapsulation = /*#__PURE__*/function (ViewEncapsulation) {
  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
  ViewEncapsulation[ViewEncapsulation["ExperimentalIsolatedShadowDom"] = 4] = "ExperimentalIsolatedShadowDom";
  return ViewEncapsulation;
}(ViewEncapsulation || {});
var Framework = /*#__PURE__*/function (Framework) {
  Framework["Angular"] = "angular";
  Framework["ACX"] = "acx";
  Framework["Wiz"] = "wiz";
  return Framework;
}(Framework || {});
class HostAttributeToken {
  attributeName;
  constructor(attributeName) {
    this.attributeName = attributeName;
  }
  __NG_ELEMENT_ID__ = () => (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵinjectAttribute"])(this.attributeName);
  toString() {
    return `HostAttributeToken ${this.attributeName}`;
  }
}
const HOST_TAG_NAME = /* @__PURE__ */(() => {
  const HOST_TAG_NAME_TOKEN = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'HOST_TAG_NAME' : '');
  HOST_TAG_NAME_TOKEN.__NG_ELEMENT_ID__ = flags => {
    const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getCurrentTNode)();
    if (tNode === null) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(204, ngDevMode && 'HOST_TAG_NAME can only be injected in directives and components ' + 'during construction time (in a class constructor or as a class field initializer)');
    }
    if (tNode.type & 2) {
      return tNode.value;
    }
    if (flags & 8) {
      return null;
    }
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. ` + `This is invalid, and so the dependency should be marked as optional.`);
  };
  return HOST_TAG_NAME_TOKEN;
})();
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return 'an <ng-container>';
  } else if (tNode.type & 4) {
    return 'an <ng-template>';
  } else if (tNode.type & 128) {
    return 'an @let declaration';
  } else {
    return 'a node';
  }
}
function output(opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(output);
  return new _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.OutputEmitterRef();
}
function inputFunction(initialValue, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
const input = /*#__PURE__*/(() => {
  inputFunction.required = inputRequiredFunction;
  return inputFunction;
})();
function viewChildFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(viewChild);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultOptionalQuerySignalFn)(opts);
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(viewChild);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultRequiredQuerySignalFn)(opts);
}
const viewChild = /*#__PURE__*/(() => {
  viewChildFn.required = viewChildRequiredFn;
  return viewChildFn;
})();
function viewChildren(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(viewChildren);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createMultiResultQuerySignalFn)(opts);
}
function contentChildFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(contentChild);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultOptionalQuerySignalFn)(opts);
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(contentChildren);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createSingleResultRequiredQuerySignalFn)(opts);
}
const contentChild = /*#__PURE__*/(() => {
  contentChildFn.required = contentChildRequiredFn;
  return contentChildFn;
})();
function contentChildren(locator, opts) {
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createMultiResultQuerySignalFn)(opts);
}
function createModelSignal(initialValue, opts) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.producerAccessed)(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL] = node;
  getter.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalAsReadonlyFn.bind(getter);
  getter.set = newValue => {
    if (!node.equal(node.value, newValue)) {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalSetFn)(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = updateFn => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
    node.debugName = opts?.debugName;
  }
  return getter;
}
function assertModelSet(value) {
  if (value === REQUIRED_UNSET_VALUE) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(952, ngDevMode && 'Model is required but no value is available yet.');
  }
}
function modelFunction(initialValue, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(model);
  return createModelSignal(initialValue, opts);
}
function modelRequiredFunction(opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(model);
  return createModelSignal(REQUIRED_UNSET_VALUE, opts);
}
const model = /*#__PURE__*/(() => {
  modelFunction.required = modelRequiredFunction;
  return modelFunction;
})();
const emitDistinctChangesOnlyDefaultValue = true;
class Query {}
const ContentChildren = /*#__PURE__*/(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ContentChildren', (selector, opts = {}) => ({
  selector,
  first: false,
  isViewQuery: false,
  descendants: false,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
  ...opts
}), Query);
const ContentChild = /*#__PURE__*/(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ContentChild', (selector, opts = {}) => ({
  selector,
  first: true,
  isViewQuery: false,
  descendants: true,
  ...opts
}), Query);
const ViewChildren = /*#__PURE__*/(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ViewChildren', (selector, opts = {}) => ({
  selector,
  first: false,
  isViewQuery: true,
  descendants: true,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
  ...opts
}), Query);
const ViewChild = /*#__PURE__*/(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.makePropDecorator)('ViewChild', (selector, opts) => ({
  selector,
  first: true,
  isViewQuery: true,
  descendants: true,
  ...opts
}), Query);
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertNgModuleType)(moduleType);
  const moduleFactory = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory(moduleType);
  if (typeof ngJitMode !== 'undefined' && !ngJitMode) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.COMPILER_OPTIONS, []).concat(options);
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setJitOptions)({
    defaultEncapsulation: _lastDefined(compilerOptions.map(opts => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map(opts => opts.preserveWhitespaces))
  });
  if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isComponentResourceResolutionQueueEmpty)()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap(option => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 0,
    kind: 'NgModule',
    type: moduleType
  });
  const compilerInjector = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
    providers: compilerProviders
  });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveComponentResources)(url => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== undefined) {
      return args[i];
    }
  }
  return undefined;
}
let NgZoneChangeDetectionScheduler = /*#__PURE__*/(() => {
  class NgZoneChangeDetectionScheduler {
    zone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    changeDetectionScheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionScheduler);
    applicationRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
    applicationErrorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER);
    _onMicrotaskEmptySubscription;
    initialize() {
      if (this._onMicrotaskEmptySubscription) {
        return;
      }
      this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
        next: () => {
          if (this.changeDetectionScheduler.runningTick) {
            return;
          }
          this.zone.run(() => {
            try {
              this.applicationRef.dirtyFlags |= 1;
              this.applicationRef._tick();
            } catch (e) {
              this.applicationErrorHandler(e);
            }
          });
        }
      });
    }
    ngOnDestroy() {
      this._onMicrotaskEmptySubscription?.unsubscribe();
    }
    static ɵfac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || NgZoneChangeDetectionScheduler)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      token: NgZoneChangeDetectionScheduler,
      factory: NgZoneChangeDetectionScheduler.ɵfac,
      providedIn: 'root'
    });
  }
  return NgZoneChangeDetectionScheduler;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(NgZoneChangeDetectionScheduler, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const PROVIDED_NG_ZONE = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'provideZoneChangeDetection token' : '', {
  factory: () => false
});
function internalProvideZoneChangeDetection({
  ngZoneFactory,
  scheduleInRootZone
}) {
  ngZoneFactory ??= () => new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone({
    ...getNgZoneOptions(),
    scheduleInRootZone
  });
  return [{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ZONELESS_ENABLED,
    useValue: false
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone,
    useFactory: ngZoneFactory
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory: () => {
      const ngZoneChangeDetectionScheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(NgZoneChangeDetectionScheduler, {
        optional: true
      });
      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');
      }
      return () => ngZoneChangeDetectionScheduler.initialize();
    }
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory: () => {
      const service = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(ZoneStablePendingTask);
      return () => {
        service.initialize();
      };
    }
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SCHEDULE_IN_ROOT_ZONE,
    useValue: scheduleInRootZone ?? _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SCHEDULE_IN_ROOT_ZONE_DEFAULT
  }];
}
function provideZoneChangeDetection(options) {
  const scheduleInRootZone = options?.scheduleInRootZone;
  const zoneProviders = internalProvideZoneChangeDetection({
    ngZoneFactory: () => {
      const ngZoneOptions = getNgZoneOptions(options);
      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;
      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgZone_CoalesceEvent');
      }
      return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone(ngZoneOptions);
    },
    scheduleInRootZone
  });
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)([{
    provide: PROVIDED_NG_ZONE,
    useValue: true
  }, zoneProviders]);
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === 'undefined' ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
let ZoneStablePendingTask = /*#__PURE__*/(() => {
  class ZoneStablePendingTask {
    subscription = new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subscription();
    initialized = false;
    zone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    pendingTasks = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasksInternal);
    initialize() {
      if (this.initialized) {
        return;
      }
      this.initialized = true;
      let task = null;
      if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
        task = this.pendingTasks.add();
      }
      this.zone.runOutsideAngular(() => {
        this.subscription.add(this.zone.onStable.subscribe(() => {
          _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone.assertNotInAngularZone();
          queueMicrotask(() => {
            if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
              this.pendingTasks.remove(task);
              task = null;
            }
          });
        }));
      });
      this.subscription.add(this.zone.onUnstable.subscribe(() => {
        _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone.assertInAngularZone();
        task ??= this.pendingTasks.add();
      }));
    }
    ngOnDestroy() {
      this.subscription.unsubscribe();
    }
    static ɵfac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ZoneStablePendingTask)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      token: ZoneStablePendingTask,
      factory: ZoneStablePendingTask.ɵfac,
      providedIn: 'root'
    });
  }
  return ZoneStablePendingTask;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(ZoneStablePendingTask, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
const SCAN_DELAY = 200;
const OVERSIZED_IMAGE_TOLERANCE = 1200;
let ImagePerformanceWarning = /*#__PURE__*/(() => {
  class ImagePerformanceWarning {
    window = null;
    observer = null;
    options = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IMAGE_CONFIG);
    lcpImageUrl;
    start() {
      if (typeof ngServerMode !== 'undefined' && ngServerMode || typeof PerformanceObserver === 'undefined' || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
        return;
      }
      this.observer = this.initPerformanceObserver();
      const doc = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDocument)();
      const win = doc.defaultView;
      if (win) {
        this.window = win;
        const waitToScan = () => {
          setTimeout(this.scanImages.bind(this), SCAN_DELAY);
        };
        const setup = () => {
          if (doc.readyState === 'complete') {
            waitToScan();
          } else {
            this.window?.addEventListener('load', waitToScan, {
              once: true
            });
          }
        };
        if (typeof Zone !== 'undefined') {
          Zone.root.run(() => setup());
        } else {
          setup();
        }
      }
    }
    ngOnDestroy() {
      this.observer?.disconnect();
    }
    initPerformanceObserver() {
      if (typeof PerformanceObserver === 'undefined') {
        return null;
      }
      const observer = new PerformanceObserver(entryList => {
        const entries = entryList.getEntries();
        if (entries.length === 0) return;
        const lcpElement = entries[entries.length - 1];
        const imgSrc = lcpElement.element?.src ?? '';
        if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;
        this.lcpImageUrl = imgSrc;
      });
      observer.observe({
        type: 'largest-contentful-paint',
        buffered: true
      });
      return observer;
    }
    scanImages() {
      const images = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getDocument)().querySelectorAll('img');
      let lcpElementFound,
        lcpElementLoadedCorrectly = false;
      for (let index = 0; index < images.length; index++) {
        const image = images[index];
        if (!image) {
          continue;
        }
        if (!this.options?.disableImageSizeWarning) {
          if (!image.getAttribute('ng-img') && this.isOversized(image)) {
            logOversizedImageWarning(image.src);
          }
        }
        if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
          if (image.src === this.lcpImageUrl) {
            lcpElementFound = true;
            if (image.loading !== 'lazy' || image.getAttribute('ng-img')) {
              lcpElementLoadedCorrectly = true;
            }
          }
        }
      }
      if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
        logLazyLCPWarning(this.lcpImageUrl);
      }
    }
    isOversized(image) {
      if (!this.window) {
        return false;
      }
      const nonOversizedImageExtentions = ['.svg'];
      const imageSource = (image.src || '').toLowerCase();
      if (nonOversizedImageExtentions.some(extension => imageSource.endsWith(extension))) {
        return false;
      }
      const computedStyle = this.window.getComputedStyle(image);
      let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));
      let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));
      const boxSizing = computedStyle.getPropertyValue('box-sizing');
      const objectFit = computedStyle.getPropertyValue('object-fit');
      if (objectFit === `cover`) {
        return false;
      }
      if (boxSizing === 'border-box') {
        const paddingTop = computedStyle.getPropertyValue('padding-top');
        const paddingRight = computedStyle.getPropertyValue('padding-right');
        const paddingBottom = computedStyle.getPropertyValue('padding-bottom');
        const paddingLeft = computedStyle.getPropertyValue('padding-left');
        renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
        renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
      }
      const intrinsicWidth = image.naturalWidth;
      const intrinsicHeight = image.naturalHeight;
      const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
      const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
      return oversizedWidth || oversizedHeight;
    }
    static ɵfac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ImagePerformanceWarning)();
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      token: ImagePerformanceWarning,
      factory: ImagePerformanceWarning.ɵfac,
      providedIn: 'root'
    });
  }
  return ImagePerformanceWarning;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(ImagePerformanceWarning, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], null, null);
})();
function logLazyLCPWarning(src) {
  console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element ` + `but was given a "loading" value of "lazy", which can negatively impact ` + `application loading performance. This warning can be addressed by ` + `changing the loading value of the LCP image to "eager", or by using the ` + `NgOptimizedImage directive's prioritization utilities. For more ` + `information about addressing or disabling this warning, see ` + `${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERROR_DETAILS_PAGE_BASE_URL}/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-913, `An image with src ${src} has intrinsic file dimensions much larger than its ` + `rendered size. This can negatively impact application loading performance. ` + `For more information about addressing or disabling this warning, see ` + `${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERROR_DETAILS_PAGE_BASE_URL}/NG0913`));
}
const PLATFORM_DESTROY_LISTENERS = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PlatformDestroyListeners' : '');
const ENABLE_ROOT_COMPONENT_BOOTSTRAP = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENABLE_ROOT_COMPONENT_BOOTSTRAP' : '');
function isApplicationBootstrapConfig(config) {
  return !config.moduleRef;
}
function bootstrap(config) {
  const envInjector = isApplicationBootstrapConfig(config) ? config.r3Injector : config.moduleRef.injector;
  const ngZone = envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config)) {
      config.r3Injector.resolveInjectorInitializers();
    } else {
      config.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_APPLICATION_ERROR_HANDLER);
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      if (envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(408, 'Both provideZoneChangeDetection and provideZonelessChangeDetection are provided. ' + 'This is likely a mistake. Update the application providers to use only one of the two.'));
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: exceptionHandler
      });
    });
    if (isApplicationBootstrapConfig(config)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      const destroyListener = () => config.moduleRef.destroy();
      const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      config.moduleRef.onDestroy(() => {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.remove)(config.allPlatformModules, config.moduleRef);
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const pendingTasks = envInjector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PendingTasksInternal);
      const taskId = pendingTasks.add();
      const initStatus = envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.LOCALE_ID, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE_ID);
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setLocaleId)(localeId || _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE_ID);
        const enableRootComponentbootstrap = envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP, true);
        if (!enableRootComponentbootstrap) {
          if (isApplicationBootstrapConfig(config)) {
            return envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
          }
          config.allPlatformModules.push(config.moduleRef);
          return config.moduleRef;
        }
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config)) {
          const appRef = envInjector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
          if (config.rootComponent !== undefined) {
            appRef.bootstrap(config.rootComponent);
          }
          return appRef;
        } else {
          moduleBootstrapImpl?.(config.moduleRef, config.allPlatformModules);
          return config.moduleRef;
        }
      }).finally(() => void pendingTasks.remove(taskId));
    });
  });
}
let moduleBootstrapImpl;
function setModuleBootstrapImpl() {
  moduleBootstrapImpl = _moduleDoBootstrap;
}
function _moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-403, ngDevMode && `The module ${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(moduleRef.instance.constructor)} was bootstrapped, ` + `but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + `Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
  try {
    const result = callback();
    if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isPromise)(result)) {
      return result.catch(e => {
        ngZone.runOutsideAngular(() => errorHandler(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler(e));
    throw e;
  }
}
let PlatformRef = /*#__PURE__*/(() => {
  class PlatformRef {
    _injector;
    _modules = [];
    _destroyListeners = [];
    _destroyed = false;
    constructor(_injector) {
      this._injector = _injector;
    }
    bootstrapModuleFactory(moduleFactory, options) {
      const allAppProviders = [(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetectionInternal)(), ...(options?.applicationProviders ?? []), _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.errorHandlerEnvironmentInitializer, ...(ngDevMode ? [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validAppIdInitializer] : [])];
      const moduleRef = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createNgModuleRefWithProviders)(moduleFactory.moduleType, this.injector, allAppProviders);
      setModuleBootstrapImpl();
      return bootstrap({
        moduleRef,
        allPlatformModules: this._modules,
        platformInjector: this.injector
      });
    }
    bootstrapModule(moduleType, compilerOptions = []) {
      const options = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.optionsReducer)({}, compilerOptions);
      setModuleBootstrapImpl();
      return compileNgModuleFactory(this.injector, options, moduleType).then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
    }
    onDestroy(callback) {
      this._destroyListeners.push(callback);
    }
    get injector() {
      return this._injector;
    }
    destroy() {
      if (this._destroyed) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(404, ngDevMode && 'The platform has already been destroyed!');
      }
      this._modules.slice().forEach(module => module.destroy());
      this._destroyListeners.forEach(listener => listener());
      const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
      if (destroyListeners) {
        destroyListeners.forEach(listener => listener());
        destroyListeners.clear();
      }
      this._destroyed = true;
    }
    get destroyed() {
      return this._destroyed;
    }
    static ɵfac = function PlatformRef_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || PlatformRef)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector));
    };
    static ɵprov = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      token: PlatformRef,
      factory: PlatformRef.ɵfac,
      providedIn: 'platform'
    });
  }
  return PlatformRef;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(PlatformRef, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'platform'
    }]
  }], () => [{
    type: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector
  }], null);
})();
let _platformInjector = null;
function createPlatform(injector) {
  if (getPlatform()) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(400, ngDevMode && 'There can be only one platform. Destroy the previous one to create a new one.');
  }
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishDefaultGlobalUtils)();
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishSignalConfiguration)();
  _platformInjector = typeof ngServerMode === 'undefined' || !ngServerMode ? injector : null;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform) {
      const platformProviders = [...providers, ...extraProviders, {
        provide: marker,
        useValue: true
      }];
      platform = parentPlatformFactory?.(platformProviders) ?? createPlatform(createPlatformInjector(platformProviders, desc));
    }
    return typeof ngServerMode !== 'undefined' && ngServerMode ? platform : assertPlatform(marker);
  };
}
function createPlatformInjector(providers = [], name) {
  return _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector.create({
    name,
    providers: [{
      provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.INJECTOR_SCOPE,
      useValue: 'platform'
    }, {
      provide: PLATFORM_DESTROY_LISTENERS,
      useValue: new Set([() => _platformInjector = null])
    }, ...providers]
  });
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-401, ngDevMode && 'No platform exists!');
  }
  if ((typeof ngDevMode === 'undefined' || ngDevMode) && !platform.injector.get(requiredToken, null)) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(400, 'A platform with a different configuration has been created. Please destroy it first.');
  }
  return platform;
}
function getPlatform() {
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return null;
  }
  return _platformInjector?.get(PlatformRef) ?? null;
}
function destroyPlatform() {
  getPlatform()?.destroy();
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector) return _platformInjector;
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishDefaultGlobalUtils)();
  const injector = createPlatformInjector(providers);
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    _platformInjector = injector;
  }
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.publishSignalConfiguration)();
  runPlatformInitializers(injector);
  return injector;
}
function providePlatformInitializer(initializerFn) {
  return {
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_INITIALIZER,
    useValue: initializerFn,
    multi: true
  };
}
function runPlatformInitializers(injector) {
  const inits = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_INITIALIZER, null);
  (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runInInjectionContext)(injector, () => {
    inits?.forEach(init => init());
  });
}
function exhaustiveCheckNoChangesInterval(interval) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.provideEnvironmentInitializer)(() => {
    const applicationRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
    const errorHandler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ErrorHandler);
    const scheduler = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionSchedulerImpl);
    const ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    function scheduleCheckNoChanges() {
      ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          if (applicationRef.destroyed) {
            return;
          }
          if (scheduler.pendingRenderTaskId || scheduler.runningTick) {
            scheduleCheckNoChanges();
            return;
          }
          for (const view of applicationRef.allViews) {
            try {
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.checkNoChangesInternal)(view._lView, true);
            } catch (e) {
              errorHandler.handleError(e);
            }
          }
          scheduleCheckNoChanges();
        }, interval);
      });
    }
    scheduleCheckNoChanges();
  });
}
function provideCheckNoChangesConfig(options) {
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)(typeof ngDevMode === 'undefined' || ngDevMode ? [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.UseExhaustiveCheckNoChanges,
    useValue: options.exhaustive
  }, options?.interval !== undefined ? exhaustiveCheckNoChangesInterval(options.interval) : []] : []);
}
function isDevMode() {
  return typeof ngDevMode === 'undefined' || !!ngDevMode;
}
function enableProdMode() {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__._global['ngDevMode'] = false;
  }
}
const appsWithEventReplay = /*#__PURE__*/new WeakSet();
const EAGER_CONTENT_LISTENERS_KEY = '';
function shouldEnableEventReplay(injector) {
  return injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_EVENT_REPLAY_ENABLED, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EVENT_REPLAY_ENABLED_DEFAULT);
}
function withEventReplay() {
  const providers = [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_EVENT_REPLAY_ENABLED,
    useFactory: () => {
      let isEnabled = true;
      if (typeof ngServerMode === 'undefined' || !ngServerMode) {
        const appId = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
        isEnabled = !!window._ejsas?.[appId];
      }
      if (isEnabled) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgEventReplay');
      }
      return isEnabled;
    }
  }];
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    providers.push({
      provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
      useValue: () => {
        const appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
        const {
          injector
        } = appRef;
        if (!appsWithEventReplay.has(appRef)) {
          const jsActionMap = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_BLOCK_ELEMENT_MAP);
          if (shouldEnableEventReplay(injector)) {
            (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableStashEventListenerImpl)();
            const appId = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
            const clearStashFn = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setStashFn)(appId, (rEl, eventName, listenerFn) => {
              if (rEl.nodeType !== Node.ELEMENT_NODE) return;
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.sharedStashFunction)(rEl, eventName, listenerFn);
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.sharedMapFunction)(rEl, jsActionMap);
            });
            appRef.onDestroy(clearStashFn);
          }
        }
      },
      multi: true
    }, {
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
      useFactory: () => {
        const appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
        const {
          injector
        } = appRef;
        return () => {
          if (!shouldEnableEventReplay(injector) || appsWithEventReplay.has(appRef)) {
            return;
          }
          appsWithEventReplay.add(appRef);
          const appId = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
          appRef.onDestroy(() => {
            appsWithEventReplay.delete(appRef);
            if (typeof ngServerMode !== 'undefined' && !ngServerMode) {
              (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.clearAppScopedEarlyEventContract)(appId);
            }
          });
          appRef.whenStable().then(() => {
            if (appRef.destroyed) {
              return;
            }
            const eventContractDetails = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_EVENT_CONTRACT);
            initEventReplay(eventContractDetails, injector);
            const jsActionMap = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.JSACTION_BLOCK_ELEMENT_MAP);
            jsActionMap.get(EAGER_CONTENT_LISTENERS_KEY)?.forEach(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.removeListeners);
            jsActionMap.delete(EAGER_CONTENT_LISTENERS_KEY);
            const eventContract = eventContractDetails.instance;
            if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isIncrementalHydrationEnabled)(injector)) {
              appRef.onDestroy(() => eventContract.cleanUp());
            } else {
              eventContract.cleanUp();
            }
          });
        };
      },
      multi: true
    });
  }
  return providers;
}
const initEventReplay = (eventDelegation, injector) => {
  const appId = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
  const earlyJsactionData = window._ejsas[appId];
  const eventContract = eventDelegation.instance = new _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.EventContract(new _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.EventContractContainer(earlyJsactionData.c));
  for (const et of earlyJsactionData.et) {
    eventContract.addEvent(et);
  }
  for (const et of earlyJsactionData.etc) {
    eventContract.addEvent(et);
  }
  const eventInfos = (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.getAppScopedQueuedEventInfos)(appId);
  eventContract.replayEarlyEventInfos(eventInfos);
  (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.clearAppScopedEarlyEventContract)(appId);
  const dispatcher = new _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.EventDispatcher(event => {
    invokeRegisteredReplayListeners(injector, event, event.currentTarget);
  });
  (0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.registerDispatcher)(eventContract, dispatcher);
};
function collectDomEventsInfo(tView, lView, eventTypesToReplay) {
  const domEventsInfo = new Map();
  const lCleanup = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEANUP];
  const tCleanup = tView.cleanup;
  if (!tCleanup || !lCleanup) {
    return domEventsInfo;
  }
  for (let i = 0; i < tCleanup.length;) {
    const firstParam = tCleanup[i++];
    const secondParam = tCleanup[i++];
    if (typeof firstParam !== 'string') {
      continue;
    }
    const eventType = firstParam;
    if (!(0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.isEarlyEventType)(eventType)) {
      continue;
    }
    if ((0,_primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.isCaptureEventType)(eventType)) {
      eventTypesToReplay.capture.add(eventType);
    } else {
      eventTypesToReplay.regular.add(eventType);
    }
    const listenerElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[secondParam]);
    i++;
    const useCaptureOrIndx = tCleanup[i++];
    const isDomEvent = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0;
    if (!isDomEvent) {
      continue;
    }
    if (!domEventsInfo.has(listenerElement)) {
      domEventsInfo.set(listenerElement, [eventType]);
    } else {
      domEventsInfo.get(listenerElement).push(eventType);
    }
  }
  return domEventsInfo;
}
function invokeRegisteredReplayListeners(injector, event, currentTarget) {
  const blockName = (currentTarget && currentTarget.getAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_SSR_ID_ATTRIBUTE)) ?? '';
  if (/d\d+/.test(blockName)) {
    hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget);
  } else if (event.eventPhase === _primitives_event_dispatch_mjs__WEBPACK_IMPORTED_MODULE_5__.EventPhase.REPLAY) {
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.invokeListeners)(event, currentTarget);
  }
}
function hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget) {
  const queue = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EVENT_REPLAY_QUEUE);
  queue.push({
    event,
    currentTarget
  });
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.triggerHydrationFromBlockName)(injector, blockName, createReplayQueuedBlockEventsFn(queue));
}
function createReplayQueuedBlockEventsFn(queue) {
  return hydratedBlocks => {
    const hydrated = new Set(hydratedBlocks);
    const newQueue = [];
    for (let {
      event,
      currentTarget
    } of queue) {
      const blockName = currentTarget.getAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_SSR_ID_ATTRIBUTE);
      if (hydrated.has(blockName)) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.invokeListeners)(event, currentTarget);
      } else {
        newQueue.push({
          event,
          currentTarget
        });
      }
    }
    queue.length = 0;
    queue.push(...newQueue);
  };
}
let isHydrationSupportEnabled = false;
let isI18nHydrationRuntimeSupportEnabled = false;
let isIncrementalHydrationRuntimeSupportEnabled = false;
const APPLICATION_IS_STABLE_TIMEOUT = 10_000;
function enableHydrationRuntimeSupport() {
  if (!isHydrationSupportEnabled) {
    isHydrationSupportEnabled = true;
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableRetrieveHydrationInfoImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateElementNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateTextNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateElementContainerNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateContainerAnchorImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateContainerRefImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableFindMatchingDehydratedViewImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableApplyRootElementTransformImpl)();
  }
}
function enableI18nHydrationRuntimeSupport() {
  if (!isI18nHydrationRuntimeSupportEnabled) {
    isI18nHydrationRuntimeSupportEnabled = true;
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableLocateOrCreateI18nNodeImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enablePrepareI18nBlockForHydrationImpl)();
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableClaimDehydratedIcuCaseImpl)();
  }
}
function enableIncrementalHydrationRuntimeSupport() {
  if (!isIncrementalHydrationRuntimeSupportEnabled) {
    isIncrementalHydrationRuntimeSupportEnabled = true;
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.enableRetrieveDeferBlockDataImpl)();
  }
}
function printHydrationStats(injector) {
  const console = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console);
  const message = `Angular hydrated ${ngDevMode.hydratedComponents} component(s) ` + `and ${ngDevMode.hydratedNodes} node(s), ` + `${ngDevMode.componentsSkippedHydration} component(s) were skipped. ` + ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isIncrementalHydrationEnabled)(injector) ? `${ngDevMode.deferBlocksWithIncrementalHydration} defer block(s) were configured to use incremental hydration. ` : '') + `Learn more at ${_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOC_PAGE_BASE_URL}/guide/hydration.`;
  console.log(message);
}
function whenStableWithTimeout(appRef) {
  const whenStablePromise = appRef.whenStable();
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const timeoutTime = APPLICATION_IS_STABLE_TIMEOUT;
    const console = appRef.injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console);
    const ngZone = appRef.injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    const timeoutId = ngZone.runOutsideAngular(() => {
      return setTimeout(() => logWarningOnStableTimedout(timeoutTime, console), timeoutTime);
    });
    whenStablePromise.finally(() => clearTimeout(timeoutId));
  }
  return whenStablePromise;
}
const CLIENT_RENDER_MODE_FLAG = 'ngcm';
function isClientRenderModeEnabled(doc) {
  return (typeof ngServerMode === 'undefined' || !ngServerMode) && doc.body.hasAttribute(CLIENT_RENDER_MODE_FLAG);
}
function withDomHydration() {
  const providers = [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED,
    useFactory: () => {
      let isEnabled = true;
      if (typeof ngServerMode === 'undefined' || !ngServerMode) {
        const transferState = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TransferState, {
          optional: true
        });
        isEnabled = !!transferState?.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_DATA_KEY, null);
      }
      if (isEnabled) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgHydration');
      }
      return isEnabled;
    }
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setIsI18nHydrationSupportEnabled)(false);
      if (typeof ngServerMode !== 'undefined' && ngServerMode) {
        return;
      }
      const doc = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.verifySsrContentsIntegrity)(doc);
        enableHydrationRuntimeSupport();
      } else if (typeof ngDevMode !== 'undefined' && ngDevMode && !isClientRenderModeEnabled(doc)) {
        const console = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Console);
        const message = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-505, 'Angular hydration was requested on the client, but there was no ' + 'serialized information present in the server response, ' + 'thus hydration was not enabled. ' + 'Make sure the `provideClientHydration()` is included into the list ' + 'of providers in the server part of the application configuration.');
        console.warn(message);
      }
    },
    multi: true
  }];
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    providers.push({
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PRESERVE_HOST_CONTENT,
      useFactory: () => {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED);
      }
    }, {
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
      useFactory: () => {
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)) {
          const appRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
          return () => {
            whenStableWithTimeout(appRef).then(() => {
              if (appRef.destroyed) {
                return;
              }
              (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.cleanupDehydratedViews)(appRef);
              if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.countBlocksSkippedByHydration)(appRef.injector);
                printHydrationStats(appRef.injector);
              }
            });
          };
        }
        return () => {};
      },
      multi: true
    });
  }
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)(providers);
}
function withI18nSupport() {
  return [{
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_I18N_HYDRATION_ENABLED,
    useFactory: () => (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_HYDRATION_DOM_REUSE_ENABLED)) {
        enableI18nHydrationRuntimeSupport();
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setIsI18nHydrationSupportEnabled)(true);
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgI18nHydration');
      }
    },
    multi: true
  }];
}
function withIncrementalHydration() {
  const providers = [withEventReplay(), {
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_INCREMENTAL_HYDRATION_ENABLED,
    useValue: true
  }, {
    provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEHYDRATED_BLOCK_REGISTRY,
    useClass: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DehydratedBlockRegistry
  }, {
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ENVIRONMENT_INITIALIZER,
    useValue: () => {
      enableIncrementalHydrationRuntimeSupport();
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.performanceMarkFeature)('NgIncrementalHydration');
    },
    multi: true
  }];
  if (typeof ngServerMode === 'undefined' || !ngServerMode) {
    providers.push({
      provide: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_BOOTSTRAP_LISTENER,
      useFactory: () => {
        const injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector);
        const doc = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
        return () => {
          const deferBlockData = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.processBlockData)(injector);
          const commentsByBlockId = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.gatherDeferBlocksCommentNodes)(doc, doc.body);
          (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.processAndInitTriggers)(injector, deferBlockData, commentsByBlockId);
          (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.appendDeferBlocksToJSActionMap)(doc, injector);
        };
      },
      multi: true
    });
  }
  return providers;
}
function logWarningOnStableTimedout(time, console) {
  const message = `Angular hydration expected the ApplicationRef.isStable() to emit \`true\`, but it ` + `didn't happen within ${time}ms. Angular hydration logic depends on the application becoming stable ` + `as a signal to complete hydration process.`;
  console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.formatRuntimeError)(-506, message));
}
const STABILITY_WARNING_THRESHOLD = APPLICATION_IS_STABLE_TIMEOUT - 1_000;
class DebugTaskTrackerImpl {
  openTasks = /*#__PURE__*/new Map();
  add(taskId) {
    this.openTasks.set(taskId, new Error('Task stack tracking error'));
  }
  remove(taskId) {
    this.openTasks.delete(taskId);
  }
}
function provideStabilityDebugging() {
  const taskTracker = new DebugTaskTrackerImpl();
  const {
    openTasks
  } = taskTracker;
  return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.makeEnvironmentProviders)([{
    provide: _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DEBUG_TASK_TRACKER,
    useValue: taskTracker
  }, (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideAppInitializer)(() => {
    if (typeof ngDevMode === 'undefined' || !ngDevMode) {
      console.warn('Stability debugging utility was provided in production mode. ' + 'This will cause debug code to be included in production bundles. ' + 'If this is intentional because you are debugging stability issues in a production environment, you can ignore this warning.');
    }
    const ngZone = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.NgZone);
    const applicationRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef);
    let _taskTrackingZone = null;
    if (typeof Zone !== 'undefined') {
      ngZone.run(() => {
        _taskTrackingZone = Zone.current.get('TaskTrackingZone');
      });
    }
    ngZone.runOutsideAngular(() => {
      const timeoutId = setTimeout(() => {
        console.debug(`---- Application did not stabilize within ${STABILITY_WARNING_THRESHOLD / 1000} seconds ----`);
        if (typeof Zone !== 'undefined' && !_taskTrackingZone) {
          console.info('Zone.js is present but no TaskTrackingZone found. To enable better debugging of tasks in the Angular Zone, ' + 'import "zone.js/plugins/task-tracking" in your application.');
        }
        if (_taskTrackingZone?.macroTasks?.length) {
          console.group('Macrotasks keeping Angular Zone unstable:');
          for (const t of _taskTrackingZone?.macroTasks ?? []) {
            console.debug(t.creationLocation.stack);
          }
          console.groupEnd();
        }
        console.group('PendingTasks keeping application unstable:');
        for (const error of openTasks.values()) {
          console.debug(error.stack);
        }
        console.groupEnd();
      }, STABILITY_WARNING_THRESHOLD);
      applicationRef.whenStable().then(() => {
        clearTimeout(timeoutId);
      });
    });
  })]);
}
function getModuleFactory(id) {
  const type = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getRegisteredNgModuleType)(id);
  if (!type) throw noModuleError(id);
  return new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModuleFactory(type);
}
function getNgModuleById(id) {
  const type = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getRegisteredNgModuleType)(id);
  if (!type) throw noModuleError(id);
  return type;
}
function noModuleError(id) {
  return new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(920, ngDevMode && `No module with ID ${id} loaded`);
}
let ChangeDetectorRef = /*#__PURE__*/(() => {
  class ChangeDetectorRef {
    static __NG_ELEMENT_ID__ = injectChangeDetectorRef;
  }
  return ChangeDetectorRef;
})();
function injectChangeDetectorRef(flags) {
  return createViewRef((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getCurrentTNode)(), (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getLView)(), (flags & 16) === 16);
}
function createViewRef(tNode, lView, isPipe) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isComponentHost)(tNode) && !isPipe) {
    const componentView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentLViewByIndex)(tNode.index, lView);
    return new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewRef(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DECLARATION_COMPONENT_VIEW];
    return new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewRef(hostComponentView, lView);
  }
  return null;
}
class ViewRef extends ChangeDetectorRef {}
class EmbeddedViewRef extends ViewRef {}
class DefaultIterableDifferFactory {
  constructor() {}
  supports(obj) {
    return (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isListLikeIterable)(obj);
  }
  create(trackByFn) {
    return new DefaultIterableDiffer(trackByFn);
  }
}
const trackByIdentity = (index, item) => item;
class DefaultIterableDiffer {
  length = 0;
  collection;
  _linkedRecords = null;
  _unlinkedRecords = null;
  _previousItHead = null;
  _itHead = null;
  _itTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _movesHead = null;
  _movesTail = null;
  _removalsHead = null;
  _removalsTail = null;
  _identityChangesHead = null;
  _identityChangesTail = null;
  _trackByFn;
  constructor(trackByFn) {
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets) moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i = 0; i < localMovePreviousIndex; i++) {
              const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
              const index = offset + i;
              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                moveOffsets[i] = offset + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null) collection = [];
    if (!(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isListLikeIterable)(collection)) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(900, ngDevMode && `Error trying to diff '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(collection)}'. Only arrays and iterables are allowed`);
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {}
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index = 0; index < this.length; index++) {
        item = collection[index];
        itemTrackBy = this._trackByFn(index, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index = 0;
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.iterateListLike)(collection, item => {
        itemTrackBy = this._trackByFn(index, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
        index++;
      });
      this.length = index;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  _mismatch(record, item, itemTrackBy, index) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
      }
    }
    return record;
  }
  _verifyReinsertion(record, item, itemTrackBy, index) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index);
    } else if (record.currentIndex != index) {
      record.currentIndex = index;
      this._addToMoves(record, index);
    }
    return record;
  }
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  _reinsertAfter(record, prevRecord, index) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  _moveAfter(record, prevRecord, index) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  _addAfter(record, prevRecord, index) {
    this._insertAfter(record, prevRecord, index);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  _insertAfter(record, prevRecord, index) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index;
    return record;
  }
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
}
class IterableChangeRecord_ {
  item;
  trackById;
  currentIndex = null;
  previousIndex = null;
  _nextPrevious = null;
  _prev = null;
  _next = null;
  _prevDup = null;
  _nextDup = null;
  _prevRemoved = null;
  _nextRemoved = null;
  _nextAdded = null;
  _nextMoved = null;
  _nextIdentityChange = null;
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
  }
}
class _DuplicateItemRecordList {
  _head = null;
  _tail = null;
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
}
class _DuplicateMap {
  map = /*#__PURE__*/new Map();
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null) return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
class DefaultKeyValueDifferFactory {
  constructor() {}
  supports(obj) {
    return obj instanceof Map || (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isJsObject)(obj);
  }
  create() {
    return new DefaultKeyValueDiffer();
  }
}
class DefaultKeyValueDiffer {
  _records = /*#__PURE__*/new Map();
  _mapHead = null;
  _appendAfter = null;
  _previousMapHead = null;
  _changesHead = null;
  _changesTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _removalsHead = null;
  _removalsTail = null;
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
  }
  forEachItem(fn) {
    let record;
    for (record = this._mapHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachChangedItem(fn) {
    let record;
    for (record = this._changesHead; record !== null; record = record._nextChanged) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  diff(map) {
    if (!map) {
      map = new Map();
    } else if (!(map instanceof Map || (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isJsObject)(map))) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(900, ngDevMode && `Error trying to diff '${(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.stringify)(map)}'. Only maps and objects are allowed`);
    }
    return this.check(map) ? this : null;
  }
  onDestroy() {}
  check(map) {
    this._reset();
    let insertBefore = this._mapHead;
    this._appendAfter = null;
    this._forEach(map, (value, key) => {
      if (insertBefore && insertBefore.key === key) {
        this._maybeAddToChanges(insertBefore, value);
        this._appendAfter = insertBefore;
        insertBefore = insertBefore._next;
      } else {
        const record = this._getOrCreateRecordForKey(key, value);
        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
      }
    });
    if (insertBefore) {
      if (insertBefore._prev) {
        insertBefore._prev._next = null;
      }
      this._removalsHead = insertBefore;
      for (let record = insertBefore; record !== null; record = record._nextRemoved) {
        if (record === this._mapHead) {
          this._mapHead = null;
        }
        this._records.delete(record.key);
        record._nextRemoved = record._next;
        record.previousValue = record.currentValue;
        record.currentValue = null;
        record._prev = null;
        record._next = null;
      }
    }
    if (this._changesTail) this._changesTail._nextChanged = null;
    if (this._additionsTail) this._additionsTail._nextAdded = null;
    return this.isDirty;
  }
  _insertBeforeOrAppend(before, record) {
    if (before) {
      const prev = before._prev;
      record._next = before;
      record._prev = prev;
      before._prev = record;
      if (prev) {
        prev._next = record;
      }
      if (before === this._mapHead) {
        this._mapHead = record;
      }
      this._appendAfter = before;
      return before;
    }
    if (this._appendAfter) {
      this._appendAfter._next = record;
      record._prev = this._appendAfter;
    } else {
      this._mapHead = record;
    }
    this._appendAfter = record;
    return null;
  }
  _getOrCreateRecordForKey(key, value) {
    if (this._records.has(key)) {
      const record = this._records.get(key);
      this._maybeAddToChanges(record, value);
      const prev = record._prev;
      const next = record._next;
      if (prev) {
        prev._next = next;
      }
      if (next) {
        next._prev = prev;
      }
      record._next = null;
      record._prev = null;
      return record;
    }
    const record = new KeyValueChangeRecord_(key);
    this._records.set(key, record);
    record.currentValue = value;
    this._addToAdditions(record);
    return record;
  }
  _reset() {
    if (this.isDirty) {
      let record;
      this._previousMapHead = this._mapHead;
      for (record = this._previousMapHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        record.previousValue = record.currentValue;
      }
      for (record = this._additionsHead; record != null; record = record._nextAdded) {
        record.previousValue = record.currentValue;
      }
      this._changesHead = this._changesTail = null;
      this._additionsHead = this._additionsTail = null;
      this._removalsHead = null;
    }
  }
  _maybeAddToChanges(record, newValue) {
    if (!Object.is(newValue, record.currentValue)) {
      record.previousValue = record.currentValue;
      record.currentValue = newValue;
      this._addToChanges(record);
    }
  }
  _addToAdditions(record) {
    if (this._additionsHead === null) {
      this._additionsHead = this._additionsTail = record;
    } else {
      this._additionsTail._nextAdded = record;
      this._additionsTail = record;
    }
  }
  _addToChanges(record) {
    if (this._changesHead === null) {
      this._changesHead = this._changesTail = record;
    } else {
      this._changesTail._nextChanged = record;
      this._changesTail = record;
    }
  }
  _forEach(obj, fn) {
    if (obj instanceof Map) {
      obj.forEach(fn);
    } else {
      Object.keys(obj).forEach(k => fn(obj[k], k));
    }
  }
}
class KeyValueChangeRecord_ {
  key;
  previousValue = null;
  currentValue = null;
  _nextPrevious = null;
  _next = null;
  _prev = null;
  _nextAdded = null;
  _nextRemoved = null;
  _nextChanged = null;
  constructor(key) {
    this.key = key;
  }
}
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
let IterableDiffers = /*#__PURE__*/(() => {
  class IterableDiffers {
    factories;
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      token: IterableDiffers,
      providedIn: 'root',
      factory: defaultIterableDiffersFactory
    });
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent != null) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new IterableDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: IterableDiffers,
        useFactory: () => {
          const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(IterableDiffers, {
            optional: true,
            skipSelf: true
          });
          return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
        }
      };
    }
    find(iterable) {
      const factory = this.factories.find(f => f.supports(iterable));
      if (factory != null) {
        return factory;
      } else {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
      }
    }
  }
  return IterableDiffers;
})();
function getTypeNameForDebugging(type) {
  return type['name'] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
let KeyValueDiffers = /*#__PURE__*/(() => {
  class KeyValueDiffers {
    static ɵprov = /* @__PURE__ */
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
      token: KeyValueDiffers,
      providedIn: 'root',
      factory: defaultKeyValueDiffersFactory
    });
    factories;
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new KeyValueDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: KeyValueDiffers,
        useFactory: () => {
          const parent = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(KeyValueDiffers, {
            optional: true,
            skipSelf: true
          });
          return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
        }
      };
    }
    find(kv) {
      const factory = this.factories.find(f => f.supports(kv));
      if (factory) {
        return factory;
      }
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
    }
  }
  return KeyValueDiffers;
})();
const keyValDiff = [/*#__PURE__*/new DefaultKeyValueDifferFactory()];
const iterableDiff = [/*#__PURE__*/new DefaultIterableDifferFactory()];
const defaultIterableDiffers = /*#__PURE__*/new IterableDiffers(iterableDiff);
const defaultKeyValueDiffers = /*#__PURE__*/new KeyValueDiffers(keyValDiff);
const platformCore = /*#__PURE__*/createPlatformFactory(null, 'core', []);
let ApplicationModule = /*#__PURE__*/(() => {
  class ApplicationModule {
    constructor(appRef) {}
    static ɵfac = function ApplicationModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || ApplicationModule)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef));
    };
    static ɵmod = /*@__PURE__*/(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"])({
      type: ApplicationModule
    });
    static ɵinj = /*@__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"])({});
  }
  return ApplicationModule;
})();
/*#__PURE__*/(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(ApplicationModule, [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NgModule
  }], () => [{
    type: _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ApplicationRef
  }], null);
})();
function internalCreateApplication(config) {
  const {
    rootComponent,
    appProviders,
    platformProviders,
    platformRef
  } = config;
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.profiler)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ProfilerEvent.BootstrapApplicationStart);
  if (typeof ngServerMode !== 'undefined' && ngServerMode && !platformRef) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RuntimeError(-401, ngDevMode && 'Missing Platform: This may be due to using `bootstrapApplication` on the server without passing a `BootstrapContext`. ' + 'Please make sure that `bootstrapApplication` is called with a `context` argument.');
  }
  try {
    const platformInjector = platformRef?.injector ?? createOrReusePlatformInjector(platformProviders);
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && rootComponent !== undefined) {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertStandaloneComponentType)(rootComponent);
    }
    const allAppProviders = [(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.provideZonelessChangeDetectionInternal)(), _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.errorHandlerEnvironmentInitializer, ...(ngDevMode ? [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validAppIdInitializer] : []), ...(appProviders || [])];
    const adapter = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EnvironmentNgModuleRefAdapter({
      providers: allAppProviders,
      parent: platformInjector,
      debugName: typeof ngDevMode === 'undefined' || ngDevMode ? 'Environment Injector' : '',
      runEnvironmentInitializers: false
    });
    return bootstrap({
      r3Injector: adapter.injector,
      platformInjector,
      rootComponent
    });
  } catch (e) {
    return Promise.reject(e);
  } finally {
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.profiler)(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ProfilerEvent.BootstrapApplicationEnd);
  }
}
class SerializedViewCollection {
  views = [];
  indexByContent = /*#__PURE__*/new Map();
  add(serializedView) {
    const viewAsString = JSON.stringify(serializedView);
    if (!this.indexByContent.has(viewAsString)) {
      const index = this.views.length;
      this.views.push(serializedView);
      this.indexByContent.set(viewAsString, index);
      return index;
    }
    return this.indexByContent.get(viewAsString);
  }
  getAll() {
    return this.views;
  }
}
let tViewSsrId = 0;
function getSsrId(tView) {
  if (!tView.ssrId) {
    tView.ssrId = `t${tViewSsrId++}`;
  }
  return tView.ssrId;
}
function calcNumRootNodes(tView, lView, tNode) {
  const rootNodes = [];
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.collectNativeNodes)(tView, lView, tNode, rootNodes);
  return rootNodes.length;
}
function calcNumRootNodesInLContainer(lContainer) {
  const rootNodes = [];
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.collectNativeNodesInLContainer)(lContainer, rootNodes);
  return rootNodes.length;
}
function annotateComponentLViewForHydration(lView, context) {
  const hostElement = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST];
  if (hostElement && !hostElement.hasAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME)) {
    return annotateHostElementForHydration(hostElement, lView, null, context);
  }
  return null;
}
function annotateLContainerForHydration(lContainer, context) {
  const componentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapLView)(lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
  const componentLViewNghIndex = annotateComponentLViewForHydration(componentLView, context);
  if (componentLViewNghIndex === null) {
    return;
  }
  const hostElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
  const rootLView = lContainer[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.PARENT];
  const rootLViewNghIndex = annotateHostElementForHydration(hostElement, rootLView, null, context);
  const renderer = componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RENDERER];
  const finalIndex = `${componentLViewNghIndex}|${rootLViewNghIndex}`;
  renderer.setAttribute(hostElement, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_ATTR_NAME, finalIndex);
}
function annotateForHydration(appRef, doc) {
  const injector = appRef.injector;
  const isI18nHydrationEnabledVal = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isI18nHydrationEnabled)(injector);
  const isIncrementalHydrationEnabledVal = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isIncrementalHydrationEnabled)(injector);
  const serializedViewCollection = new SerializedViewCollection();
  const corruptedTextNodes = new Map();
  const viewRefs = appRef._views;
  const shouldReplayEvents = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.IS_EVENT_REPLAY_ENABLED, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.EVENT_REPLAY_ENABLED_DEFAULT);
  const eventTypesToReplay = {
    regular: new Set(),
    capture: new Set()
  };
  const deferBlocks = new Map();
  const appId = appRef.injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.APP_ID);
  for (const viewRef of viewRefs) {
    const lNode = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLNodeForHydration)(viewRef);
    if (lNode !== null) {
      const context = {
        serializedViewCollection,
        corruptedTextNodes,
        isI18nHydrationEnabled: isI18nHydrationEnabledVal,
        isIncrementalHydrationEnabled: isIncrementalHydrationEnabledVal,
        i18nChildren: new Map(),
        eventTypesToReplay,
        shouldReplayEvents,
        appId,
        deferBlocks
      };
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(lNode)) {
        annotateLContainerForHydration(lNode, context);
      } else {
        annotateComponentLViewForHydration(lNode, context);
      }
      insertCorruptedTextNodeMarkers(corruptedTextNodes, doc);
    }
  }
  const serializedViews = serializedViewCollection.getAll();
  const transferState = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TransferState);
  transferState.set(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_DATA_KEY, serializedViews);
  if (deferBlocks.size > 0) {
    const blocks = {};
    for (const [id, info] of deferBlocks.entries()) {
      blocks[id] = info;
    }
    transferState.set(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_DEFER_BLOCKS_KEY, blocks);
  }
  return eventTypesToReplay;
}
function serializeLContainer(lContainer, tNode, lView, parentDeferBlockId, context) {
  const views = [];
  let lastViewAsString = '';
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    let childLView = lContainer[i];
    let template;
    let numRootNodes;
    let serializedView;
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isRootView)(childLView)) {
      childLView = childLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET];
      if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(childLView)) {
        numRootNodes = calcNumRootNodesInLContainer(childLView) + 1;
        annotateLContainerForHydration(childLView, context);
        const componentLView = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapLView)(childLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
        serializedView = {
          [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATE_ID]: componentLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW].ssrId,
          [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NUM_ROOT_NODES]: numRootNodes
        };
      }
    }
    if (!serializedView) {
      const childTView = childLView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW];
      if (childTView.type === 1) {
        template = childTView.ssrId;
        numRootNodes = 1;
      } else {
        template = getSsrId(childTView);
        numRootNodes = calcNumRootNodes(childTView, childLView, childTView.firstChild);
      }
      serializedView = {
        [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATE_ID]: template,
        [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NUM_ROOT_NODES]: numRootNodes
      };
      let isHydrateNeverBlock = false;
      if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDeferBlock)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW], tNode)) {
        const lDetails = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getLDeferBlockDetails)(lView, tNode);
        const tDetails = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getTDeferBlockDetails)(lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW], tNode);
        if (context.isIncrementalHydrationEnabled && tDetails.hydrateTriggers !== null) {
          const deferBlockId = `d${context.deferBlocks.size}`;
          if (tDetails.hydrateTriggers.has(7)) {
            isHydrateNeverBlock = true;
          }
          let rootNodes = [];
          (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.collectNativeNodesInLContainer)(lContainer, rootNodes);
          const deferBlockInfo = {
            [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NUM_ROOT_NODES]: rootNodes.length,
            [_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE]: lDetails[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE$1]
          };
          const serializedTriggers = serializeHydrateTriggers(tDetails.hydrateTriggers);
          if (serializedTriggers.length > 0) {
            deferBlockInfo[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_HYDRATE_TRIGGERS] = serializedTriggers;
          }
          if (parentDeferBlockId !== null) {
            deferBlockInfo[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_PARENT_BLOCK_ID] = parentDeferBlockId;
          }
          context.deferBlocks.set(deferBlockId, deferBlockInfo);
          const node = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lContainer);
          if (node !== undefined) {
            if (node.nodeType === Node.COMMENT_NODE) {
              annotateDeferBlockAnchorForHydration(node, deferBlockId);
            }
          } else {
            ngDevMode && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validateNodeExists)(node, childLView, tNode);
            ngDevMode && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.validateMatchingNode)(node, Node.COMMENT_NODE, null, childLView, tNode, true);
            annotateDeferBlockAnchorForHydration(node, deferBlockId);
          }
          if (!isHydrateNeverBlock) {
            annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, deferBlockId, context);
          }
          parentDeferBlockId = deferBlockId;
          serializedView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_ID] = deferBlockId;
        }
        serializedView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE] = lDetails[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DEFER_BLOCK_STATE$1];
      }
      if (!isHydrateNeverBlock) {
        Object.assign(serializedView, serializeLView(lContainer[i], parentDeferBlockId, context));
      }
    }
    const currentViewAsString = JSON.stringify(serializedView);
    if (views.length > 0 && currentViewAsString === lastViewAsString) {
      const previousView = views[views.length - 1];
      previousView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLIER] ??= 1;
      previousView[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.MULTIPLIER]++;
    } else {
      lastViewAsString = currentViewAsString;
      views.push(serializedView);
    }
  }
  return views;
}
function serializeHydrateTriggers(triggerMap) {
  const serializableDeferBlockTrigger = new Set([0, 1, 2, 5]);
  let triggers = [];
  for (let [trigger, details] of triggerMap) {
    if (serializableDeferBlockTrigger.has(trigger)) {
      if (details === null) {
        triggers.push(trigger);
      } else if (details.type === 5) {
        triggers.push({
          trigger,
          delay: details.delay
        });
      } else {
        triggers.push({
          trigger,
          intersectionObserverOptions: details.intersectionObserverOptions
        });
      }
    }
  }
  return triggers;
}
function appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes) {
  const noOffsetIndex = tNode.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET;
  ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NODES] ??= {};
  ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NODES][noOffsetIndex] ??= (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.calcPathForNode)(tNode, lView, excludedParentNodes);
}
function appendDisconnectedNodeIndex(ngh, tNodeOrNoOffsetIndex) {
  const noOffsetIndex = typeof tNodeOrNoOffsetIndex === 'number' ? tNodeOrNoOffsetIndex : tNodeOrNoOffsetIndex.index - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET;
  ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DISCONNECTED_NODES] ??= [];
  if (!ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DISCONNECTED_NODES].includes(noOffsetIndex)) {
    ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DISCONNECTED_NODES].push(noOffsetIndex);
  }
}
function serializeLView(lView, parentDeferBlockId = null, context) {
  const ngh = {};
  const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW];
  const i18nChildren = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getOrComputeI18nChildren)(tView, context);
  const nativeElementsToEventTypes = context.shouldReplayEvents ? collectDomEventsInfo(tView, lView, context.eventTypesToReplay) : null;
  for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tNode = tView.data[i];
    const noOffsetIndex = i - _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET;
    const i18nData = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.trySerializeI18nBlock)(lView, i, context);
    if (i18nData) {
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.I18N_DATA] ??= {};
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.I18N_DATA][noOffsetIndex] = i18nData.caseQueue;
      for (const nodeNoOffsetIndex of i18nData.disconnectedNodes) {
        appendDisconnectedNodeIndex(ngh, nodeNoOffsetIndex);
      }
      for (const nodeNoOffsetIndex of i18nData.disjointNodes) {
        const tNode = tView.data[nodeNoOffsetIndex + _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET];
        ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertTNode)(tNode);
        appendSerializedNodePath(ngh, tNode, lView, i18nChildren);
      }
      continue;
    }
    if (!(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isTNodeShape)(tNode)) {
      continue;
    }
    if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDetachedByI18n)(tNode)) {
      continue;
    }
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(lView[i]) && tNode.tView) {
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATES] ??= {};
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TEMPLATES][noOffsetIndex] = getSsrId(tNode.tView);
    }
    if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(tNode, lView) && isContentProjectedNode(tNode)) {
      appendDisconnectedNodeIndex(ngh, tNode);
      continue;
    }
    if (Array.isArray(tNode.projection)) {
      for (const projectionHeadTNode of tNode.projection) {
        if (!projectionHeadTNode) continue;
        if (!Array.isArray(projectionHeadTNode)) {
          if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isProjectionTNode)(projectionHeadTNode) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isInSkipHydrationBlock)(projectionHeadTNode)) {
            if ((0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(projectionHeadTNode, lView)) {
              appendDisconnectedNodeIndex(ngh, projectionHeadTNode);
            } else {
              appendSerializedNodePath(ngh, projectionHeadTNode, lView, i18nChildren);
            }
          }
        } else {
          throw (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.unsupportedProjectionOfDomNodes)((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i]));
        }
      }
    }
    conditionallyAnnotateNodePath(ngh, tNode, lView, i18nChildren);
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(lView[i])) {
      const hostNode = lView[i][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST];
      if (Array.isArray(hostNode)) {
        const targetNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(hostNode);
        if (!targetNode.hasAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME)) {
          annotateHostElementForHydration(targetNode, hostNode, parentDeferBlockId, context);
        }
      }
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CONTAINERS] ??= {};
      ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.CONTAINERS][noOffsetIndex] = serializeLContainer(lView[i], tNode, lView, parentDeferBlockId, context);
    } else if (Array.isArray(lView[i]) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isLetDeclaration)(tNode)) {
      const targetNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i][_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST]);
      if (!targetNode.hasAttribute(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME)) {
        annotateHostElementForHydration(targetNode, lView[i], parentDeferBlockId, context);
      }
    } else {
      if (tNode.type & 8) {
        ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ELEMENT_CONTAINERS] ??= {};
        ngh[_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ELEMENT_CONTAINERS][noOffsetIndex] = calcNumRootNodes(tView, lView, tNode.child);
      } else if (tNode.type & (16 | 128)) {
        let nextTNode = tNode.next;
        while (nextTNode !== null && nextTNode.type & (16 | 128)) {
          nextTNode = nextTNode.next;
        }
        if (nextTNode && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isInSkipHydrationBlock)(nextTNode)) {
          appendSerializedNodePath(ngh, nextTNode, lView, i18nChildren);
        }
      } else if (tNode.type & 1) {
        const rNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i]);
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.processTextNodeBeforeSerialization)(context, rNode);
      }
    }
    if (nativeElementsToEventTypes && tNode.type & 2) {
      const nativeElement = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.unwrapRNode)(lView[i]);
      if (nativeElementsToEventTypes.has(nativeElement)) {
        (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setJSActionAttributes)(nativeElement, nativeElementsToEventTypes.get(nativeElement), parentDeferBlockId);
      }
    }
  }
  return ngh;
}
function conditionallyAnnotateNodePath(ngh, tNode, lView, excludedParentNodes) {
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isProjectionTNode)(tNode)) {
    return;
  }
  if (tNode.projectionNext && tNode.projectionNext !== tNode.next && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isInSkipHydrationBlock)(tNode.projectionNext)) {
    appendSerializedNodePath(ngh, tNode.projectionNext, lView, excludedParentNodes);
  }
  if (tNode.prev === null && tNode.parent !== null && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(tNode.parent, lView) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isDisconnectedNode)(tNode, lView)) {
    appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes);
  }
}
function componentUsesShadowDomEncapsulation(lView) {
  const instance = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.CONTEXT];
  if (!instance?.constructor) return false;
  const def = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef)(instance.constructor);
  return def?.encapsulation === _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ShadowDom || def?.encapsulation === _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.ExperimentalIsolatedShadowDom;
}
function annotateHostElementForHydration(element, lView, parentDeferBlockId, context) {
  const renderer = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.RENDERER];
  if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.hasI18n)(lView) && !(0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isI18nHydrationSupportEnabled)() || componentUsesShadowDomEncapsulation(lView)) {
    renderer.setAttribute(element, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SKIP_HYDRATION_ATTR_NAME, '');
    return null;
  } else {
    const ngh = serializeLView(lView, parentDeferBlockId, context);
    const index = context.serializedViewCollection.add(ngh);
    renderer.setAttribute(element, _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NGH_ATTR_NAME, index.toString());
    return index;
  }
}
function annotateDeferBlockAnchorForHydration(comment, deferBlockId) {
  comment.textContent = `ngh=${deferBlockId}`;
}
function insertCorruptedTextNodeMarkers(corruptedTextNodes, doc) {
  for (const [textNode, marker] of corruptedTextNodes) {
    textNode.after(doc.createComment(marker));
  }
}
function isContentProjectedNode(tNode) {
  let currentTNode = tNode;
  while (currentTNode != null) {
    if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isComponentHost)(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
function annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, parentDeferBlockId, context) {
  const actionList = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.convertHydrateTriggersToJsAction)(tDetails.hydrateTriggers);
  for (let et of actionList) {
    context.eventTypesToReplay.regular.add(et);
  }
  if (actionList.length > 0) {
    const elementNodes = rootNodes.filter(rn => rn.nodeType === Node.ELEMENT_NODE);
    for (let rNode of elementNodes) {
      (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setJSActionAttributes)(rNode, actionList, parentDeferBlockId);
    }
  }
}
function booleanAttribute(value) {
  return typeof value === 'boolean' ? value : value != null && value !== 'false';
}
function numberAttribute(value, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));
  return isNumberValue ? Number(value) : fallbackValue;
}
const PERFORMANCE_MARK_PREFIX = '🅰️';
let enablePerfLogging = false;
function startMeasuring(label) {
  if (!enablePerfLogging) {
    return;
  }
  const {
    startLabel
  } = labels(label);
  performance.mark(startLabel);
}
function stopMeasuring(label) {
  if (!enablePerfLogging) {
    return;
  }
  const {
    startLabel,
    labelName,
    endLabel
  } = labels(label);
  performance.mark(endLabel);
  performance.measure(labelName, startLabel, endLabel);
  performance.clearMarks(startLabel);
  performance.clearMarks(endLabel);
}
function labels(label) {
  const labelName = `${PERFORMANCE_MARK_PREFIX}:${label}`;
  return {
    labelName,
    startLabel: `start:${labelName}`,
    endLabel: `end:${labelName}`
  };
}
let warningLogged = false;
function enableProfiling() {
  if (!warningLogged && (typeof performance === 'undefined' || !performance.mark || !performance.measure)) {
    warningLogged = true;
    console.warn('Performance API is not supported on this platform');
    return;
  }
  enablePerfLogging = true;
}
function disableProfiling() {
  enablePerfLogging = false;
}
function getClosestComponentName(node) {
  let currentNode = node;
  while (currentNode) {
    const lView = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.readPatchedLView)(currentNode);
    if (lView !== null) {
      for (let i = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HEADER_OFFSET; i < lView.length; i++) {
        const current = lView[i];
        if (!(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLView)(current) && !(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isLContainer)(current) || current[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.HOST] !== currentNode) {
          continue;
        }
        const tView = lView[_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.TVIEW];
        const tNode = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getTNode)(tView, i);
        if ((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isComponentHost)(tNode)) {
          const def = tView.data[tNode.directiveStart + tNode.componentOffset];
          const name = def.debugInfo?.className || def.type.name;
          if (name) {
            return name;
          } else {
            break;
          }
        }
      }
    }
    currentNode = currentNode.parentNode;
  }
  return null;
}
function ɵassertType(value) {}
function ɵɵngDeclareDirective(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'directive',
    type: decl.type
  });
  return compiler.compileDirectiveDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵfac.js`, decl);
}
function ɵɵngDeclareClassMetadata(decl) {
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(decl.type, decl.decorators, decl.ctorParameters ?? null, decl.propDecorators ?? null);
}
function ɵɵngDeclareClassMetadataAsync(decl) {
  (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadataAsync)(decl.type, decl.resolveDeferredDeps, (...types) => {
    const meta = decl.resolveMetadata(...types);
    (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setClassMetadata)(decl.type, meta.decorators, meta.ctorParameters, meta.propDecorators);
  });
}
function ɵɵngDeclareComponent(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'component',
    type: decl.type
  });
  return compiler.compileComponentDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵcmp.js`, decl);
}
function ɵɵngDeclareFactory(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: getFactoryKind(decl.target),
    type: decl.type
  });
  return compiler.compileFactoryDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵfac.js`, decl);
}
function getFactoryKind(target) {
  switch (target) {
    case FactoryTarget.Directive:
      return 'directive';
    case FactoryTarget.Component:
      return 'component';
    case FactoryTarget.Injectable:
      return 'injectable';
    case FactoryTarget.Pipe:
      return 'pipe';
    case FactoryTarget.NgModule:
      return 'NgModule';
  }
}
function ɵɵngDeclareInjectable(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'injectable',
    type: decl.type
  });
  return compiler.compileInjectableDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵprov.js`, decl);
}
function ɵɵngDeclareInjector(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'NgModule',
    type: decl.type
  });
  return compiler.compileInjectorDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵinj.js`, decl);
}
function ɵɵngDeclareNgModule(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'NgModule',
    type: decl.type
  });
  return compiler.compileNgModuleDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵmod.js`, decl);
}
function ɵɵngDeclarePipe(decl) {
  const compiler = (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCompilerFacade)({
    usage: 1,
    kind: 'pipe',
    type: decl.type
  });
  return compiler.compilePipeDeclaration(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.angularCoreEnv, `ng:///${decl.type.name}/ɵpipe.js`, decl);
}
const NOT_SET = /* @__PURE__ */Symbol('NOT_SET');
const EMPTY_CLEANUP_SET = /* @__PURE__ */new Set();
const AFTER_RENDER_PHASE_EFFECT_NODE = /* @__PURE__ */(() => ({
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL_NODE,
  kind: 'afterRenderEffectPhase',
  consumerIsAlwaysLive: true,
  consumerAllowSignalWrites: true,
  value: NOT_SET,
  cleanup: null,
  consumerMarkedDirty() {
    if (this.sequence.impl.executing) {
      if (this.sequence.lastPhase === null || this.sequence.lastPhase < this.phase) {
        return;
      }
      this.sequence.erroredOrDestroyed = true;
    }
    this.sequence.scheduler.notify(7);
  },
  phaseFn(previousValue) {
    this.sequence.lastPhase = this.phase;
    if (!this.dirty) {
      return this.signal;
    }
    this.dirty = false;
    if (this.value !== NOT_SET && !(0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerPollProducersForChange)(this)) {
      return this.signal;
    }
    try {
      for (const cleanupFn of this.cleanup ?? EMPTY_CLEANUP_SET) {
        cleanupFn();
      }
    } finally {
      this.cleanup?.clear();
    }
    const args = [];
    if (previousValue !== undefined) {
      args.push(previousValue);
    }
    args.push(this.registerCleanupFn);
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerBeforeComputation)(this);
    let newValue;
    try {
      newValue = this.userFn.apply(null, args);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerAfterComputation)(this, prevConsumer);
    }
    if (this.value === NOT_SET || !this.equal(this.value, newValue)) {
      this.value = newValue;
      this.version++;
    }
    return this.signal;
  }
}))();
class AfterRenderEffectSequence extends _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderSequence {
  scheduler;
  lastPhase = null;
  nodes = [undefined, undefined, undefined, undefined];
  onDestroyFns = null;
  constructor(impl, effectHooks, view, scheduler, injector, snapshot = null) {
    super(impl, [undefined, undefined, undefined, undefined], view, false, injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.DestroyRef), snapshot);
    this.scheduler = scheduler;
    for (const phase of _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AFTER_RENDER_PHASES) {
      const effectHook = effectHooks[phase];
      if (effectHook === undefined) {
        continue;
      }
      const node = Object.create(AFTER_RENDER_PHASE_EFFECT_NODE);
      node.sequence = this;
      node.phase = phase;
      node.userFn = effectHook;
      node.dirty = true;
      node.signal = () => {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.producerAccessed)(node);
        return node.value;
      };
      node.signal[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.SIGNAL] = node;
      node.registerCleanupFn = fn => (node.cleanup ??= new Set()).add(fn);
      this.nodes[phase] = node;
      this.hooks[phase] = value => node.phaseFn(value);
      if (ngDevMode) {
        setupDebugInfo(node, injector);
      }
    }
  }
  afterRun() {
    super.afterRun();
    this.lastPhase = null;
  }
  destroy() {
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    super.destroy();
    for (const node of this.nodes) {
      if (node) {
        try {
          for (const fn of node.cleanup ?? EMPTY_CLEANUP_SET) {
            fn();
          }
        } finally {
          (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.consumerDestroy)(node);
        }
      }
    }
  }
}
function afterRenderEffect(callbackOrSpec, options) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertNotInReactiveContext)(afterRenderEffect, 'Call `afterRenderEffect` outside of a reactive context. For example, create the render ' + 'effect inside the component constructor`.');
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.assertInInjectionContext)(afterRenderEffect);
  }
  if (typeof ngServerMode !== 'undefined' && ngServerMode) {
    return _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.NOOP_AFTER_RENDER_REF;
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.Injector);
  const scheduler = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionScheduler);
  const manager = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderManager);
  const tracing = injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.TracingService, null, {
    optional: true
  });
  manager.impl ??= injector.get(_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.AfterRenderImpl);
  let spec = callbackOrSpec;
  if (typeof spec === 'function') {
    spec = {
      mixedReadWrite: callbackOrSpec
    };
  }
  const viewContext = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContext, null, {
    optional: true
  });
  const sequence = new AfterRenderEffectSequence(manager.impl, [spec.earlyRead, spec.write, spec.mixedReadWrite, spec.read], viewContext?.view, scheduler, injector, tracing?.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
function setupDebugInfo(node, injector) {
  node.debugName = `afterRenderEffect - ${phaseDebugName(node.phase)} phase`;
  const prevInjectorProfilerContext = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setInjectorProfilerContext)({
    injector,
    token: null
  });
  try {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.emitAfterRenderEffectPhaseCreatedEvent)(node);
  } finally {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setInjectorProfilerContext)(prevInjectorProfilerContext);
  }
}
function phaseDebugName(phase) {
  switch (phase) {
    case 0:
      return 'EarlyRead';
    case 1:
      return 'Write';
    case 2:
      return 'MixedReadWrite';
    case 3:
      return 'Read';
  }
}
function createComponent(component, options) {
  ngDevMode && (0,_debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertComponentDef)(component);
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef)(component);
  const elementInjector = options.elementInjector || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getNullInjector)();
  const factory = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory(componentDef);
  return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector, options.directives, options.bindings);
}
function reflectComponentType(component) {
  const componentDef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getComponentDef)(component);
  if (!componentDef) return null;
  const factory = new _debug_node_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.ComponentFactory(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
function mergeApplicationConfig(...configs) {
  return configs.reduce((prev, curr) => {
    return Object.assign(prev, curr, {
      providers: [...prev.providers, ...curr.providers]
    });
  }, {
    providers: []
  });
}
const REQUEST = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'REQUEST' : '', {
  providedIn: 'platform',
  factory: () => null
});
const RESPONSE_INIT = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'RESPONSE_INIT' : '', {
  providedIn: 'platform',
  factory: () => null
});
const REQUEST_CONTEXT = /*#__PURE__*/new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'REQUEST_CONTEXT' : '', {
  providedIn: 'platform',
  factory: () => null
});


/***/ },

/***/ 52260
/*!*****************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_resource-chunk.mjs ***!
  \*****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutputEmitterRef: () => (/* binding */ OutputEmitterRef),
/* harmony export */   ResourceImpl: () => (/* binding */ ResourceImpl),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   encapsulateResourceError: () => (/* binding */ encapsulateResourceError),
/* harmony export */   getOutputDestroyRef: () => (/* binding */ getOutputDestroyRef),
/* harmony export */   linkedSignal: () => (/* binding */ linkedSignal),
/* harmony export */   resource: () => (/* binding */ resource)
/* harmony export */ });
/* harmony import */ var _Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 89204);
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 11817);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/* harmony import */ var _linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_linked_signal-chunk.mjs */ 68262);

/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */




class OutputEmitterRef {
  destroyed = false;
  listeners = null;
  errorHandler = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler, {
    optional: true
  });
  destroyRef = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef);
  constructor() {
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(953, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== undefined && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  emit(value) {
    if (this.destroyed) {
      console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(953, ngDevMode && 'Unexpected emit for destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.'));
      return;
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(previousConsumer);
    }
  }
}
function getOutputDestroyRef(ref) {
  return ref.destroyRef;
}
function computed(computation, options) {
  const getter = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createComputed)(computation, options?.equal);
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
    getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL].debugName = options?.debugName;
  }
  return getter;
}
const identityFn = v => v;
function linkedSignal(optionsOrComputation, options) {
  if (typeof optionsOrComputation === 'function') {
    const getter = (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.createLinkedSignal)(optionsOrComputation, identityFn, options?.equal);
    return upgradeLinkedSignalGetter(getter, options?.debugName);
  } else {
    const getter = (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.createLinkedSignal)(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);
    return upgradeLinkedSignalGetter(getter, optionsOrComputation.debugName);
  }
}
function upgradeLinkedSignalGetter(getter, debugName) {
  if (ngDevMode) {
    getter.toString = () => `[LinkedSignal: ${getter()}]`;
    getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL].debugName = debugName;
  }
  const node = getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  const upgradedGetter = getter;
  upgradedGetter.set = newValue => (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignalSetFn)(node, newValue);
  upgradedGetter.update = updateFn => (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignalUpdateFn)(node, updateFn);
  upgradedGetter.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalAsReadonlyFn.bind(getter);
  return upgradedGetter;
}
function resource(options) {
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(resource);
  }
  const oldNameForParams = options.request;
  const params = options.params ?? oldNameForParams ?? (() => null);
  return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.debugName, options.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector));
}
class BaseWritableResource {
  value;
  isLoading;
  constructor(value, debugName) {
    this.value = value;
    this.value.set = this.set.bind(this);
    this.value.update = this.update.bind(this);
    this.value.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalAsReadonlyFn;
    this.isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading', ngDevMode ? createDebugNameObject(debugName, 'isLoading') : undefined);
  }
  isError = /*#__PURE__*/computed(() => this.status() === 'error');
  update(updateFn) {
    this.set(updateFn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.value)));
  }
  isValueDefined = /*#__PURE__*/computed(() => {
    if (this.isError()) {
      return false;
    }
    return this.value() !== undefined;
  });
  hasValue() {
    return this.isValueDefined();
  }
  asReadonly() {
    return this;
  }
}
class ResourceImpl extends BaseWritableResource {
  loaderFn;
  equal;
  debugName;
  pendingTasks;
  state;
  extRequest;
  effectRef;
  pendingController;
  resolvePendingTask = undefined;
  destroyed = false;
  unregisterOnDestroy;
  status;
  error;
  constructor(request, loaderFn, defaultValue, equal, debugName, injector) {
    super(computed(() => {
      const streamValue = this.state().stream?.();
      if (!streamValue) {
        return defaultValue;
      }
      if (this.state().status === 'loading' && this.error()) {
        return defaultValue;
      }
      if (!isResolved(streamValue)) {
        throw new ResourceValueError(this.error());
      }
      return streamValue.value;
    }, {
      equal,
      ...(ngDevMode ? createDebugNameObject(debugName, 'value') : undefined)
    }), debugName);
    this.loaderFn = loaderFn;
    this.equal = equal;
    this.debugName = debugName;
    this.extRequest = linkedSignal({
      source: request,
      computation: request => ({
        request,
        reload: 0
      }),
      ...(ngDevMode ? createDebugNameObject(debugName, 'extRequest') : undefined)
    });
    this.state = linkedSignal({
      source: this.extRequest,
      computation: (extRequest, previous) => {
        const status = extRequest.request === undefined ? 'idle' : 'loading';
        if (!previous) {
          return {
            extRequest,
            status,
            previousStatus: 'idle',
            stream: undefined
          };
        } else {
          return {
            extRequest,
            status,
            previousStatus: projectStatusOfState(previous.value),
            stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : undefined
          };
        }
      },
      ...(ngDevMode ? createDebugNameObject(debugName, 'state') : undefined)
    });
    this.effectRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.effect)(this.loadEffect.bind(this), {
      injector,
      manualCleanup: true,
      ...(ngDevMode ? createDebugNameObject(debugName, 'loadEffect') : undefined)
    });
    this.pendingTasks = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasks);
    this.unregisterOnDestroy = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef).onDestroy(() => this.destroy());
    this.status = computed(() => projectStatusOfState(this.state()), ngDevMode ? createDebugNameObject(debugName, 'status') : undefined);
    this.error = computed(() => {
      const stream = this.state().stream?.();
      return stream && !isResolved(stream) ? stream.error : undefined;
    }, ngDevMode ? createDebugNameObject(debugName, 'error') : undefined);
  }
  set(value) {
    if (this.destroyed) {
      return;
    }
    const error = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.error);
    const state = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.state);
    if (!error) {
      const current = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.value);
      if (state.status === 'local' && (this.equal ? this.equal(current, value) : current === value)) {
        return;
      }
    }
    this.state.set({
      extRequest: state.extRequest,
      status: 'local',
      previousStatus: 'local',
      stream: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
        value
      }, ngDevMode ? createDebugNameObject(this.debugName, 'stream') : undefined)
    });
    this.abortInProgressLoad();
  }
  reload() {
    const {
      status
    } = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.state);
    if (status === 'idle' || status === 'loading') {
      return false;
    }
    this.extRequest.update(({
      request,
      reload
    }) => ({
      request,
      reload: reload + 1
    }));
    return true;
  }
  destroy() {
    this.destroyed = true;
    this.unregisterOnDestroy();
    this.effectRef.destroy();
    this.abortInProgressLoad();
    this.state.set({
      extRequest: {
        request: undefined,
        reload: 0
      },
      status: 'idle',
      previousStatus: 'idle',
      stream: undefined
    });
  }
  loadEffect() {
    var _this = this;
    return (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const extRequest = _this.extRequest();
      const {
        status: currentStatus,
        previousStatus
      } = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.state);
      if (extRequest.request === undefined) {
        return;
      } else if (currentStatus !== 'loading') {
        return;
      }
      _this.abortInProgressLoad();
      let resolvePendingTask = _this.resolvePendingTask = _this.pendingTasks.add();
      const {
        signal: abortSignal
      } = _this.pendingController = new AbortController();
      try {
        const stream = yield (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => {
          return _this.loaderFn({
            params: extRequest.request,
            request: extRequest.request,
            abortSignal,
            previous: {
              status: previousStatus
            }
          });
        });
        if (abortSignal.aborted || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.extRequest) !== extRequest) {
          return;
        }
        _this.state.set({
          extRequest,
          status: 'resolved',
          previousStatus: 'resolved',
          stream
        });
      } catch (err) {
        if (abortSignal.aborted || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.extRequest) !== extRequest) {
          return;
        }
        _this.state.set({
          extRequest,
          status: 'resolved',
          previousStatus: 'error',
          stream: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
            error: encapsulateResourceError(err)
          }, ngDevMode ? createDebugNameObject(_this.debugName, 'stream') : undefined)
        });
      } finally {
        resolvePendingTask?.();
        resolvePendingTask = undefined;
      }
    })();
  }
  abortInProgressLoad() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => this.pendingController?.abort());
    this.pendingController = undefined;
    this.resolvePendingTask?.();
    this.resolvePendingTask = undefined;
  }
}
function wrapEqualityFn(equal) {
  return (a, b) => a === undefined || b === undefined ? a === b : equal(a, b);
}
function getLoader(options) {
  if (isStreamingResourceOptions(options)) {
    return options.stream;
  }
  return /*#__PURE__*/function () {
    var _ref = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (params) {
      try {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
          value: yield options.loader(params)
        }, ngDevMode ? createDebugNameObject(options.debugName, 'stream') : undefined);
      } catch (err) {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
          error: encapsulateResourceError(err)
        }, ngDevMode ? createDebugNameObject(options.debugName, 'stream') : undefined);
      }
    });
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}
function isStreamingResourceOptions(options) {
  return !!options.stream;
}
function projectStatusOfState(state) {
  switch (state.status) {
    case 'loading':
      return state.extRequest.reload === 0 ? 'loading' : 'reloading';
    case 'resolved':
      return isResolved(state.stream()) ? 'resolved' : 'error';
    default:
      return state.status;
  }
}
function isResolved(state) {
  return state.error === undefined;
}
function createDebugNameObject(resourceDebugName, internalSignalDebugName) {
  return {
    debugName: `Resource${resourceDebugName ? '#' + resourceDebugName : ''}.${internalSignalDebugName}`
  };
}
function encapsulateResourceError(error) {
  if (isErrorLike(error)) {
    return error;
  }
  return new ResourceWrappedError(error);
}
function isErrorLike(error) {
  return error instanceof Error || typeof error === 'object' && typeof error.name === 'string' && typeof error.message === 'string';
}
class ResourceValueError extends Error {
  constructor(error) {
    super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, {
      cause: error
    });
  }
}
class ResourceWrappedError extends Error {
  constructor(error) {
    super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), {
      cause: error
    });
  }
}


/***/ },

/***/ 66248
/*!******************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_attribute-chunk.mjs ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attribute: () => (/* binding */ Attribute)
/* harmony export */ });
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

const Attribute = {
  JSACTION: 'jsaction'
};


/***/ },

/***/ 68262
/*!**********************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_linked_signal-chunk.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLinkedSignal: () => (/* binding */ createLinkedSignal),
/* harmony export */   linkedSignalSetFn: () => (/* binding */ linkedSignalSetFn),
/* harmony export */   linkedSignalUpdateFn: () => (/* binding */ linkedSignalUpdateFn)
/* harmony export */ });
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */


function createLinkedSignal(sourceFn, computationFn, equalityFn) {
  const node = Object.create(LINKED_SIGNAL_NODE);
  node.source = sourceFn;
  node.computation = computationFn;
  if (equalityFn != undefined) {
    node.equal = equalityFn;
  }
  const linkedSignalGetter = () => {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerAccessed)(node);
    if (node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  const getter = linkedSignalGetter;
  getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    getter.toString = () => `[LinkedSignal${debugName}: ${String(node.value)}]`;
  }
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runPostProducerCreatedFn)(node);
  return getter;
}
function linkedSignalSetFn(node, newValue) {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalSetFn)(node, newValue);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerMarkClean)(node);
}
function linkedSignalUpdateFn(node, updater) {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalUpdateFn)(node, updater);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerMarkClean)(node);
}
const LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.REACTIVE_NODE,
    value: _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET,
    dirty: true,
    error: null,
    equal: _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEquals,
    kind: 'linkedSignal',
    producerMustRecompute(node) {
      return node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET || node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING) {
        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');
      }
      const oldValue = node.value;
      node.value = _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING;
      const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerBeforeComputation)(node);
      let newValue;
      try {
        const newSourceValue = node.source();
        const prev = oldValue === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET || oldValue === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED ? undefined : {
          source: node.sourceValue,
          value: oldValue
        };
        newValue = node.computation(newSourceValue, prev);
        node.sourceValue = newSourceValue;
      } catch (err) {
        newValue = _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED;
        node.error = err;
      } finally {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerAfterComputation)(node, prevConsumer);
      }
      if (oldValue !== _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET && newValue !== _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();


/***/ },

/***/ 78330
/*!******************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_not_found-chunk.mjs ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOT_FOUND: () => (/* binding */ NOT_FOUND),
/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),
/* harmony export */   getCurrentInjector: () => (/* binding */ getCurrentInjector),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isNotFound: () => (/* binding */ isNotFound),
/* harmony export */   setCurrentInjector: () => (/* binding */ setCurrentInjector)
/* harmony export */ });
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

let _currentInjector = undefined;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function inject(token, options) {
  const currentInjector = getCurrentInjector();
  if (!currentInjector) {
    throw new Error('Current injector is not set.');
  }
  if (!token.ɵprov) {
    throw new Error('Token is not an injectable');
  }
  return currentInjector.retrieve(token, options);
}
const NOT_FOUND = /*#__PURE__*/Symbol('NotFound');
class NotFoundError extends Error {
  name = 'ɵNotFound';
  constructor(message) {
    super(message);
  }
}
function isNotFound(e) {
  return e === NOT_FOUND || e?.name === 'ɵNotFound';
}


/***/ },

/***/ 89204
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }

}])
//# sourceMappingURL=7580.js.map