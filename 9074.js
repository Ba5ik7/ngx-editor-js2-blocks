(self["webpackChunkdemo"] = self["webpackChunkdemo"] || []).push([[9074],{

/***/ 11817
/*!******************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_untracked-chunk.mjs ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AFTER_RENDER_SEQUENCES_TO_ADD: () => (/* binding */ AFTER_RENDER_SEQUENCES_TO_ADD),
/* harmony export */   ANIMATIONS: () => (/* binding */ ANIMATIONS),
/* harmony export */   CHILD_HEAD: () => (/* binding */ CHILD_HEAD),
/* harmony export */   CHILD_TAIL: () => (/* binding */ CHILD_TAIL),
/* harmony export */   CLEANUP: () => (/* binding */ CLEANUP),
/* harmony export */   CONTAINER_HEADER_OFFSET: () => (/* binding */ CONTAINER_HEADER_OFFSET),
/* harmony export */   CONTEXT: () => (/* binding */ CONTEXT),
/* harmony export */   ChangeDetectionScheduler: () => (/* binding */ ChangeDetectionScheduler),
/* harmony export */   CheckNoChangesMode: () => (/* binding */ CheckNoChangesMode),
/* harmony export */   DEBUG_TASK_TRACKER: () => (/* binding */ DEBUG_TASK_TRACKER),
/* harmony export */   DECLARATION_COMPONENT_VIEW: () => (/* binding */ DECLARATION_COMPONENT_VIEW),
/* harmony export */   DECLARATION_LCONTAINER: () => (/* binding */ DECLARATION_LCONTAINER),
/* harmony export */   DECLARATION_VIEW: () => (/* binding */ DECLARATION_VIEW),
/* harmony export */   DEHYDRATED_VIEWS: () => (/* binding */ DEHYDRATED_VIEWS),
/* harmony export */   DOCUMENT: () => (/* binding */ DOCUMENT),
/* harmony export */   DOC_PAGE_BASE_URL: () => (/* binding */ DOC_PAGE_BASE_URL),
/* harmony export */   DestroyRef: () => (/* binding */ DestroyRef),
/* harmony export */   EFFECTS: () => (/* binding */ EFFECTS),
/* harmony export */   EFFECTS_TO_SCHEDULE: () => (/* binding */ EFFECTS_TO_SCHEDULE),
/* harmony export */   EMBEDDED_VIEW_INJECTOR: () => (/* binding */ EMBEDDED_VIEW_INJECTOR),
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),
/* harmony export */   ENVIRONMENT: () => (/* binding */ ENVIRONMENT),
/* harmony export */   ENVIRONMENT_INITIALIZER: () => (/* binding */ ENVIRONMENT_INITIALIZER),
/* harmony export */   ERROR_DETAILS_PAGE_BASE_URL: () => (/* binding */ ERROR_DETAILS_PAGE_BASE_URL),
/* harmony export */   EffectRefImpl: () => (/* binding */ EffectRefImpl),
/* harmony export */   EffectScheduler: () => (/* binding */ EffectScheduler),
/* harmony export */   EnvironmentInjector: () => (/* binding */ EnvironmentInjector),
/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler),
/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),
/* harmony export */   FLAGS: () => (/* binding */ FLAGS),
/* harmony export */   HEADER_OFFSET: () => (/* binding */ HEADER_OFFSET),
/* harmony export */   HOST: () => (/* binding */ HOST),
/* harmony export */   HYDRATION: () => (/* binding */ HYDRATION),
/* harmony export */   ID: () => (/* binding */ ID),
/* harmony export */   INJECTOR: () => (/* binding */ INJECTOR$1),
/* harmony export */   INJECTOR$1: () => (/* binding */ INJECTOR),
/* harmony export */   INJECTOR_DEF_TYPES: () => (/* binding */ INJECTOR_DEF_TYPES),
/* harmony export */   INJECTOR_SCOPE: () => (/* binding */ INJECTOR_SCOPE),
/* harmony export */   INTERNAL_APPLICATION_ERROR_HANDLER: () => (/* binding */ INTERNAL_APPLICATION_ERROR_HANDLER),
/* harmony export */   InjectionToken: () => (/* binding */ InjectionToken),
/* harmony export */   Injector: () => (/* binding */ Injector),
/* harmony export */   MATH_ML_NAMESPACE: () => (/* binding */ MATH_ML_NAMESPACE),
/* harmony export */   MOVED_VIEWS: () => (/* binding */ MOVED_VIEWS),
/* harmony export */   NATIVE: () => (/* binding */ NATIVE),
/* harmony export */   NEXT: () => (/* binding */ NEXT),
/* harmony export */   NG_COMP_DEF: () => (/* binding */ NG_COMP_DEF),
/* harmony export */   NG_DIR_DEF: () => (/* binding */ NG_DIR_DEF),
/* harmony export */   NG_ELEMENT_ID: () => (/* binding */ NG_ELEMENT_ID),
/* harmony export */   NG_FACTORY_DEF: () => (/* binding */ NG_FACTORY_DEF),
/* harmony export */   NG_INJ_DEF: () => (/* binding */ NG_INJ_DEF),
/* harmony export */   NG_MOD_DEF: () => (/* binding */ NG_MOD_DEF),
/* harmony export */   NG_PIPE_DEF: () => (/* binding */ NG_PIPE_DEF),
/* harmony export */   NG_PROV_DEF: () => (/* binding */ NG_PROV_DEF),
/* harmony export */   NgZone: () => (/* binding */ NgZone),
/* harmony export */   NoopNgZone: () => (/* binding */ NoopNgZone),
/* harmony export */   NullInjector: () => (/* binding */ NullInjector),
/* harmony export */   ON_DESTROY_HOOKS: () => (/* binding */ ON_DESTROY_HOOKS),
/* harmony export */   PARENT: () => (/* binding */ PARENT),
/* harmony export */   PREORDER_HOOK_FLAGS: () => (/* binding */ PREORDER_HOOK_FLAGS),
/* harmony export */   PROVIDED_ZONELESS: () => (/* binding */ PROVIDED_ZONELESS),
/* harmony export */   PendingTasks: () => (/* binding */ PendingTasks),
/* harmony export */   PendingTasksInternal: () => (/* binding */ PendingTasksInternal),
/* harmony export */   QUERIES: () => (/* binding */ QUERIES),
/* harmony export */   R3Injector: () => (/* binding */ R3Injector),
/* harmony export */   REACTIVE_TEMPLATE_CONSUMER: () => (/* binding */ REACTIVE_TEMPLATE_CONSUMER),
/* harmony export */   RENDERER: () => (/* binding */ RENDERER),
/* harmony export */   RuntimeError: () => (/* binding */ RuntimeError),
/* harmony export */   SCHEDULE_IN_ROOT_ZONE: () => (/* binding */ SCHEDULE_IN_ROOT_ZONE),
/* harmony export */   SCHEDULE_IN_ROOT_ZONE_DEFAULT: () => (/* binding */ SCHEDULE_IN_ROOT_ZONE_DEFAULT),
/* harmony export */   SVG_NAMESPACE: () => (/* binding */ SVG_NAMESPACE),
/* harmony export */   TVIEW: () => (/* binding */ TVIEW),
/* harmony export */   T_HOST: () => (/* binding */ T_HOST),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   VIEW_REFS: () => (/* binding */ VIEW_REFS),
/* harmony export */   Version: () => (/* binding */ Version),
/* harmony export */   ViewContext: () => (/* binding */ ViewContext),
/* harmony export */   XSS_SECURITY_URL: () => (/* binding */ XSS_SECURITY_URL),
/* harmony export */   ZONELESS_ENABLED: () => (/* binding */ ZONELESS_ENABLED),
/* harmony export */   _global: () => (/* binding */ _global),
/* harmony export */   addToArray: () => (/* binding */ addToArray),
/* harmony export */   angularZoneInstanceIdProperty: () => (/* binding */ angularZoneInstanceIdProperty),
/* harmony export */   arrayEquals: () => (/* binding */ arrayEquals),
/* harmony export */   arrayInsert2: () => (/* binding */ arrayInsert2),
/* harmony export */   arraySplice: () => (/* binding */ arraySplice),
/* harmony export */   assertComponentType: () => (/* binding */ assertComponentType),
/* harmony export */   assertDefined: () => (/* binding */ assertDefined),
/* harmony export */   assertDirectiveDef: () => (/* binding */ assertDirectiveDef),
/* harmony export */   assertDomNode: () => (/* binding */ assertDomNode),
/* harmony export */   assertElement: () => (/* binding */ assertElement),
/* harmony export */   assertEqual: () => (/* binding */ assertEqual),
/* harmony export */   assertFirstCreatePass: () => (/* binding */ assertFirstCreatePass),
/* harmony export */   assertFirstUpdatePass: () => (/* binding */ assertFirstUpdatePass),
/* harmony export */   assertFunction: () => (/* binding */ assertFunction),
/* harmony export */   assertGreaterThan: () => (/* binding */ assertGreaterThan),
/* harmony export */   assertGreaterThanOrEqual: () => (/* binding */ assertGreaterThanOrEqual),
/* harmony export */   assertHasParent: () => (/* binding */ assertHasParent),
/* harmony export */   assertInInjectionContext: () => (/* binding */ assertInInjectionContext),
/* harmony export */   assertIndexInDeclRange: () => (/* binding */ assertIndexInDeclRange),
/* harmony export */   assertIndexInExpandoRange: () => (/* binding */ assertIndexInExpandoRange),
/* harmony export */   assertIndexInRange: () => (/* binding */ assertIndexInRange),
/* harmony export */   assertInjectImplementationNotEqual: () => (/* binding */ assertInjectImplementationNotEqual),
/* harmony export */   assertLContainer: () => (/* binding */ assertLContainer),
/* harmony export */   assertLView: () => (/* binding */ assertLView),
/* harmony export */   assertLessThan: () => (/* binding */ assertLessThan),
/* harmony export */   assertNgModuleType: () => (/* binding */ assertNgModuleType),
/* harmony export */   assertNodeInjector: () => (/* binding */ assertNodeInjector),
/* harmony export */   assertNotDefined: () => (/* binding */ assertNotDefined),
/* harmony export */   assertNotEqual: () => (/* binding */ assertNotEqual),
/* harmony export */   assertNotInReactiveContext: () => (/* binding */ assertNotInReactiveContext),
/* harmony export */   assertNotReactive: () => (/* binding */ assertNotReactive),
/* harmony export */   assertNotSame: () => (/* binding */ assertNotSame),
/* harmony export */   assertNumber: () => (/* binding */ assertNumber),
/* harmony export */   assertNumberInRange: () => (/* binding */ assertNumberInRange),
/* harmony export */   assertOneOf: () => (/* binding */ assertOneOf),
/* harmony export */   assertParentView: () => (/* binding */ assertParentView),
/* harmony export */   assertProjectionSlots: () => (/* binding */ assertProjectionSlots),
/* harmony export */   assertSame: () => (/* binding */ assertSame),
/* harmony export */   assertString: () => (/* binding */ assertString),
/* harmony export */   assertTIcu: () => (/* binding */ assertTIcu),
/* harmony export */   assertTNode: () => (/* binding */ assertTNode),
/* harmony export */   assertTNodeCreationIndex: () => (/* binding */ assertTNodeCreationIndex),
/* harmony export */   assertTNodeForLView: () => (/* binding */ assertTNodeForLView),
/* harmony export */   assertTNodeForTView: () => (/* binding */ assertTNodeForTView),
/* harmony export */   attachInjectFlag: () => (/* binding */ attachInjectFlag),
/* harmony export */   concatStringsWithSpace: () => (/* binding */ concatStringsWithSpace),
/* harmony export */   convertToBitFlags: () => (/* binding */ convertToBitFlags),
/* harmony export */   createInjector: () => (/* binding */ createInjector),
/* harmony export */   createInjectorWithoutInjectorInstances: () => (/* binding */ createInjectorWithoutInjectorInstances),
/* harmony export */   cyclicDependencyError: () => (/* binding */ cyclicDependencyError),
/* harmony export */   cyclicDependencyErrorWithDetails: () => (/* binding */ cyclicDependencyErrorWithDetails),
/* harmony export */   debugStringifyTypeForError: () => (/* binding */ debugStringifyTypeForError),
/* harmony export */   decreaseElementDepthCount: () => (/* binding */ decreaseElementDepthCount),
/* harmony export */   deepForEach: () => (/* binding */ deepForEach),
/* harmony export */   effect: () => (/* binding */ effect),
/* harmony export */   emitAfterRenderEffectPhaseCreatedEvent: () => (/* binding */ emitAfterRenderEffectPhaseCreatedEvent),
/* harmony export */   emitInjectEvent: () => (/* binding */ emitInjectEvent),
/* harmony export */   emitInjectorToCreateInstanceEvent: () => (/* binding */ emitInjectorToCreateInstanceEvent),
/* harmony export */   emitInstanceCreatedByInjectorEvent: () => (/* binding */ emitInstanceCreatedByInjectorEvent),
/* harmony export */   emitProviderConfiguredEvent: () => (/* binding */ emitProviderConfiguredEvent),
/* harmony export */   enterDI: () => (/* binding */ enterDI),
/* harmony export */   enterSkipHydrationBlock: () => (/* binding */ enterSkipHydrationBlock),
/* harmony export */   enterView: () => (/* binding */ enterView),
/* harmony export */   errorHandlerEnvironmentInitializer: () => (/* binding */ errorHandlerEnvironmentInitializer),
/* harmony export */   fillProperties: () => (/* binding */ fillProperties),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   formatRuntimeError: () => (/* binding */ formatRuntimeError),
/* harmony export */   forwardRef: () => (/* binding */ forwardRef),
/* harmony export */   getBindingIndex: () => (/* binding */ getBindingIndex),
/* harmony export */   getBindingRoot: () => (/* binding */ getBindingRoot),
/* harmony export */   getBindingsEnabled: () => (/* binding */ getBindingsEnabled),
/* harmony export */   getClosureSafeProperty: () => (/* binding */ getClosureSafeProperty),
/* harmony export */   getComponentDef: () => (/* binding */ getComponentDef),
/* harmony export */   getComponentLViewByIndex: () => (/* binding */ getComponentLViewByIndex),
/* harmony export */   getConstant: () => (/* binding */ getConstant),
/* harmony export */   getContextLView: () => (/* binding */ getContextLView),
/* harmony export */   getCurrentDirectiveDef: () => (/* binding */ getCurrentDirectiveDef),
/* harmony export */   getCurrentDirectiveIndex: () => (/* binding */ getCurrentDirectiveIndex),
/* harmony export */   getCurrentParentTNode: () => (/* binding */ getCurrentParentTNode),
/* harmony export */   getCurrentQueryIndex: () => (/* binding */ getCurrentQueryIndex),
/* harmony export */   getCurrentTNode: () => (/* binding */ getCurrentTNode),
/* harmony export */   getCurrentTNodePlaceholderOk: () => (/* binding */ getCurrentTNodePlaceholderOk),
/* harmony export */   getDirectiveDef: () => (/* binding */ getDirectiveDef),
/* harmony export */   getDirectiveDefOrThrow: () => (/* binding */ getDirectiveDefOrThrow),
/* harmony export */   getElementDepthCount: () => (/* binding */ getElementDepthCount),
/* harmony export */   getFactoryDef: () => (/* binding */ getFactoryDef),
/* harmony export */   getInjectableDef: () => (/* binding */ getInjectableDef),
/* harmony export */   getInjectorDef: () => (/* binding */ getInjectorDef),
/* harmony export */   getLView: () => (/* binding */ getLView),
/* harmony export */   getLViewParent: () => (/* binding */ getLViewParent),
/* harmony export */   getNamespace: () => (/* binding */ getNamespace),
/* harmony export */   getNativeByIndex: () => (/* binding */ getNativeByIndex),
/* harmony export */   getNativeByTNode: () => (/* binding */ getNativeByTNode),
/* harmony export */   getNativeByTNodeOrNull: () => (/* binding */ getNativeByTNodeOrNull),
/* harmony export */   getNgModuleDef: () => (/* binding */ getNgModuleDef),
/* harmony export */   getNgModuleDefOrThrow: () => (/* binding */ getNgModuleDefOrThrow),
/* harmony export */   getNullInjector: () => (/* binding */ getNullInjector),
/* harmony export */   getOrCreateLViewCleanup: () => (/* binding */ getOrCreateLViewCleanup),
/* harmony export */   getOrCreateTViewCleanup: () => (/* binding */ getOrCreateTViewCleanup),
/* harmony export */   getPipeDef: () => (/* binding */ getPipeDef),
/* harmony export */   getSelectedIndex: () => (/* binding */ getSelectedIndex),
/* harmony export */   getSelectedTNode: () => (/* binding */ getSelectedTNode),
/* harmony export */   getTNode: () => (/* binding */ getTNode),
/* harmony export */   getTView: () => (/* binding */ getTView),
/* harmony export */   hasI18n: () => (/* binding */ hasI18n),
/* harmony export */   importProvidersFrom: () => (/* binding */ importProvidersFrom),
/* harmony export */   increaseElementDepthCount: () => (/* binding */ increaseElementDepthCount),
/* harmony export */   incrementBindingIndex: () => (/* binding */ incrementBindingIndex),
/* harmony export */   initNgDevMode: () => (/* binding */ initNgDevMode),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   injectRootLimpMode: () => (/* binding */ injectRootLimpMode),
/* harmony export */   internalImportProvidersFrom: () => (/* binding */ internalImportProvidersFrom),
/* harmony export */   isClassProvider: () => (/* binding */ isClassProvider),
/* harmony export */   isComponentDef: () => (/* binding */ isComponentDef),
/* harmony export */   isComponentHost: () => (/* binding */ isComponentHost),
/* harmony export */   isContentQueryHost: () => (/* binding */ isContentQueryHost),
/* harmony export */   isCreationMode: () => (/* binding */ isCreationMode),
/* harmony export */   isCurrentTNodeParent: () => (/* binding */ isCurrentTNodeParent),
/* harmony export */   isDestroyed: () => (/* binding */ isDestroyed),
/* harmony export */   isDirectiveHost: () => (/* binding */ isDirectiveHost),
/* harmony export */   isEnvironmentProviders: () => (/* binding */ isEnvironmentProviders),
/* harmony export */   isExhaustiveCheckNoChanges: () => (/* binding */ isExhaustiveCheckNoChanges),
/* harmony export */   isForwardRef: () => (/* binding */ isForwardRef),
/* harmony export */   isInCheckNoChangesMode: () => (/* binding */ isInCheckNoChangesMode),
/* harmony export */   isInI18nBlock: () => (/* binding */ isInI18nBlock),
/* harmony export */   isInInjectionContext: () => (/* binding */ isInInjectionContext),
/* harmony export */   isInSkipHydrationBlock: () => (/* binding */ isInSkipHydrationBlock),
/* harmony export */   isInjectable: () => (/* binding */ isInjectable),
/* harmony export */   isLContainer: () => (/* binding */ isLContainer),
/* harmony export */   isLView: () => (/* binding */ isLView),
/* harmony export */   isProjectionTNode: () => (/* binding */ isProjectionTNode),
/* harmony export */   isRefreshingViews: () => (/* binding */ isRefreshingViews),
/* harmony export */   isRootView: () => (/* binding */ isRootView),
/* harmony export */   isSkipHydrationRootTNode: () => (/* binding */ isSkipHydrationRootTNode),
/* harmony export */   isStandalone: () => (/* binding */ isStandalone),
/* harmony export */   isTypeProvider: () => (/* binding */ isTypeProvider),
/* harmony export */   keyValueArrayGet: () => (/* binding */ keyValueArrayGet),
/* harmony export */   keyValueArrayIndexOf: () => (/* binding */ keyValueArrayIndexOf),
/* harmony export */   keyValueArraySet: () => (/* binding */ keyValueArraySet),
/* harmony export */   lastNodeWasCreated: () => (/* binding */ lastNodeWasCreated),
/* harmony export */   leaveDI: () => (/* binding */ leaveDI),
/* harmony export */   leaveSkipHydrationBlock: () => (/* binding */ leaveSkipHydrationBlock),
/* harmony export */   leaveView: () => (/* binding */ leaveView),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   makeEnvironmentProviders: () => (/* binding */ makeEnvironmentProviders),
/* harmony export */   markAncestorsForTraversal: () => (/* binding */ markAncestorsForTraversal),
/* harmony export */   markViewForRefresh: () => (/* binding */ markViewForRefresh),
/* harmony export */   newArray: () => (/* binding */ newArray),
/* harmony export */   nextBindingIndex: () => (/* binding */ nextBindingIndex),
/* harmony export */   nextContextImpl: () => (/* binding */ nextContextImpl),
/* harmony export */   provideBrowserGlobalErrorListeners: () => (/* binding */ provideBrowserGlobalErrorListeners),
/* harmony export */   provideEnvironmentInitializer: () => (/* binding */ provideEnvironmentInitializer),
/* harmony export */   providerToFactory: () => (/* binding */ providerToFactory),
/* harmony export */   removeFromArray: () => (/* binding */ removeFromArray),
/* harmony export */   removeLViewOnDestroy: () => (/* binding */ removeLViewOnDestroy),
/* harmony export */   renderStringify: () => (/* binding */ renderStringify),
/* harmony export */   requiresRefreshOrTraversal: () => (/* binding */ requiresRefreshOrTraversal),
/* harmony export */   resetPreOrderHookFlags: () => (/* binding */ resetPreOrderHookFlags),
/* harmony export */   resolveForwardRef: () => (/* binding */ resolveForwardRef),
/* harmony export */   runInInjectionContext: () => (/* binding */ runInInjectionContext),
/* harmony export */   runInInjectorProfilerContext: () => (/* binding */ runInInjectorProfilerContext),
/* harmony export */   scheduleCallbackWithMicrotask: () => (/* binding */ scheduleCallbackWithMicrotask),
/* harmony export */   scheduleCallbackWithRafRace: () => (/* binding */ scheduleCallbackWithRafRace),
/* harmony export */   setBindingIndex: () => (/* binding */ setBindingIndex),
/* harmony export */   setBindingRootForHostBindings: () => (/* binding */ setBindingRootForHostBindings),
/* harmony export */   setCurrentDirectiveIndex: () => (/* binding */ setCurrentDirectiveIndex),
/* harmony export */   setCurrentQueryIndex: () => (/* binding */ setCurrentQueryIndex),
/* harmony export */   setCurrentTNode: () => (/* binding */ setCurrentTNode),
/* harmony export */   setCurrentTNodeAsNotParent: () => (/* binding */ setCurrentTNodeAsNotParent),
/* harmony export */   setInI18nBlock: () => (/* binding */ setInI18nBlock),
/* harmony export */   setInjectImplementation: () => (/* binding */ setInjectImplementation),
/* harmony export */   setInjectorProfiler: () => (/* binding */ setInjectorProfiler),
/* harmony export */   setInjectorProfilerContext: () => (/* binding */ setInjectorProfilerContext),
/* harmony export */   setIsInCheckNoChangesMode: () => (/* binding */ setIsInCheckNoChangesMode),
/* harmony export */   setIsRefreshingViews: () => (/* binding */ setIsRefreshingViews),
/* harmony export */   setSelectedIndex: () => (/* binding */ setSelectedIndex),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   signalAsReadonlyFn: () => (/* binding */ signalAsReadonlyFn),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   storeCleanupWithContext: () => (/* binding */ storeCleanupWithContext),
/* harmony export */   storeLViewOnDestroy: () => (/* binding */ storeLViewOnDestroy),
/* harmony export */   stringify: () => (/* binding */ stringify),
/* harmony export */   stringifyForError: () => (/* binding */ stringifyForError),
/* harmony export */   throwError: () => (/* binding */ throwError),
/* harmony export */   throwProviderNotFoundError: () => (/* binding */ throwProviderNotFoundError),
/* harmony export */   truncateMiddle: () => (/* binding */ truncateMiddle),
/* harmony export */   untracked: () => (/* binding */ untracked),
/* harmony export */   unwrapLView: () => (/* binding */ unwrapLView),
/* harmony export */   unwrapRNode: () => (/* binding */ unwrapRNode),
/* harmony export */   updateAncestorTraversalFlagsOnAttach: () => (/* binding */ updateAncestorTraversalFlagsOnAttach),
/* harmony export */   viewAttachedToChangeDetector: () => (/* binding */ viewAttachedToChangeDetector),
/* harmony export */   viewAttachedToContainer: () => (/* binding */ viewAttachedToContainer),
/* harmony export */   walkProviderTree: () => (/* binding */ walkProviderTree),
/* harmony export */   walkUpViews: () => (/* binding */ walkUpViews),
/* harmony export */   wasLastNodeCreated: () => (/* binding */ wasLastNodeCreated),
/* harmony export */   "ɵunwrapWritableSignal": () => (/* binding */ ɵunwrapWritableSignal),
/* harmony export */   "ɵɵdefineInjectable": () => (/* binding */ ɵɵdefineInjectable),
/* harmony export */   "ɵɵdefineInjector": () => (/* binding */ ɵɵdefineInjector),
/* harmony export */   "ɵɵdisableBindings": () => (/* binding */ ɵɵdisableBindings),
/* harmony export */   "ɵɵenableBindings": () => (/* binding */ ɵɵenableBindings),
/* harmony export */   "ɵɵinject": () => (/* binding */ ɵɵinject),
/* harmony export */   "ɵɵinvalidFactoryDep": () => (/* binding */ ɵɵinvalidFactoryDep),
/* harmony export */   "ɵɵnamespaceHTML": () => (/* binding */ ɵɵnamespaceHTML),
/* harmony export */   "ɵɵnamespaceMathML": () => (/* binding */ ɵɵnamespaceMathML),
/* harmony export */   "ɵɵnamespaceSVG": () => (/* binding */ ɵɵnamespaceSVG),
/* harmony export */   "ɵɵresetView": () => (/* binding */ ɵɵresetView),
/* harmony export */   "ɵɵrestoreView": () => (/* binding */ ɵɵrestoreView)
/* harmony export */ });
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 44866);
/* harmony import */ var _not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_not_found-chunk.mjs */ 78330);
/* harmony import */ var _angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core/primitives/signals */ 95094);
/* harmony import */ var _angular_core_primitives_di__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core/primitives/di */ 20144);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */






class Version {
  full;
  major;
  minor;
  patch;
  constructor(full) {
    this.full = full;
    const parts = full.split('.');
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join('.');
  }
}
const VERSION = /* @__PURE__ */new Version('21.1.0');
const DOC_PAGE_BASE_URL = /*#__PURE__*/(() => {
  const full = VERSION.full;
  const isPreRelease = full.includes('-next') || full.includes('-rc') || full === '0.0.0' + '-PLACEHOLDER';
  const prefix = isPreRelease ? 'next' : `v${VERSION.major}`;
  return `https://${prefix}.angular.dev`;
})();
const ERROR_DETAILS_PAGE_BASE_URL = /*#__PURE__*/(() => {
  return `${DOC_PAGE_BASE_URL}/errors`;
})();
const XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';
class RuntimeError extends Error {
  code;
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
}
function formatRuntimeErrorCode(code) {
  return `NG0${Math.abs(code)}`;
}
function formatRuntimeError(code, message) {
  const fullCode = formatRuntimeErrorCode(code);
  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? '.' : '';
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
const _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== 'undefined' ? location.toString() : '';
  const newCounters = {
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0,
    deferBlocksWithIncrementalHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
  if (!allowNgDevModeTrue) {
    _global['ngDevMode'] = false;
  } else {
    if (typeof _global['ngDevMode'] !== 'object') {
      _global['ngDevMode'] = {};
    }
    Object.assign(_global['ngDevMode'], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
    if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== 'undefined' && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Could not find renamed property on target object.' : '');
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === 'string') {
    return token;
  }
  if (Array.isArray(token)) {
    return `[${token.map(stringify).join(', ')}]`;
  }
  if (token == null) {
    return '' + token;
  }
  const name = token.overriddenName || token.name;
  if (name) {
    return `${name}`;
  }
  const result = token.toString();
  if (result == null) {
    return '' + result;
  }
  const newLineIndex = result.indexOf('\n');
  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;
}
function concatStringsWithSpace(before, after) {
  if (!before) return after || '';
  if (!after) return before;
  return `${before} ${after}`;
}
function truncateMiddle(str, maxLength = 100) {
  if (!str || maxLength < 1 || str.length <= maxLength) return str;
  if (maxLength == 1) return str.substring(0, 1) + '...';
  const halfLimit = Math.round(maxLength / 2);
  return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);
}
const __forward_ref__ = /*#__PURE__*/getClosureSafeProperty({
  __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function () {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === 'number')) {
    throwError(msg, typeof actual, 'number', '===');
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, 'Expected a number');
  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');
  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');
}
function assertString(actual, msg) {
  if (!(typeof actual === 'string')) {
    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === 'function')) {
    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError(msg, actual, expected, '==');
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError(msg, actual, expected, '!=');
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError(msg, actual, expected, '===');
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError(msg, actual, expected, '!==');
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError(msg, actual, expected, '<');
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError(msg, actual, expected, '<=');
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError(msg, actual, expected, '>');
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError(msg, actual, expected, '>=');
  }
}
function assertNotDefined(actual, msg) {
  if (actual != null) {
    throwError(msg, actual, null, '==');
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError(msg, actual, null, '!=');
  }
}
function throwError(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, 'Array must be defined.');
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1) return true;
  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function assertNotReactive(fn) {
  if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getActiveConsumer)() !== null) {
    throwError(`${fn}() should never be called in a reactive context.`);
  }
}
function ɵɵdefineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: undefined
  };
}
function ɵɵdefineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF);
}
function isInjectable(type) {
  return getInjectableDef(type) !== null;
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) && type[field] || null;
}
function getInheritedInjectableDef(type) {
  const def = type?.[NG_PROV_DEF] ?? null;
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type) {
  return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;
}
const NG_PROV_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵprov: getClosureSafeProperty
});
const NG_INJ_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵinj: getClosureSafeProperty
});
class InjectionToken {
  _desc;
  ngMetadataName = 'InjectionToken';
  ɵprov;
  constructor(_desc, options) {
    this._desc = _desc;
    this.ɵprov = undefined;
    if (typeof options == 'number') {
      (typeof ngDevMode === 'undefined' || ngDevMode) && assertLessThan(options, 0, 'Only negative numbers are supported here');
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== undefined) {
      this.ɵprov = ɵɵdefineInjectable({
        token: this,
        providedIn: options.providedIn || 'root',
        factory: options.factory
      });
    }
  }
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
}
let _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context) {
  !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context;
  return previous;
}
const injectorProfilerCallbacks = [];
const NOOP_PROFILER_REMOVAL = () => {};
function removeProfiler(profiler) {
  const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);
  if (profilerIdx !== -1) {
    injectorProfilerCallbacks.splice(profilerIdx, 1);
  }
}
function setInjectorProfiler(injectorProfiler) {
  !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');
  if (injectorProfiler !== null) {
    if (!injectorProfilerCallbacks.includes(injectorProfiler)) {
      injectorProfilerCallbacks.push(injectorProfiler);
    }
    return () => removeProfiler(injectorProfiler);
  } else {
    injectorProfilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
function injectorProfiler(event) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  for (let i = 0; i < injectorProfilerCallbacks.length; i++) {
    const injectorProfilerCallback = injectorProfilerCallbacks[i];
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  let token;
  if (typeof eventProvider === 'function') {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.ɵprov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: {
      token,
      provider,
      isViewProvider
    }
  });
}
function emitInjectorToCreateInstanceEvent(token) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 5,
    context: getInjectorProfilerContext(),
    token: token
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: {
      value: instance
    }
  });
}
function emitInjectEvent(token, value, flags) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: {
      token,
      value,
      flags
    }
  });
}
function emitEffectCreatedEvent(effect) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 3,
    context: getInjectorProfilerContext(),
    effect
  });
}
function emitAfterRenderEffectPhaseCreatedEvent(effectPhase) {
  !ngDevMode && throwError('Injector profiler should never be called in production mode');
  injectorProfiler({
    type: 4,
    context: getInjectorProfilerContext(),
    effectPhase
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError('runInInjectorProfilerContext should never be called in production mode');
  const prevInjectContext = setInjectorProfilerContext({
    injector,
    token
  });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value) {
  return value && !!value.ɵproviders;
}
const NG_COMP_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵcmp: getClosureSafeProperty
});
const NG_DIR_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵdir: getClosureSafeProperty
});
const NG_PIPE_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵpipe: getClosureSafeProperty
});
const NG_MOD_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵmod: getClosureSafeProperty
});
const NG_FACTORY_DEF = /*#__PURE__*/getClosureSafeProperty({
  ɵfac: getClosureSafeProperty
});
const NG_ELEMENT_ID = /*#__PURE__*/getClosureSafeProperty({
  __NG_ELEMENT_ID__: getClosureSafeProperty
});
const NG_ENV_ID = /*#__PURE__*/getClosureSafeProperty({
  __NG_ENV_ID__: getClosureSafeProperty
});
function getNgModuleDef(type) {
  assertTypeDefined(type, '@NgModule');
  return type[NG_MOD_DEF] || null;
}
function getNgModuleDefOrThrow(type) {
  const ngModuleDef = getNgModuleDef(type);
  if (!ngModuleDef) {
    throw new RuntimeError(915, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵmod' property.`);
  }
  return ngModuleDef;
}
function getComponentDef(type) {
  assertTypeDefined(type, '@Component');
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDefOrThrow(type) {
  const def = getDirectiveDef(type);
  if (!def) {
    throw new RuntimeError(916, (typeof ngDevMode === 'undefined' || ngDevMode) && `Type ${stringify(type)} does not have 'ɵdir' property.`);
  }
  return def;
}
function getDirectiveDef(type) {
  assertTypeDefined(type, '@Directive');
  return type[NG_DIR_DEF] || null;
}
function getPipeDef(type) {
  assertTypeDefined(type, '@Pipe');
  return type[NG_PIPE_DEF] || null;
}
function assertTypeDefined(type, symbolType) {
  if (type == null) {
    throw new RuntimeError(-919, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot read ${symbolType} metadata. This can indicate a runtime ` + `circular dependency in your app that needs to be resolved.`);
  }
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);
  return def !== null && def.standalone;
}
function renderStringify(value) {
  if (typeof value === 'string') return value;
  if (value == null) return '';
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === 'function') return value.name || value.toString();
  if (typeof value === 'object' && value != null && typeof value.type === 'function') {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function debugStringifyTypeForError(type) {
  const componentDef = getComponentDef(type);
  if (componentDef !== null && componentDef.debugInfo) {
    return stringifyTypeFromDebugInfo(componentDef.debugInfo);
  }
  return stringifyForError(type);
}
function stringifyTypeFromDebugInfo(debugInfo) {
  if (!debugInfo.filePath || !debugInfo.lineNumber) {
    return debugInfo.className;
  } else {
    return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;
  }
}
const NG_RUNTIME_ERROR_CODE = /*#__PURE__*/getClosureSafeProperty({
  'ngErrorCode': getClosureSafeProperty
});
const NG_RUNTIME_ERROR_MESSAGE = /*#__PURE__*/getClosureSafeProperty({
  'ngErrorMessage': getClosureSafeProperty
});
const NG_TOKEN_PATH = /*#__PURE__*/getClosureSafeProperty({
  'ngTokenPath': getClosureSafeProperty
});
function cyclicDependencyError(token, path) {
  const message = ngDevMode ? `Circular dependency detected for \`${token}\`.` : '';
  return createRuntimeError(message, -200, path);
}
function cyclicDependencyErrorWithDetails(token, path) {
  return augmentRuntimeError(cyclicDependencyError(token, path), null);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.ɵfromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error('Invalid provider');
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;
  throw new RuntimeError(-201, errorMessage);
}
function prependTokenToDependencyPath(error, token) {
  error[NG_TOKEN_PATH] ??= [];
  const currentPath = error[NG_TOKEN_PATH];
  let pathStr;
  if (typeof token === 'object' && 'multi' in token && token?.multi === true) {
    assertDefined(token.provide, 'Token with multi: true should have a provide property');
    pathStr = stringifyForError(token.provide);
  } else {
    pathStr = stringifyForError(token);
  }
  if (currentPath[0] !== pathStr) {
    error[NG_TOKEN_PATH].unshift(pathStr);
  }
}
function augmentRuntimeError(error, source) {
  const tokenPath = error[NG_TOKEN_PATH];
  const errorCode = error[NG_RUNTIME_ERROR_CODE];
  const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;
  error.message = formatErrorMessage(message, errorCode, tokenPath, source);
  return error;
}
function createRuntimeError(message, code, path) {
  const error = new RuntimeError(code, message);
  error[NG_RUNTIME_ERROR_CODE] = code;
  error[NG_RUNTIME_ERROR_MESSAGE] = message;
  if (path) {
    error[NG_TOKEN_PATH] = path;
  }
  return error;
}
function getRuntimeErrorCode(error) {
  return error[NG_RUNTIME_ERROR_CODE];
}
function formatErrorMessage(text, code, path = [], source = null) {
  let pathDetails = '';
  if (path && path.length > 1) {
    pathDetails = ` Path: ${path.join(' -> ')}.`;
  }
  const sourceDetails = source ? ` Source: ${source}.` : '';
  return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);
}
let _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == 'root') {
    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & 8) return null;
  if (notFoundValue !== undefined) return notFoundValue;
  throwProviderNotFoundError(token, typeof ngDevMode !== 'undefined' && ngDevMode ? 'Injector' : '');
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');
}
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const DI_DECORATOR_FLAG = '__NG_DI_FLAG__';
class RetrievingInjector {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  retrieve(token, options) {
    const flags = convertToBitFlags(options) || 0;
    try {
      return this.injector.get(token, flags & 8 ? null : THROW_IF_NOT_FOUND, flags);
    } catch (e) {
      if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isNotFound)(e)) {
        return e;
      }
      throw e;
    }
  }
}
function injectInjectorOnly(token, flags = 0) {
  const currentInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCurrentInjector)();
  if (currentInjector === undefined) {
    throw new RuntimeError(-203, ngDevMode && `The \`${stringify(token)}\` token injection failed. \`inject()\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (currentInjector === null) {
    return injectRootLimpMode(token, undefined, flags);
  } else {
    const options = convertToInjectOptions(flags);
    const value = currentInjector.retrieve(token, options);
    ngDevMode && emitInjectEvent(token, value, flags);
    if ((0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.isNotFound)(value)) {
      if (options.optional) {
        return null;
      }
      throw value;
    }
    return value;
  }
}
function ɵɵinject(token, flags = 0) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function ɵɵinvalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, options) {
  return ɵɵinject(token, convertToBitFlags(options));
}
function convertToBitFlags(flags) {
  if (typeof flags === 'undefined' || typeof flags === 'number') {
    return flags;
  }
  return 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function convertToInjectOptions(flags) {
  return {
    optional: !!(flags & 8),
    host: !!(flags & 1),
    self: !!(flags & 2),
    skipSelf: !!(flags & 4)
  };
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && 'Arguments array must have arguments.');
      }
      let type = undefined;
      let flags = 0;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === 'number') {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(ɵɵinject(type, flags));
    } else {
      args.push(ɵɵinject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input, fn) {
  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arraySplice(array, index, count) {
  const length = array.length - count;
  while (index < length) {
    array[index] = array[index + count];
    index++;
  }
  while (count--) {
    array.pop();
  }
}
function arrayInsert2(array, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return undefined;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
const EMPTY_OBJ = {};
const EMPTY_ARRAY = [];
if ((typeof ngDevMode === 'undefined' || ngDevMode) && /*#__PURE__*/initNgDevMode()) {
  /*#__PURE__*/Object.freeze(EMPTY_OBJ);
  /*#__PURE__*/Object.freeze(EMPTY_ARRAY);
}
const ENVIRONMENT_INITIALIZER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');
const INJECTOR$1 = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR' : '', -1);
const INJECTOR_DEF_TYPES = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'INJECTOR_DEF_TYPES' : '');
class NullInjector {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const message = ngDevMode ? `No provider found for \`${stringify(token)}\`.` : '';
      const error = createRuntimeError(message, -201);
      error.name = 'ɵNotFound';
      throw error;
    }
    return notFoundValue;
  }
}
function makeEnvironmentProviders(providers) {
  return {
    ɵproviders: providers
  };
}
function provideEnvironmentInitializer(initializerFn) {
  return makeEnvironmentProviders([{
    provide: ENVIRONMENT_INITIALIZER,
    multi: true,
    useValue: initializerFn
  }]);
}
function importProvidersFrom(...sources) {
  return {
    ɵproviders: internalImportProvidersFrom(true, sources),
    ɵfromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = new Set();
  let injectorTypesWithProviders;
  const collectProviders = provider => {
    providersOut.push(provider);
  };
  deepForEach(sources, source => {
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== undefined) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers
    } = typesWithProviders[i];
    deepForEachProvider(providers, provider => {
      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container) return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify).concat(defName);
    throw cyclicDependencyErrorWithDetails(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, imported => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== undefined) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({
        provide: defType,
        useFactory: factory,
        deps: EMPTY_ARRAY
      }, defType);
      visitor({
        provide: INJECTOR_DEF_TYPES,
        useValue: defType,
        multi: true
      }, defType);
      visitor({
        provide: ENVIRONMENT_INITIALIZER,
        useValue: () => ɵɵinject(defType),
        multi: true
      }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, provider => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== undefined;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function deepForEachProvider(providers, fn) {
  for (let provider of providers) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.ɵproviders;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
const USE_VALUE = /*#__PURE__*/getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value) {
  return value !== null && typeof value == 'object' && USE_VALUE in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === 'function';
}
function isClassProvider(value) {
  return !!value.useClass;
}
const INJECTOR_SCOPE = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Set Injector scope.' : '');
const NOT_YET = {};
const CIRCULAR = {};
let NULL_INJECTOR = undefined;
function getNullInjector() {
  if (NULL_INJECTOR === undefined) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
class EnvironmentInjector {}
class R3Injector extends EnvironmentInjector {
  parent;
  source;
  scopes;
  records = /*#__PURE__*/new Map();
  _ngOnDestroyHooks = /*#__PURE__*/new Set();
  _onDestroyHooks = [];
  get destroyed() {
    return this._destroyed;
  }
  _destroyed = false;
  injectorDefTypes;
  constructor(providers, parent, source, scopes) {
    super();
    this.parent = parent;
    this.source = source;
    this.scopes = scopes;
    forEachSingleProvider(providers, provider => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(undefined, this));
    if (scopes.has('environment')) {
      this.records.set(EnvironmentInjector, makeRecord(undefined, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === 'string') {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, {
      self: true
    }));
  }
  retrieve(token, options) {
    const flags = convertToBitFlags(options) || 0;
    try {
      return this.get(token, THROW_IF_NOT_FOUND, flags);
    } catch (e) {
      if ((0,_angular_core_primitives_di__WEBPACK_IMPORTED_MODULE_4__.isNotFound)(e)) {
        return e;
      }
      throw e;
    }
  }
  destroy() {
    assertNotDestroyed(this);
    this._destroyed = true;
    const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(prevConsumer);
    }
  }
  onDestroy(callback) {
    assertNotDestroyed(this);
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    assertNotDestroyed(this);
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      return fn();
    } finally {
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {
    assertNotDestroyed(this);
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    const flags = convertToBitFlags(options);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: token
      });
    }
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    try {
      if (!(flags & 4)) {
        let record = this.records.get(token);
        if (record === undefined) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record, flags);
        }
      }
      const nextInjector = !(flags & 2) ? this.parent : getNullInjector();
      notFoundValue = flags & 8 && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (error) {
      const errorCode = getRuntimeErrorCode(error);
      if (errorCode === -200 || errorCode === -201) {
        if (ngDevMode) {
          prependTokenToDependencyPath(error, token);
          if (previousInjector) {
            throw error;
          } else {
            throw augmentRuntimeError(error, this.source);
          }
        } else {
          throw new RuntimeError(errorCode, null);
        }
      } else {
        throw error;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  resolveInjectorInitializers() {
    const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(null);
    const previousInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(this);
    const previousInjectImplementation = setInjectImplementation(undefined);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, {
        self: true
      });
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' + `(expected an array, but got ${typeof initializers}). ` + 'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' + '`multi: true` provider.');
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(', ')}]`;
  }
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInjectorToCreateInstanceEvent(token);
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === undefined) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(undefined, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== undefined) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record, flags) {
    const prevConsumer = (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(null);
    try {
      if (record.value === CIRCULAR) {
        throw cyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            emitInjectorToCreateInstanceEvent(token);
            record.value = record.factory(undefined, flags);
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory(undefined, flags);
        }
      }
      if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      (0,_angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_3__.setActiveConsumer)(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === 'string') {
      return providedIn === 'any' || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
}
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && 'unreachable');
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(undefined, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = undefined;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(undefined, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 ? 8 : undefined);
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function assertNotDestroyed(injector) {
  if (injector.destroyed) {
    throw new RuntimeError(205, ngDevMode && 'Injector has already been destroyed.');
  }
}
function makeRecord(factory, value, multi = false) {
  return {
    factory: factory,
    value: value,
    multi: multi ? [] : undefined
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === 'object' && typeof value.ngOnDestroy === 'function';
}
function couldBeInjectableType(value) {
  return typeof value === 'function' || typeof value === 'object' && value.ngMetadataName === 'InjectionToken';
}
function forEachSingleProvider(providers, fn) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.ɵproviders, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  let internalInjector;
  if (injector instanceof R3Injector) {
    assertNotDestroyed(injector);
    internalInjector = injector;
  } else {
    internalInjector = new RetrievingInjector(injector);
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
  }
  const prevInjector = (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(internalInjector);
  const previousInjectImplementation = setInjectImplementation(undefined);
  try {
    return fn();
  } finally {
    (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setCurrentInjector)(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== undefined || (0,_not_found_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.getCurrentInjector)() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');
  }
}
const HOST = 0;
const TVIEW = 1;
const FLAGS = 2;
const PARENT = 3;
const NEXT = 4;
const T_HOST = 5;
const HYDRATION = 6;
const CLEANUP = 7;
const CONTEXT = 8;
const INJECTOR = 9;
const ENVIRONMENT = 10;
const RENDERER = 11;
const CHILD_HEAD = 12;
const CHILD_TAIL = 13;
const DECLARATION_VIEW = 14;
const DECLARATION_COMPONENT_VIEW = 15;
const DECLARATION_LCONTAINER = 16;
const PREORDER_HOOK_FLAGS = 17;
const QUERIES = 18;
const ID = 19;
const EMBEDDED_VIEW_INJECTOR = 20;
const ON_DESTROY_HOOKS = 21;
const EFFECTS_TO_SCHEDULE = 22;
const EFFECTS = 23;
const REACTIVE_TEMPLATE_CONSUMER = 24;
const AFTER_RENDER_SEQUENCES_TO_ADD = 25;
const ANIMATIONS = 26;
const HEADER_OFFSET = 27;
const TYPE = 1;
const DEHYDRATED_VIEWS = 6;
const NATIVE = 7;
const VIEW_REFS = 8;
const MOVED_VIEWS = 9;
const CONTAINER_HEADER_OFFSET = 10;
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === 'object';
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isProjectionTNode(tNode) {
  return (tNode.type & 16) === 16;
}
function hasI18n(lView) {
  return (lView[FLAGS] & 32) === 32;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeCreationIndex(lView, index) {
  const adjustedIndex = index + HEADER_OFFSET;
  assertIndexInRange(lView, adjustedIndex);
  assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError('This TNode does not belong to this TView.');
}
function assertTNode(tNode) {
  assertDefined(tNode, 'TNode must be defined');
  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {
    throwError('Not of type TNode, got: ' + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, 'Expected TIcu to be defined');
  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {
    throwError('Object is not of TIcu type.');
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'ɵcmp' property.") {
  if (!getComponentDef(actual)) {
    throwError(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have 'ɵmod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, 'currentTNode should exist!');
  assertDefined(tNode.parent, 'currentTNode should have a parent');
}
function assertLContainer(value) {
  assertDefined(value, 'LContainer must be defined');
  assertEqual(isLContainer(value), true, 'Expecting LContainer');
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
}
function assertLView(value) {
  assertDefined(value, 'LView must be defined');
  assertEqual(isLView(value), true, 'Expecting LView');
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');
}
function assertDirectiveDef(obj) {
  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {
    throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, "Component views should always have a parent view (component's host view)");
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(lView, injectorIndex + 8);
  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');
  assertNumber(lView[injectorIndex + 8], 'injectorIndex should point to parent injector');
}
const SVG_NAMESPACE = 'svg';
const MATH_ML_NAMESPACE = 'math';
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === 'object') return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getNativeByTNodeOrNull(tNode, lView) {
  const index = tNode === null ? -1 : tNode.index;
  if (index !== -1) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    const node = unwrapRNode(lView[index]);
    return node;
  }
  return null;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === undefined) return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(8);
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(0);
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if (isDestroyed(lView)) {
    throw new RuntimeError(911, ngDevMode && 'View has already been destroyed.');
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null) return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function storeCleanupWithContext(tView, lView, context, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');
  lCleanup.push(context);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
const instructionState = {
  lFrame: /*#__PURE__*/createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode = /*#__PURE__*/function (CheckNoChangesMode) {
  CheckNoChangesMode[CheckNoChangesMode["Off"] = 0] = "Off";
  CheckNoChangesMode[CheckNoChangesMode["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode[CheckNoChangesMode["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
  return CheckNoChangesMode;
}(CheckNoChangesMode || {});
let _checkNoChangesMode = 0;
let _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function ɵɵenableBindings() {
  instructionState.bindingsEnabled = true;
}
function enterSkipHydrationBlock(tNode) {
  instructionState.skipHydrationRootTNode = tNode;
}
function ɵɵdisableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function ɵɵrestoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function ɵɵresetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError('Must never be called in production mode');
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError('Must never be called in production mode');
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError('Must never be called in production mode');
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  const prev = _isRefreshingViews;
  _isRefreshingViews = mode;
  return prev;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock) {
  instructionState.lFrame.inI18n = isInI18nBlock;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & 4) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & 1)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null) break;
        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], '????');
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');
    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');
    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');
    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');
    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');
    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');
    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent: parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
const leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function ɵɵnamespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function ɵɵnamespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function ɵɵnamespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace() {
  return instructionState.lFrame.currentNamespace;
}
let _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === 'object' ? undefined : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
class Injector {
  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  static NULL = /*#__PURE__*/new NullInjector();
  static create(options, parent) {
    if (Array.isArray(options)) {
      return createInjector({
        name: ''
      }, parent, options, '');
    } else {
      const name = options.name ?? '';
      return createInjector({
        name
      }, options.parent, options.providers, name);
    }
  }
  static ɵprov = /* @__PURE__ */
  ɵɵdefineInjectable({
    token: Injector,
    providedIn: 'any',
    factory: () => ɵɵinject(INJECTOR$1)
  });
  static __NG_ELEMENT_ID__ = -1;
}
const DOCUMENT = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DocumentToken' : '');
let DestroyRef = /*#__PURE__*/(() => {
  class DestroyRef {
    static __NG_ELEMENT_ID__ = injectDestroyRef;
    static __NG_ENV_ID__ = injector => injector;
  }
  return DestroyRef;
})();
class NodeInjectorDestroyRef extends DestroyRef {
  _lView;
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  get destroyed() {
    return isDestroyed(this._lView);
  }
  onDestroy(callback) {
    const lView = this._lView;
    storeLViewOnDestroy(lView, callback);
    return () => removeLViewOnDestroy(lView, callback);
  }
}
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
const SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
const DEBUG_TASK_TRACKER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'DEBUG_TASK_TRACKER' : '');
let PendingTasksInternal = /*#__PURE__*/(() => {
  class PendingTasksInternal {
    taskId = 0;
    pendingTasks = new Set();
    destroyed = false;
    pendingTask = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject(false);
    debugTaskTracker = inject(DEBUG_TASK_TRACKER, {
      optional: true
    });
    get hasPendingTasks() {
      return this.destroyed ? false : this.pendingTask.value;
    }
    get hasPendingTasksObservable() {
      if (this.destroyed) {
        return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable(subscriber => {
          subscriber.next(false);
          subscriber.complete();
        });
      }
      return this.pendingTask;
    }
    add() {
      if (!this.hasPendingTasks && !this.destroyed) {
        this.pendingTask.next(true);
      }
      const taskId = this.taskId++;
      this.pendingTasks.add(taskId);
      this.debugTaskTracker?.add(taskId);
      return taskId;
    }
    has(taskId) {
      return this.pendingTasks.has(taskId);
    }
    remove(taskId) {
      this.pendingTasks.delete(taskId);
      this.debugTaskTracker?.remove(taskId);
      if (this.pendingTasks.size === 0 && this.hasPendingTasks) {
        this.pendingTask.next(false);
      }
    }
    ngOnDestroy() {
      this.pendingTasks.clear();
      if (this.hasPendingTasks) {
        this.pendingTask.next(false);
      }
      this.destroyed = true;
      this.pendingTask.unsubscribe();
    }
    static ɵprov = /* @__PURE__ */
    ɵɵdefineInjectable({
      token: PendingTasksInternal,
      providedIn: 'root',
      factory: () => new PendingTasksInternal()
    });
  }
  return PendingTasksInternal;
})();
class EventEmitter_ extends rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject {
  __isAsync;
  destroyRef = undefined;
  pendingTasks = undefined;
  constructor(isAsync = false) {
    super();
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, {
        optional: true
      }) ?? undefined;
      this.pendingTasks = inject(PendingTasksInternal, {
        optional: true
      }) ?? undefined;
    }
  }
  emit(value) {
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      super.next(value);
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === 'object') {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({
      next: nextFn,
      error: errorFn,
      complete: completeFn
    });
    if (observerOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return value => {
      const taskId = this.pendingTasks?.add();
      setTimeout(() => {
        try {
          fn(value);
        } finally {
          if (taskId !== undefined) {
            this.pendingTasks?.remove(taskId);
          }
        }
      });
    };
  }
}
const EventEmitter = EventEmitter_;
function noop(...args) {}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop;
    try {
      if (animationFrameId !== undefined && typeof cancelAnimationFrame === 'function') {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== undefined) {
        clearTimeout(timeoutId);
      }
    } catch {}
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === 'function') {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop;
  };
}
class AsyncStackTaggingZoneSpec {
  createTask;
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = 'asyncStackTagging for ' + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  name;
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
}
const isAngularZoneProperty = 'isAngularZone';
const angularZoneInstanceIdProperty = isAngularZoneProperty + '_ID';
let ngZoneInstanceId = 0;
class NgZone {
  hasPendingMacrotasks = false;
  hasPendingMicrotasks = false;
  isStable = true;
  onUnstable = /*#__PURE__*/new EventEmitter(false);
  onMicrotaskEmpty = /*#__PURE__*/new EventEmitter(false);
  onStable = /*#__PURE__*/new EventEmitter(false);
  onError = /*#__PURE__*/new EventEmitter(false);
  constructor(options) {
    const {
      enableLongStackTrace = false,
      shouldCoalesceEventChangeDetection = false,
      shouldCoalesceRunChangeDetection = false,
      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT
    } = options;
    if (typeof Zone == 'undefined') {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec('Angular'));
    }
    if (Zone['TaskTrackingZoneSpec']) {
      self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());
    }
    if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
      self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    self.scheduleInRootZone = scheduleInRootZone;
    forkInnerZoneWithAngularBehavior(self);
  }
  static isInAngularZone() {
    return typeof Zone !== 'undefined' && Zone.current.get(isAngularZoneProperty) === true;
  }
  static assertInAngularZone() {
    if (!NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && 'Expected to be in Angular Zone, but it is not!');
    }
  }
  static assertNotInAngularZone() {
    if (NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && 'Expected to not be in Angular Zone, but it is!');
    }
  }
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
}
const EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: 'angular',
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask' || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == 'microTask') {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == 'macroTask') {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
class NoopNgZone {
  hasPendingMicrotasks = false;
  hasPendingMacrotasks = false;
  isStable = true;
  onUnstable = /*#__PURE__*/new EventEmitter();
  onMicrotaskEmpty = /*#__PURE__*/new EventEmitter();
  onStable = /*#__PURE__*/new EventEmitter();
  onError = /*#__PURE__*/new EventEmitter();
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
}
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, '__ignore_ng_zone__');
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, '__scheduler_tick__');
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
class ErrorHandler {
  _console = console;
  handleError(error) {
    this._console.error('ERROR', error);
  }
}
const INTERNAL_APPLICATION_ERROR_HANDLER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {
  factory: () => {
    const zone = inject(NgZone);
    const injector = inject(EnvironmentInjector);
    let userErrorHandler;
    return e => {
      zone.runOutsideAngular(() => {
        if (injector.destroyed && !userErrorHandler) {
          setTimeout(() => {
            throw e;
          });
        } else {
          userErrorHandler ??= injector.get(ErrorHandler);
          userErrorHandler.handleError(e);
        }
      });
    };
  }
});
const errorHandlerEnvironmentInitializer = {
  provide: ENVIRONMENT_INITIALIZER,
  useValue: () => {
    const handler = inject(ErrorHandler, {
      optional: true
    });
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && handler === null) {
      throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. ` + 'If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.');
    }
  },
  multi: true
};
const globalErrorListeners = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'GlobalErrorListeners' : '', {
  factory: () => {
    if (typeof ngServerMode !== 'undefined' && ngServerMode) {
      return;
    }
    const window = inject(DOCUMENT).defaultView;
    if (!window) {
      return;
    }
    const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    const rejectionListener = e => {
      errorHandler(e.reason);
      e.preventDefault();
    };
    const errorListener = e => {
      if (e.error) {
        errorHandler(e.error);
      } else {
        errorHandler(new Error(ngDevMode ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}` : e.message, {
          cause: e
        }));
      }
      e.preventDefault();
    };
    const setupEventListeners = () => {
      window.addEventListener('unhandledrejection', rejectionListener);
      window.addEventListener('error', errorListener);
    };
    if (typeof Zone !== 'undefined') {
      Zone.root.run(setupEventListeners);
    } else {
      setupEventListeners();
    }
    inject(DestroyRef).onDestroy(() => {
      window.removeEventListener('error', errorListener);
      window.removeEventListener('unhandledrejection', rejectionListener);
    });
  }
});
function provideBrowserGlobalErrorListeners() {
  return makeEnvironmentProviders([provideEnvironmentInitializer(() => void inject(globalErrorListeners))]);
}
function ɵunwrapWritableSignal(value) {
  return null;
}
function signal(initialValue, options) {
  const [get, set, update] = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.createSignal)(initialValue, options?.equal);
  const signalFn = get;
  const node = signalFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  signalFn.set = set;
  signalFn.update = update;
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
    node.debugName = options?.debugName;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  if (node.readonlyFn === undefined) {
    const readonlyFn = () => this();
    readonlyFn[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function assertNotInReactiveContext(debugFn, extraContext) {
  if ((0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.getActiveConsumer)() !== null) {
    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);
  }
}
let ViewContext = /*#__PURE__*/(() => {
  class ViewContext {
    view;
    node;
    constructor(view, node) {
      this.view = view;
      this.node = node;
    }
    static __NG_ELEMENT_ID__ = injectViewContext;
  }
  return ViewContext;
})();
function injectViewContext() {
  return new ViewContext(getLView(), getCurrentTNode());
}
class ChangeDetectionScheduler {}
const ZONELESS_ENABLED = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', {
  factory: () => true
});
const PROVIDED_ZONELESS = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', {
  factory: () => false
});
const SCHEDULE_IN_ROOT_ZONE = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');
let PendingTasks = /*#__PURE__*/(() => {
  class PendingTasks {
    internalPendingTasks = inject(PendingTasksInternal);
    scheduler = inject(ChangeDetectionScheduler);
    errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
    add() {
      const taskId = this.internalPendingTasks.add();
      return () => {
        if (!this.internalPendingTasks.has(taskId)) {
          return;
        }
        this.scheduler.notify(11);
        this.internalPendingTasks.remove(taskId);
      };
    }
    run(fn) {
      const removeTask = this.add();
      fn().catch(this.errorHandler).finally(removeTask);
    }
    static ɵprov = /* @__PURE__ */
    ɵɵdefineInjectable({
      token: PendingTasks,
      providedIn: 'root',
      factory: () => new PendingTasks()
    });
  }
  return PendingTasks;
})();
let EffectScheduler = /*#__PURE__*/(() => {
  class EffectScheduler {
    static ɵprov = /* @__PURE__ */
    ɵɵdefineInjectable({
      token: EffectScheduler,
      providedIn: 'root',
      factory: () => new ZoneAwareEffectScheduler()
    });
  }
  return EffectScheduler;
})();
class ZoneAwareEffectScheduler {
  dirtyEffectCount = 0;
  queues = /*#__PURE__*/new Map();
  add(handle) {
    this.enqueue(handle);
    this.schedule(handle);
  }
  schedule(handle) {
    if (!handle.dirty) {
      return;
    }
    this.dirtyEffectCount++;
  }
  remove(handle) {
    const zone = handle.zone;
    const queue = this.queues.get(zone);
    if (!queue.has(handle)) {
      return;
    }
    queue.delete(handle);
    if (handle.dirty) {
      this.dirtyEffectCount--;
    }
  }
  enqueue(handle) {
    const zone = handle.zone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    queue.add(handle);
  }
  flush() {
    while (this.dirtyEffectCount > 0) {
      let ranOneEffect = false;
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          ranOneEffect ||= this.flushQueue(queue);
        } else {
          ranOneEffect ||= zone.run(() => this.flushQueue(queue));
        }
      }
      if (!ranOneEffect) {
        this.dirtyEffectCount = 0;
      }
    }
  }
  flushQueue(queue) {
    let ranOneEffect = false;
    for (const handle of queue) {
      if (!handle.dirty) {
        continue;
      }
      this.dirtyEffectCount--;
      ranOneEffect = true;
      handle.run();
    }
    return ranOneEffect;
  }
}
class EffectRefImpl {
  [_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL];
  constructor(node) {
    this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
  }
  destroy() {
    this[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL].destroy();
  }
}
function effect(effectFn, options) {
  ngDevMode && assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' + 'effect inside the component constructor.');
  if (ngDevMode && !options?.injector) {
    assertInInjectionContext(effect);
  }
  if (ngDevMode && options?.allowSignalWrites !== undefined) {
    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);
  }
  const injector = options?.injector ?? inject(Injector);
  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  let node;
  const viewContext = injector.get(ViewContext, null, {
    optional: true
  });
  const notifier = injector.get(ChangeDetectionScheduler);
  if (viewContext !== null) {
    node = createViewEffect(viewContext.view, notifier, effectFn);
    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {
      destroyRef = null;
    }
  } else {
    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);
  }
  node.injector = injector;
  if (destroyRef !== null) {
    node.onDestroyFns = [destroyRef.onDestroy(() => node.destroy())];
  }
  const effectRef = new EffectRefImpl(node);
  if (ngDevMode) {
    node.debugName = options?.debugName ?? '';
    const prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
    try {
      emitEffectCreatedEvent(effectRef);
    } finally {
      setInjectorProfilerContext(prevInjectorProfilerContext);
    }
  }
  return effectRef;
}
const EFFECT_NODE = /* @__PURE__ */(() => ({
  ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.BASE_EFFECT_NODE,
  cleanupFns: undefined,
  zone: null,
  onDestroyFns: null,
  run() {
    if (ngDevMode && (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.isInNotificationPhase)()) {
      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);
    }
    const prevRefreshingViews = setIsRefreshingViews(false);
    try {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runEffect)(this);
    } finally {
      setIsRefreshingViews(prevRefreshingViews);
    }
  },
  cleanup() {
    if (!this.cleanupFns?.length) {
      return;
    }
    const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(null);
    try {
      while (this.cleanupFns.length) {
        this.cleanupFns.pop()();
      }
    } finally {
      this.cleanupFns = [];
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.setActiveConsumer)(prevConsumer);
    }
  }
}))();
const ROOT_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...EFFECT_NODE,
  consumerMarkedDirty() {
    this.scheduler.schedule(this);
    this.notifier.notify(12);
  },
  destroy() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerDestroy)(this);
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    this.cleanup();
    this.scheduler.remove(this);
  }
}))();
const VIEW_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...EFFECT_NODE,
  consumerMarkedDirty() {
    this.view[FLAGS] |= 8192;
    markAncestorsForTraversal(this.view);
    this.notifier.notify(13);
  },
  destroy() {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerDestroy)(this);
    if (this.onDestroyFns !== null) {
      for (const fn of this.onDestroyFns) {
        fn();
      }
    }
    this.cleanup();
    this.view[EFFECTS]?.delete(this);
  }
}))();
function createViewEffect(view, notifier, fn) {
  const node = Object.create(VIEW_EFFECT_NODE);
  node.view = view;
  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;
  node.notifier = notifier;
  node.fn = createEffectFn(node, fn);
  view[EFFECTS] ??= new Set();
  view[EFFECTS].add(node);
  node.consumerMarkedDirty(node);
  return node;
}
function createRootEffect(fn, scheduler, notifier) {
  const node = Object.create(ROOT_EFFECT_NODE);
  node.fn = createEffectFn(node, fn);
  node.scheduler = scheduler;
  node.notifier = notifier;
  node.zone = typeof Zone !== 'undefined' ? Zone.current : null;
  node.scheduler.add(node);
  node.notifier.notify(12);
  return node;
}
function createEffectFn(node, fn) {
  return () => {
    fn(cleanupFn => (node.cleanupFns ??= []).push(cleanupFn));
  };
}
function untracked(nonReactiveReadsFn) {
  return (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.untracked)(nonReactiveReadsFn);
}


/***/ },

/***/ 29843
/*!***************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_effect-chunk.mjs ***!
  \***************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_EFFECT_NODE: () => (/* binding */ BASE_EFFECT_NODE),
/* harmony export */   COMPUTING: () => (/* binding */ COMPUTING),
/* harmony export */   ERRORED: () => (/* binding */ ERRORED),
/* harmony export */   REACTIVE_NODE: () => (/* binding */ REACTIVE_NODE),
/* harmony export */   SIGNAL: () => (/* binding */ SIGNAL),
/* harmony export */   SIGNAL_NODE: () => (/* binding */ SIGNAL_NODE),
/* harmony export */   UNSET: () => (/* binding */ UNSET),
/* harmony export */   consumerAfterComputation: () => (/* binding */ consumerAfterComputation),
/* harmony export */   consumerBeforeComputation: () => (/* binding */ consumerBeforeComputation),
/* harmony export */   consumerDestroy: () => (/* binding */ consumerDestroy),
/* harmony export */   consumerMarkDirty: () => (/* binding */ consumerMarkDirty),
/* harmony export */   consumerPollProducersForChange: () => (/* binding */ consumerPollProducersForChange),
/* harmony export */   createComputed: () => (/* binding */ createComputed),
/* harmony export */   createSignal: () => (/* binding */ createSignal),
/* harmony export */   defaultEquals: () => (/* binding */ defaultEquals),
/* harmony export */   finalizeConsumerAfterComputation: () => (/* binding */ finalizeConsumerAfterComputation),
/* harmony export */   getActiveConsumer: () => (/* binding */ getActiveConsumer),
/* harmony export */   isInNotificationPhase: () => (/* binding */ isInNotificationPhase),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   producerAccessed: () => (/* binding */ producerAccessed),
/* harmony export */   producerIncrementEpoch: () => (/* binding */ producerIncrementEpoch),
/* harmony export */   producerMarkClean: () => (/* binding */ producerMarkClean),
/* harmony export */   producerNotifyConsumers: () => (/* binding */ producerNotifyConsumers),
/* harmony export */   producerUpdateValueVersion: () => (/* binding */ producerUpdateValueVersion),
/* harmony export */   producerUpdatesAllowed: () => (/* binding */ producerUpdatesAllowed),
/* harmony export */   resetConsumerBeforeComputation: () => (/* binding */ resetConsumerBeforeComputation),
/* harmony export */   runEffect: () => (/* binding */ runEffect),
/* harmony export */   runPostProducerCreatedFn: () => (/* binding */ runPostProducerCreatedFn),
/* harmony export */   runPostSignalSetFn: () => (/* binding */ runPostSignalSetFn),
/* harmony export */   setActiveConsumer: () => (/* binding */ setActiveConsumer),
/* harmony export */   setPostProducerCreatedFn: () => (/* binding */ setPostProducerCreatedFn),
/* harmony export */   setPostSignalSetFn: () => (/* binding */ setPostSignalSetFn),
/* harmony export */   setThrowInvalidWriteToSignalError: () => (/* binding */ setThrowInvalidWriteToSignalError),
/* harmony export */   signalGetFn: () => (/* binding */ signalGetFn),
/* harmony export */   signalSetFn: () => (/* binding */ signalSetFn),
/* harmony export */   signalUpdateFn: () => (/* binding */ signalUpdateFn),
/* harmony export */   untracked: () => (/* binding */ untracked)
/* harmony export */ });
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

let activeConsumer = null;
let inNotificationPhase = false;
let epoch = 1;
let postProducerCreatedFn = null;
const SIGNAL = /* @__PURE__ */Symbol('SIGNAL');
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
function isReactive(value) {
  return value[SIGNAL] !== undefined;
}
const REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producers: undefined,
  producersTail: undefined,
  consumers: undefined,
  consumersTail: undefined,
  recomputing: false,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  kind: 'unknown',
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {},
  consumerMarkedDirty: () => {},
  consumerOnSignalRead: () => {}
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const prevProducerLink = activeConsumer.producersTail;
  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {
    return;
  }
  let nextProducerLink = undefined;
  const isRecomputing = activeConsumer.recomputing;
  if (isRecomputing) {
    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;
    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {
      activeConsumer.producersTail = nextProducerLink;
      nextProducerLink.lastReadVersion = node.version;
      return;
    }
  }
  const prevConsumerLink = node.consumersTail;
  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {
    return;
  }
  const isLive = consumerIsLive(activeConsumer);
  const newLink = {
    producer: node,
    consumer: activeConsumer,
    nextProducer: nextProducerLink,
    prevConsumer: prevConsumerLink,
    lastReadVersion: node.version,
    nextConsumer: undefined
  };
  activeConsumer.producersTail = newLink;
  if (prevProducerLink !== undefined) {
    prevProducerLink.nextProducer = newLink;
  } else {
    activeConsumer.producers = newLink;
  }
  if (isLive) {
    producerAddLiveConsumer(node, newLink);
  }
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    producerMarkClean(node);
    return;
  }
  node.producerRecomputeValue(node);
  producerMarkClean(node);
}
function producerNotifyConsumers(node) {
  if (node.consumers === undefined) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {
      const consumer = link.consumer;
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function producerMarkClean(node) {
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function consumerBeforeComputation(node) {
  if (node) resetConsumerBeforeComputation(node);
  return setActiveConsumer(node);
}
function resetConsumerBeforeComputation(node) {
  node.producersTail = undefined;
  node.recomputing = true;
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (node) finalizeConsumerAfterComputation(node);
}
function finalizeConsumerAfterComputation(node) {
  node.recomputing = false;
  const producersTail = node.producersTail;
  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;
  if (toRemove !== undefined) {
    if (consumerIsLive(node)) {
      do {
        toRemove = producerRemoveLiveConsumerLink(toRemove);
      } while (toRemove !== undefined);
    }
    if (producersTail !== undefined) {
      producersTail.nextProducer = undefined;
    } else {
      node.producers = undefined;
    }
  }
}
function consumerPollProducersForChange(node) {
  for (let link = node.producers; link !== undefined; link = link.nextProducer) {
    const producer = link.producer;
    const seenVersion = link.lastReadVersion;
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  if (consumerIsLive(node)) {
    let link = node.producers;
    while (link !== undefined) {
      link = producerRemoveLiveConsumerLink(link);
    }
  }
  node.producers = undefined;
  node.producersTail = undefined;
  node.consumers = undefined;
  node.consumersTail = undefined;
}
function producerAddLiveConsumer(node, link) {
  const consumersTail = node.consumersTail;
  const wasLive = consumerIsLive(node);
  if (consumersTail !== undefined) {
    link.nextConsumer = consumersTail.nextConsumer;
    consumersTail.nextConsumer = link;
  } else {
    link.nextConsumer = undefined;
    node.consumers = link;
  }
  link.prevConsumer = consumersTail;
  node.consumersTail = link;
  if (!wasLive) {
    for (let link = node.producers; link !== undefined; link = link.nextProducer) {
      producerAddLiveConsumer(link.producer, link);
    }
  }
}
function producerRemoveLiveConsumerLink(link) {
  const producer = link.producer;
  const nextProducer = link.nextProducer;
  const nextConsumer = link.nextConsumer;
  const prevConsumer = link.prevConsumer;
  link.nextConsumer = undefined;
  link.prevConsumer = undefined;
  if (nextConsumer !== undefined) {
    nextConsumer.prevConsumer = prevConsumer;
  } else {
    producer.consumersTail = prevConsumer;
  }
  if (prevConsumer !== undefined) {
    prevConsumer.nextConsumer = nextConsumer;
  } else {
    producer.consumers = nextConsumer;
    if (!consumerIsLive(producer)) {
      let producerLink = producer.producers;
      while (producerLink !== undefined) {
        producerLink = producerRemoveLiveConsumerLink(producerLink);
      }
    }
  }
  return nextProducer;
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || node.consumers !== undefined;
}
function runPostProducerCreatedFn(node) {
  postProducerCreatedFn?.(node);
}
function setPostProducerCreatedFn(fn) {
  const prev = postProducerCreatedFn;
  postProducerCreatedFn = fn;
  return prev;
}
function isValidLink(checkLink, consumer) {
  const producersTail = consumer.producersTail;
  if (producersTail !== undefined) {
    let link = consumer.producers;
    do {
      if (link === checkLink) {
        return true;
      }
      if (link === producersTail) {
        break;
      }
      link = link.nextProducer;
    } while (link !== undefined);
  }
  return false;
}
function defaultEquals(a, b) {
  return Object.is(a, b);
}
function createComputed(computation, equal) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  if (equal !== undefined) {
    node.equal = equal;
  }
  const computed = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed[SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    computed.toString = () => `[Computed${debugName}: ${String(node.value)}]`;
  }
  runPostProducerCreatedFn(node);
  return computed;
}
const UNSET = /* @__PURE__ */Symbol('UNSET');
const COMPUTING = /* @__PURE__ */Symbol('COMPUTING');
const ERRORED = /* @__PURE__ */Symbol('ERRORED');
const COMPUTED_NODE = /* @__PURE__ */(() => {
  return {
    ...REACTIVE_NODE,
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    kind: 'computed',
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      let wasEqual = false;
      try {
        newValue = node.computation();
        setActiveConsumer(null);
        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (wasEqual) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();
function defaultThrowError() {
  throw new Error();
}
let throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError(node) {
  throwInvalidWriteToSignalErrorFn(node);
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
let postSignalSetFn = null;
function createSignal(initialValue, equal) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  if (equal !== undefined) {
    node.equal = equal;
  }
  const getter = () => signalGetFn(node);
  getter[SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    getter.toString = () => `[Signal${debugName}: ${String(node.value)}]`;
  }
  runPostProducerCreatedFn(node);
  const set = newValue => signalSetFn(node, newValue);
  const update = updateFn => signalUpdateFn(node, updateFn);
  return [getter, set, update];
}
function setPostSignalSetFn(fn) {
  const prev = postSignalSetFn;
  postSignalSetFn = fn;
  return prev;
}
function signalGetFn(node) {
  producerAccessed(node);
  return node.value;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError(node);
  }
  signalSetFn(node, updater(node.value));
}
function runPostSignalSetFn(node) {
  postSignalSetFn?.(node);
}
const SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ...REACTIVE_NODE,
    equal: defaultEquals,
    value: undefined,
    kind: 'signal'
  };
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.(node);
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
const BASE_EFFECT_NODE = /* @__PURE__ */(() => ({
  ...REACTIVE_NODE,
  consumerIsAlwaysLive: true,
  consumerAllowSignalWrites: true,
  dirty: true,
  kind: 'effect'
}))();
function runEffect(node) {
  node.dirty = false;
  if (node.version > 0 && !consumerPollProducersForChange(node)) {
    return;
  }
  node.version++;
  const prevNode = consumerBeforeComputation(node);
  try {
    node.cleanup();
    node.fn();
  } finally {
    consumerAfterComputation(node, prevNode);
  }
}


/***/ },

/***/ 49074
/*!**************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/rxjs-interop.mjs ***!
  \**************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   outputFromObservable: () => (/* binding */ outputFromObservable),
/* harmony export */   outputToObservable: () => (/* binding */ outputToObservable),
/* harmony export */   pendingUntilEvent: () => (/* binding */ pendingUntilEvent),
/* harmony export */   rxResource: () => (/* binding */ rxResource),
/* harmony export */   takeUntilDestroyed: () => (/* binding */ takeUntilDestroyed),
/* harmony export */   toObservable: () => (/* binding */ toObservable),
/* harmony export */   toSignal: () => (/* binding */ toSignal)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 44866);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ 32778);
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 11817);
/* harmony import */ var _resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_resource-chunk.mjs */ 52260);
/* harmony import */ var _angular_core_primitives_signals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core/primitives/signals */ 95094);
/* harmony import */ var _angular_core_primitives_di__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core/primitives/di */ 20144);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */










function takeUntilDestroyed(destroyRef) {
  if (!destroyRef) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertInInjectionContext)(takeUntilDestroyed);
    destroyRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DestroyRef);
  }
  const destroyed$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Observable(subscriber => {
    if (destroyRef.destroyed) {
      subscriber.next();
      return;
    }
    const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));
    return unregisterFn;
  });
  return source => {
    return source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.takeUntil)(destroyed$));
  };
}
class OutputFromObservableRef {
  source;
  destroyed = false;
  destroyRef = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DestroyRef);
  constructor(source) {
    this.source = source;
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
    });
  }
  subscribe(callbackFn) {
    if (this.destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(953, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');
    }
    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({
      next: value => callbackFn(value)
    });
    return {
      unsubscribe: () => subscription.unsubscribe()
    };
  }
}
function outputFromObservable(observable, opts) {
  ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertInInjectionContext)(outputFromObservable);
  return new OutputFromObservableRef(observable);
}
function outputToObservable(ref) {
  const destroyRef = (0,_resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.getOutputDestroyRef)(ref);
  return new rxjs__WEBPACK_IMPORTED_MODULE_0__.Observable(observer => {
    const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());
    const subscription = ref.subscribe(v => observer.next(v));
    return () => {
      subscription.unsubscribe();
      unregisterOnDestroy?.();
    };
  });
}
function toObservable(source, options) {
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertInInjectionContext)(toObservable);
  }
  const injector = options?.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injector);
  const subject = new rxjs__WEBPACK_IMPORTED_MODULE_0__.ReplaySubject(1);
  const watcher = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.effect)(() => {
    let value;
    try {
      value = source();
    } catch (err) {
      (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.untracked)(() => subject.error(err));
      return;
    }
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.untracked)(() => subject.next(value));
  }, {
    injector,
    manualCleanup: true
  });
  injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DestroyRef).onDestroy(() => {
    watcher.destroy();
    subject.complete();
  });
  return subject.asObservable();
}
function toSignal(source, options) {
  typeof ngDevMode !== 'undefined' && ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertNotInReactiveContext)(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');
  const requiresCleanup = !options?.manualCleanup;
  if (ngDevMode && requiresCleanup && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertInInjectionContext)(toSignal);
  }
  const cleanupRef = requiresCleanup ? options?.injector?.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DestroyRef) ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.DestroyRef) : null;
  const equal = makeToSignalEqual(options?.equal);
  let state;
  if (options?.requireSync) {
    state = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.signal)({
      kind: 0
    }, {
      equal,
      ...(ngDevMode ? createDebugNameObject(options?.debugName, 'state') : undefined)
    });
  } else {
    state = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.signal)({
      kind: 1,
      value: options?.initialValue
    }, {
      equal,
      ...(ngDevMode ? createDebugNameObject(options?.debugName, 'state') : undefined)
    });
  }
  let destroyUnregisterFn;
  const sub = source.subscribe({
    next: value => state.set({
      kind: 1,
      value
    }),
    error: error => {
      state.set({
        kind: 2,
        error
      });
      destroyUnregisterFn?.();
    },
    complete: () => {
      destroyUnregisterFn?.();
    }
  });
  if (options?.requireSync && state().kind === 0) {
    throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(601, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
  }
  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
  return (0,_resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.computed)(() => {
    const current = state();
    switch (current.kind) {
      case 1:
        return current.value;
      case 2:
        throw current.error;
      case 0:
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(601, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
    }
  }, {
    equal: options?.equal,
    ...(ngDevMode ? createDebugNameObject(options?.debugName, 'source') : undefined)
  });
}
function makeToSignalEqual(userEquality = Object.is) {
  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);
}
function createDebugNameObject(toSignalDebugName, internalSignalDebugName) {
  return {
    debugName: `toSignal${toSignalDebugName ? '#' + toSignalDebugName : ''}.${internalSignalDebugName}`
  };
}
function pendingUntilEvent(injector) {
  if (injector === undefined) {
    ngDevMode && (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertInInjectionContext)(pendingUntilEvent);
    injector = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.Injector);
  }
  const taskService = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.PendingTasks);
  return sourceObservable => {
    return new rxjs__WEBPACK_IMPORTED_MODULE_0__.Observable(originalSubscriber => {
      const removeTask = taskService.add();
      let cleanedUp = false;
      function cleanupTask() {
        if (cleanedUp) {
          return;
        }
        removeTask();
        cleanedUp = true;
      }
      const innerSubscription = sourceObservable.subscribe({
        next: v => {
          originalSubscriber.next(v);
          cleanupTask();
        },
        complete: () => {
          originalSubscriber.complete();
          cleanupTask();
        },
        error: e => {
          originalSubscriber.error(e);
          cleanupTask();
        }
      });
      innerSubscription.add(() => {
        originalSubscriber.unsubscribe();
        cleanupTask();
      });
      return innerSubscription;
    });
  };
}
function rxResource(opts) {
  if (ngDevMode && !opts?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.assertInInjectionContext)(rxResource);
  }
  return (0,_resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.resource)({
    ...opts,
    loader: undefined,
    stream: params => {
      let sub;
      const onAbort = () => sub?.unsubscribe();
      params.abortSignal.addEventListener('abort', onAbort);
      const stream = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.signal)({
        value: undefined
      });
      let resolve;
      const promise = new Promise(r => resolve = r);
      function send(value) {
        stream.set(value);
        resolve?.(stream);
        resolve = undefined;
      }
      const streamFn = opts.stream ?? opts.loader;
      if (streamFn === undefined) {
        throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(990, ngDevMode && `Must provide \`stream\` option.`);
      }
      sub = streamFn(params).subscribe({
        next: value => send({
          value
        }),
        error: error => {
          send({
            error: (0,_resource_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.encapsulateResourceError)(error)
          });
          params.abortSignal.removeEventListener('abort', onAbort);
        },
        complete: () => {
          if (resolve) {
            send({
              error: new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.RuntimeError(991, ngDevMode && 'Resource completed before producing a value')
            });
          }
          params.abortSignal.removeEventListener('abort', onAbort);
        }
      });
      return promise;
    }
  });
}


/***/ },

/***/ 52260
/*!*****************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_resource-chunk.mjs ***!
  \*****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutputEmitterRef: () => (/* binding */ OutputEmitterRef),
/* harmony export */   ResourceImpl: () => (/* binding */ ResourceImpl),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   encapsulateResourceError: () => (/* binding */ encapsulateResourceError),
/* harmony export */   getOutputDestroyRef: () => (/* binding */ getOutputDestroyRef),
/* harmony export */   linkedSignal: () => (/* binding */ linkedSignal),
/* harmony export */   resource: () => (/* binding */ resource)
/* harmony export */ });
/* harmony import */ var _Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 89204);
/* harmony import */ var _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_untracked-chunk.mjs */ 11817);
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/* harmony import */ var _linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_linked_signal-chunk.mjs */ 68262);

/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */




class OutputEmitterRef {
  destroyed = false;
  listeners = null;
  errorHandler = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler, {
    optional: true
  });
  destroyRef = /*#__PURE__*/(0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef);
  constructor() {
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.RuntimeError(953, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== undefined && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  emit(value) {
    if (this.destroyed) {
      console.warn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRuntimeError)(953, ngDevMode && 'Unexpected emit for destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.'));
      return;
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.setActiveConsumer)(previousConsumer);
    }
  }
}
function getOutputDestroyRef(ref) {
  return ref.destroyRef;
}
function computed(computation, options) {
  const getter = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.createComputed)(computation, options?.equal);
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
    getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL].debugName = options?.debugName;
  }
  return getter;
}
const identityFn = v => v;
function linkedSignal(optionsOrComputation, options) {
  if (typeof optionsOrComputation === 'function') {
    const getter = (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.createLinkedSignal)(optionsOrComputation, identityFn, options?.equal);
    return upgradeLinkedSignalGetter(getter, options?.debugName);
  } else {
    const getter = (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.createLinkedSignal)(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);
    return upgradeLinkedSignalGetter(getter, optionsOrComputation.debugName);
  }
}
function upgradeLinkedSignalGetter(getter, debugName) {
  if (ngDevMode) {
    getter.toString = () => `[LinkedSignal: ${getter()}]`;
    getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL].debugName = debugName;
  }
  const node = getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_2__.SIGNAL];
  const upgradedGetter = getter;
  upgradedGetter.set = newValue => (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignalSetFn)(node, newValue);
  upgradedGetter.update = updateFn => (0,_linked_signal_chunk_mjs__WEBPACK_IMPORTED_MODULE_3__.linkedSignalUpdateFn)(node, updateFn);
  upgradedGetter.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalAsReadonlyFn.bind(getter);
  return upgradedGetter;
}
function resource(options) {
  if (ngDevMode && !options?.injector) {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.assertInInjectionContext)(resource);
  }
  const oldNameForParams = options.request;
  const params = options.params ?? oldNameForParams ?? (() => null);
  return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.debugName, options.injector ?? (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.inject)(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.Injector));
}
class BaseWritableResource {
  value;
  isLoading;
  constructor(value, debugName) {
    this.value = value;
    this.value.set = this.set.bind(this);
    this.value.update = this.update.bind(this);
    this.value.asReadonly = _untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signalAsReadonlyFn;
    this.isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading', ngDevMode ? createDebugNameObject(debugName, 'isLoading') : undefined);
  }
  isError = /*#__PURE__*/computed(() => this.status() === 'error');
  update(updateFn) {
    this.set(updateFn((0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.value)));
  }
  isValueDefined = /*#__PURE__*/computed(() => {
    if (this.isError()) {
      return false;
    }
    return this.value() !== undefined;
  });
  hasValue() {
    return this.isValueDefined();
  }
  asReadonly() {
    return this;
  }
}
class ResourceImpl extends BaseWritableResource {
  loaderFn;
  equal;
  debugName;
  pendingTasks;
  state;
  extRequest;
  effectRef;
  pendingController;
  resolvePendingTask = undefined;
  destroyed = false;
  unregisterOnDestroy;
  status;
  error;
  constructor(request, loaderFn, defaultValue, equal, debugName, injector) {
    super(computed(() => {
      const streamValue = this.state().stream?.();
      if (!streamValue) {
        return defaultValue;
      }
      if (this.state().status === 'loading' && this.error()) {
        return defaultValue;
      }
      if (!isResolved(streamValue)) {
        throw new ResourceValueError(this.error());
      }
      return streamValue.value;
    }, {
      equal,
      ...(ngDevMode ? createDebugNameObject(debugName, 'value') : undefined)
    }), debugName);
    this.loaderFn = loaderFn;
    this.equal = equal;
    this.debugName = debugName;
    this.extRequest = linkedSignal({
      source: request,
      computation: request => ({
        request,
        reload: 0
      }),
      ...(ngDevMode ? createDebugNameObject(debugName, 'extRequest') : undefined)
    });
    this.state = linkedSignal({
      source: this.extRequest,
      computation: (extRequest, previous) => {
        const status = extRequest.request === undefined ? 'idle' : 'loading';
        if (!previous) {
          return {
            extRequest,
            status,
            previousStatus: 'idle',
            stream: undefined
          };
        } else {
          return {
            extRequest,
            status,
            previousStatus: projectStatusOfState(previous.value),
            stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : undefined
          };
        }
      },
      ...(ngDevMode ? createDebugNameObject(debugName, 'state') : undefined)
    });
    this.effectRef = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.effect)(this.loadEffect.bind(this), {
      injector,
      manualCleanup: true,
      ...(ngDevMode ? createDebugNameObject(debugName, 'loadEffect') : undefined)
    });
    this.pendingTasks = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.PendingTasks);
    this.unregisterOnDestroy = injector.get(_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.DestroyRef).onDestroy(() => this.destroy());
    this.status = computed(() => projectStatusOfState(this.state()), ngDevMode ? createDebugNameObject(debugName, 'status') : undefined);
    this.error = computed(() => {
      const stream = this.state().stream?.();
      return stream && !isResolved(stream) ? stream.error : undefined;
    }, ngDevMode ? createDebugNameObject(debugName, 'error') : undefined);
  }
  set(value) {
    if (this.destroyed) {
      return;
    }
    const error = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.error);
    const state = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.state);
    if (!error) {
      const current = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.value);
      if (state.status === 'local' && (this.equal ? this.equal(current, value) : current === value)) {
        return;
      }
    }
    this.state.set({
      extRequest: state.extRequest,
      status: 'local',
      previousStatus: 'local',
      stream: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
        value
      }, ngDevMode ? createDebugNameObject(this.debugName, 'stream') : undefined)
    });
    this.abortInProgressLoad();
  }
  reload() {
    const {
      status
    } = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(this.state);
    if (status === 'idle' || status === 'loading') {
      return false;
    }
    this.extRequest.update(({
      request,
      reload
    }) => ({
      request,
      reload: reload + 1
    }));
    return true;
  }
  destroy() {
    this.destroyed = true;
    this.unregisterOnDestroy();
    this.effectRef.destroy();
    this.abortInProgressLoad();
    this.state.set({
      extRequest: {
        request: undefined,
        reload: 0
      },
      status: 'idle',
      previousStatus: 'idle',
      stream: undefined
    });
  }
  loadEffect() {
    var _this = this;
    return (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const extRequest = _this.extRequest();
      const {
        status: currentStatus,
        previousStatus
      } = (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.state);
      if (extRequest.request === undefined) {
        return;
      } else if (currentStatus !== 'loading') {
        return;
      }
      _this.abortInProgressLoad();
      let resolvePendingTask = _this.resolvePendingTask = _this.pendingTasks.add();
      const {
        signal: abortSignal
      } = _this.pendingController = new AbortController();
      try {
        const stream = yield (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => {
          return _this.loaderFn({
            params: extRequest.request,
            request: extRequest.request,
            abortSignal,
            previous: {
              status: previousStatus
            }
          });
        });
        if (abortSignal.aborted || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.extRequest) !== extRequest) {
          return;
        }
        _this.state.set({
          extRequest,
          status: 'resolved',
          previousStatus: 'resolved',
          stream
        });
      } catch (err) {
        if (abortSignal.aborted || (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(_this.extRequest) !== extRequest) {
          return;
        }
        _this.state.set({
          extRequest,
          status: 'resolved',
          previousStatus: 'error',
          stream: (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
            error: encapsulateResourceError(err)
          }, ngDevMode ? createDebugNameObject(_this.debugName, 'stream') : undefined)
        });
      } finally {
        resolvePendingTask?.();
        resolvePendingTask = undefined;
      }
    })();
  }
  abortInProgressLoad() {
    (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.untracked)(() => this.pendingController?.abort());
    this.pendingController = undefined;
    this.resolvePendingTask?.();
    this.resolvePendingTask = undefined;
  }
}
function wrapEqualityFn(equal) {
  return (a, b) => a === undefined || b === undefined ? a === b : equal(a, b);
}
function getLoader(options) {
  if (isStreamingResourceOptions(options)) {
    return options.stream;
  }
  return /*#__PURE__*/function () {
    var _ref = (0,_Users_ba5ik7_Documents_GIT_tmdjr_ngx_editor_js2_blocks_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (params) {
      try {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
          value: yield options.loader(params)
        }, ngDevMode ? createDebugNameObject(options.debugName, 'stream') : undefined);
      } catch (err) {
        return (0,_untracked_chunk_mjs__WEBPACK_IMPORTED_MODULE_1__.signal)({
          error: encapsulateResourceError(err)
        }, ngDevMode ? createDebugNameObject(options.debugName, 'stream') : undefined);
      }
    });
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}
function isStreamingResourceOptions(options) {
  return !!options.stream;
}
function projectStatusOfState(state) {
  switch (state.status) {
    case 'loading':
      return state.extRequest.reload === 0 ? 'loading' : 'reloading';
    case 'resolved':
      return isResolved(state.stream()) ? 'resolved' : 'error';
    default:
      return state.status;
  }
}
function isResolved(state) {
  return state.error === undefined;
}
function createDebugNameObject(resourceDebugName, internalSignalDebugName) {
  return {
    debugName: `Resource${resourceDebugName ? '#' + resourceDebugName : ''}.${internalSignalDebugName}`
  };
}
function encapsulateResourceError(error) {
  if (isErrorLike(error)) {
    return error;
  }
  return new ResourceWrappedError(error);
}
function isErrorLike(error) {
  return error instanceof Error || typeof error === 'object' && typeof error.name === 'string' && typeof error.message === 'string';
}
class ResourceValueError extends Error {
  constructor(error) {
    super(ngDevMode ? `Resource is currently in an error state (see Error.cause for details): ${error.message}` : error.message, {
      cause: error
    });
  }
}
class ResourceWrappedError extends Error {
  constructor(error) {
    super(ngDevMode ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.` : String(error), {
      cause: error
    });
  }
}


/***/ },

/***/ 68262
/*!**********************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_linked_signal-chunk.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLinkedSignal: () => (/* binding */ createLinkedSignal),
/* harmony export */   linkedSignalSetFn: () => (/* binding */ linkedSignalSetFn),
/* harmony export */   linkedSignalUpdateFn: () => (/* binding */ linkedSignalUpdateFn)
/* harmony export */ });
/* harmony import */ var _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_effect-chunk.mjs */ 29843);
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */


function createLinkedSignal(sourceFn, computationFn, equalityFn) {
  const node = Object.create(LINKED_SIGNAL_NODE);
  node.source = sourceFn;
  node.computation = computationFn;
  if (equalityFn != undefined) {
    node.equal = equalityFn;
  }
  const linkedSignalGetter = () => {
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
    (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerAccessed)(node);
    if (node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  const getter = linkedSignalGetter;
  getter[_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.SIGNAL] = node;
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';
    getter.toString = () => `[LinkedSignal${debugName}: ${String(node.value)}]`;
  }
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.runPostProducerCreatedFn)(node);
  return getter;
}
function linkedSignalSetFn(node, newValue) {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalSetFn)(node, newValue);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerMarkClean)(node);
}
function linkedSignalUpdateFn(node, updater) {
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerUpdateValueVersion)(node);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.signalUpdateFn)(node, updater);
  (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.producerMarkClean)(node);
}
const LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {
  return {
    ..._effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.REACTIVE_NODE,
    value: _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET,
    dirty: true,
    error: null,
    equal: _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultEquals,
    kind: 'linkedSignal',
    producerMustRecompute(node) {
      return node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET || node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING) {
        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');
      }
      const oldValue = node.value;
      node.value = _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.COMPUTING;
      const prevConsumer = (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerBeforeComputation)(node);
      let newValue;
      try {
        const newSourceValue = node.source();
        const prev = oldValue === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET || oldValue === _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED ? undefined : {
          source: node.sourceValue,
          value: oldValue
        };
        newValue = node.computation(newSourceValue, prev);
        node.sourceValue = newSourceValue;
      } catch (err) {
        newValue = _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED;
        node.error = err;
      } finally {
        (0,_effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.consumerAfterComputation)(node, prevConsumer);
      }
      if (oldValue !== _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.UNSET && newValue !== _effect_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();


/***/ },

/***/ 78330
/*!******************************************************************!*\
  !*** ./node_modules/@angular/core/fesm2022/_not_found-chunk.mjs ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOT_FOUND: () => (/* binding */ NOT_FOUND),
/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),
/* harmony export */   getCurrentInjector: () => (/* binding */ getCurrentInjector),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isNotFound: () => (/* binding */ isNotFound),
/* harmony export */   setCurrentInjector: () => (/* binding */ setCurrentInjector)
/* harmony export */ });
/**
 * @license Angular v21.1.0
 * (c) 2010-2026 Google LLC. https://angular.dev/
 * License: MIT
 */

let _currentInjector = undefined;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function inject(token, options) {
  const currentInjector = getCurrentInjector();
  if (!currentInjector) {
    throw new Error('Current injector is not set.');
  }
  if (!token.ɵprov) {
    throw new Error('Token is not an injectable');
  }
  return currentInjector.retrieve(token, options);
}
const NOT_FOUND = /*#__PURE__*/Symbol('NotFound');
class NotFoundError extends Error {
  name = 'ɵNotFound';
  constructor(message) {
    super(message);
  }
}
function isNotFound(e) {
  return e === NOT_FOUND || e?.name === 'ɵNotFound';
}


/***/ },

/***/ 89204
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }

}])
//# sourceMappingURL=9074.js.map