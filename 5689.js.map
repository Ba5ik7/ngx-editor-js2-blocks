{"version":3,"file":"5689.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEwS;AAExS,SAASe,kBAAkBA,CAACC,QAAQ,EAAEC,aAAa,EAAEC,UAAU,EAAE;EAC7D,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAACC,kBAAkB,CAAC;EAC9CH,IAAI,CAACI,MAAM,GAAGP,QAAQ;EACtBG,IAAI,CAACK,WAAW,GAAGP,aAAa;EAChC,IAAIC,UAAU,IAAIO,SAAS,EAAE;IACzBN,IAAI,CAACO,KAAK,GAAGR,UAAU;EAC3B;EACA,MAAMS,kBAAkB,GAAGA,CAAA,KAAM;IAC7B;IACAzB,gFAA0B,CAACiB,IAAI,CAAC;IAChC;IACAN,sEAAgB,CAACM,IAAI,CAAC;IACtB,IAAIA,IAAI,CAACS,KAAK,KAAKjB,yDAAO,EAAE;MACxB,MAAMQ,IAAI,CAACU,KAAK;IACpB;IACA,OAAOV,IAAI,CAACS,KAAK;EACrB,CAAC;EACD,MAAME,MAAM,GAAGH,kBAAkB;EACjCG,MAAM,CAAC9B,wDAAM,CAAC,GAAGmB,IAAI;EACrB,IAAI,OAAOY,SAAS,KAAK,WAAW,IAAIA,SAAS,EAAE;IAC/C,MAAMC,SAAS,GAAGb,IAAI,CAACa,SAAS,GAAG,IAAI,GAAGb,IAAI,CAACa,SAAS,GAAG,GAAG,GAAG,EAAE;IACnEF,MAAM,CAACG,QAAQ,GAAG,MAAM,gBAAgBD,SAAS,KAAKb,IAAI,CAACS,KAAK,GAAG;EACvE;EACA3B,8EAAwB,CAACkB,IAAI,CAAC;EAC9B,OAAOW,MAAM;AACjB;AACA,SAASI,iBAAiBA,CAACf,IAAI,EAAEgB,QAAQ,EAAE;EACvCjC,gFAA0B,CAACiB,IAAI,CAAC;EAChChB,iEAAW,CAACgB,IAAI,EAAEgB,QAAQ,CAAC;EAC3B/B,uEAAiB,CAACe,IAAI,CAAC;AAC3B;AACA,SAASiB,oBAAoBA,CAACjB,IAAI,EAAEkB,OAAO,EAAE;EACzCnC,gFAA0B,CAACiB,IAAI,CAAC;EAChCd,oEAAc,CAACc,IAAI,EAAEkB,OAAO,CAAC;EAC7BjC,uEAAiB,CAACe,IAAI,CAAC;AAC3B;AACA;AACA;AACA;AACA,MAAMG,kBAAkB,GAAG,eAAgB,CAAC,MAAM;EAC9C,OAAO;IACH,GAAGhB,+DAAa;IAChBsB,KAAK,EAAErB,uDAAK;IACZ+B,KAAK,EAAE,IAAI;IACXT,KAAK,EAAE,IAAI;IACXH,KAAK,EAAElB,+DAAa;IACpB+B,IAAI,EAAE,cAAc;IACpBC,qBAAqBA,CAACrB,IAAI,EAAE;MACxB;MACA;MACA,OAAOA,IAAI,CAACS,KAAK,KAAKrB,uDAAK,IAAIY,IAAI,CAACS,KAAK,KAAKnB,2DAAS;IAC3D,CAAC;IACDgC,sBAAsBA,CAACtB,IAAI,EAAE;MACzB,IAAIA,IAAI,CAACS,KAAK,KAAKnB,2DAAS,EAAE;QAC1B;QACA,MAAM,IAAIiC,KAAK,CAAC,OAAOX,SAAS,KAAK,WAAW,IAAIA,SAAS,GAAG,iCAAiC,GAAG,EAAE,CAAC;MAC3G;MACA,MAAMY,QAAQ,GAAGxB,IAAI,CAACS,KAAK;MAC3BT,IAAI,CAACS,KAAK,GAAGnB,2DAAS;MACtB,MAAMmC,YAAY,GAAGlC,+EAAyB,CAACS,IAAI,CAAC;MACpD,IAAIgB,QAAQ;MACZ,IAAI;QACA,MAAMU,cAAc,GAAG1B,IAAI,CAACI,MAAM,CAAC,CAAC;QACpC,MAAMuB,IAAI,GAAGH,QAAQ,KAAKpC,uDAAK,IAAIoC,QAAQ,KAAKhC,yDAAO,GACjDc,SAAS,GACT;UACEF,MAAM,EAAEJ,IAAI,CAAC4B,WAAW;UACxBnB,KAAK,EAAEe;QACX,CAAC;QACLR,QAAQ,GAAGhB,IAAI,CAACK,WAAW,CAACqB,cAAc,EAAEC,IAAI,CAAC;QACjD3B,IAAI,CAAC4B,WAAW,GAAGF,cAAc;MACrC,CAAC,CACD,OAAOG,GAAG,EAAE;QACRb,QAAQ,GAAGxB,yDAAO;QAClBQ,IAAI,CAACU,KAAK,GAAGmB,GAAG;MACpB,CAAC,SACO;QACJpC,8EAAwB,CAACO,IAAI,EAAEyB,YAAY,CAAC;MAChD;MACA,IAAID,QAAQ,KAAKpC,uDAAK,IAAI4B,QAAQ,KAAKxB,yDAAO,IAAIQ,IAAI,CAACO,KAAK,CAACiB,QAAQ,EAAER,QAAQ,CAAC,EAAE;QAC9E;QACA;QACAhB,IAAI,CAACS,KAAK,GAAGe,QAAQ;QACrB;MACJ;MACAxB,IAAI,CAACS,KAAK,GAAGO,QAAQ;MACrBhB,IAAI,CAAC8B,OAAO,EAAE;IAClB;EACJ,CAAC;AACL,CAAC,EAAE,CAAC;;AAEJ;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,kBAAkB,EAAE;EACnC,MAAMP,YAAY,GAAG9B,uEAAiB,CAAC,IAAI,CAAC;EAC5C;EACA;EACA,IAAI;IACA,OAAOqC,kBAAkB,CAAC,CAAC;EAC/B,CAAC,SACO;IACJrC,uEAAiB,CAAC8B,YAAY,CAAC;EACnC;AACJ;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;;AAEA,SAASQ,uBAAuBA,CAACC,IAAI,EAAE;EACnC;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPJ;AACA;AACA;AACA;AACA;;AAE+M;AACwP;AACpV;AAChD;AAEnE,SAASkB,WAAWA,CAACC,EAAE,EAAEC,QAAQ,EAAEC,iBAAiB,EAAE;EAClD,MAAMvD,IAAI,GAAGC,MAAM,CAACC,MAAM,CAACsD,UAAU,CAAC;EACtC,IAAID,iBAAiB,EAAE;IACnBvD,IAAI,CAACyD,yBAAyB,GAAG,IAAI;EACzC;EACAzD,IAAI,CAACqD,EAAE,GAAGA,EAAE;EACZrD,IAAI,CAACsD,QAAQ,GAAGA,QAAQ;EACxB,MAAMI,iBAAiB,GAAIC,SAAS,IAAK;IACrC3D,IAAI,CAAC2D,SAAS,GAAGA,SAAS;EAC9B,CAAC;EACD,SAASC,oBAAoBA,CAAC5D,IAAI,EAAE;IAChC,OAAOA,IAAI,CAACqD,EAAE,KAAK,IAAI,IAAIrD,IAAI,CAACsD,QAAQ,KAAK,IAAI;EACrD;EACA,SAASO,gBAAgBA,CAAC7D,IAAI,EAAE;IAC5B,IAAI,CAAC4D,oBAAoB,CAAC5D,IAAI,CAAC,EAAE;MAC7BoC,qEAAe,CAACpC,IAAI,CAAC,CAAC,CAAC;MACvBA,IAAI,CAAC2D,SAAS,CAAC,CAAC;MAChB;MACA3D,IAAI,CAACqD,EAAE,GAAG,IAAI;MACdrD,IAAI,CAACsD,QAAQ,GAAG,IAAI;MACpBtD,IAAI,CAAC2D,SAAS,GAAGG,eAAe;IACpC;EACJ;EACA,MAAMC,GAAG,GAAGA,CAAA,KAAM;IACd,IAAI/D,IAAI,CAACqD,EAAE,KAAK,IAAI,EAAE;MAClB;MACA;IACJ;IACA,IAAIhB,2EAAqB,CAAC,CAAC,EAAE;MACzB,MAAM,IAAId,KAAK,CAAC,OAAOX,SAAS,KAAK,WAAW,IAAIA,SAAS,GACvD,mEAAmE,GACnE,EAAE,CAAC;IACb;IACAZ,IAAI,CAACmB,KAAK,GAAG,KAAK;IAClB,IAAInB,IAAI,CAACgE,MAAM,IAAI,CAAC1B,oFAA8B,CAACtC,IAAI,CAAC,EAAE;MACtD;IACJ;IACAA,IAAI,CAACgE,MAAM,GAAG,IAAI;IAClB,MAAMvC,YAAY,GAAGlC,+EAAyB,CAACS,IAAI,CAAC;IACpD,IAAI;MACAA,IAAI,CAAC2D,SAAS,CAAC,CAAC;MAChB3D,IAAI,CAAC2D,SAAS,GAAGG,eAAe;MAChC9D,IAAI,CAACqD,EAAE,CAACK,iBAAiB,CAAC;IAC9B,CAAC,SACO;MACJjE,8EAAwB,CAACO,IAAI,EAAEyB,YAAY,CAAC;IAChD;EACJ,CAAC;EACDzB,IAAI,CAACiE,GAAG,GAAG;IACPC,MAAM,EAAEA,CAAA,KAAM/B,uEAAiB,CAACnC,IAAI,CAAC;IACrC+D,GAAG;IACHI,OAAO,EAAEA,CAAA,KAAMnE,IAAI,CAAC2D,SAAS,CAAC,CAAC;IAC/BS,OAAO,EAAEA,CAAA,KAAMP,gBAAgB,CAAC7D,IAAI,CAAC;IACrC,CAACnB,wDAAM,GAAGmB;EACd,CAAC;EACD,OAAOA,IAAI,CAACiE,GAAG;AACnB;AACA,MAAMH,eAAe,GAAGA,CAAA,KAAM,CAAE,CAAC;AACjC;AACA;AACA;AACA,MAAMN,UAAU,GAAG,eAAgB,CAAC,MAAM;EACtC,OAAO;IACH,GAAGrE,+DAAa;IAChBkF,oBAAoB,EAAE,IAAI;IAC1BZ,yBAAyB,EAAE,KAAK;IAChCa,mBAAmB,EAAGtE,IAAI,IAAK;MAC3B,IAAIA,IAAI,CAACsD,QAAQ,KAAK,IAAI,EAAE;QACxBtD,IAAI,CAACsD,QAAQ,CAACtD,IAAI,CAACiE,GAAG,CAAC;MAC3B;IACJ,CAAC;IACDD,MAAM,EAAE,KAAK;IACbL,SAAS,EAAEG;EACf,CAAC;AACL,CAAC,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrFJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAASzE,aAAaA,CAACkF,CAAC,EAAEC,CAAC,EAAE;EACzB,OAAOvE,MAAM,CAACwE,EAAE,CAACF,CAAC,EAAEC,CAAC,CAAC;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAIE,cAAc,GAAG,IAAI;AACzB,IAAIC,mBAAmB,GAAG,KAAK;AAC/B;AACA;AACA;AACA,IAAIC,KAAK,GAAG,CAAC;AACb;AACA;AACA;AACA,IAAIC,qBAAqB,GAAG,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA,MAAMhG,MAAM,GAAG,eAAgBiG,MAAM,CAAC,QAAQ,CAAC;AAC/C,SAASnF,iBAAiBA,CAACoF,QAAQ,EAAE;EACjC,MAAMpD,IAAI,GAAG+C,cAAc;EAC3BA,cAAc,GAAGK,QAAQ;EACzB,OAAOpD,IAAI;AACf;AACA,SAASe,iBAAiBA,CAAA,EAAG;EACzB,OAAOgC,cAAc;AACzB;AACA,SAASrC,qBAAqBA,CAAA,EAAG;EAC7B,OAAOsC,mBAAmB;AAC9B;AACA,SAAShC,UAAUA,CAAClC,KAAK,EAAE;EACvB,OAAOA,KAAK,CAAC5B,MAAM,CAAC,KAAKyB,SAAS;AACtC;AACA,MAAMnB,aAAa,GAAG;EAClB2C,OAAO,EAAE,CAAC;EACVkD,cAAc,EAAE,CAAC;EACjB7D,KAAK,EAAE,KAAK;EACZ8D,YAAY,EAAE3E,SAAS;EACvB4E,uBAAuB,EAAE5E,SAAS;EAClC6E,mBAAmB,EAAE7E,SAAS;EAC9B8E,iBAAiB,EAAE,CAAC;EACpBC,gBAAgB,EAAE/E,SAAS;EAC3BgF,uBAAuB,EAAEhF,SAAS;EAClCmD,yBAAyB,EAAE,KAAK;EAChCY,oBAAoB,EAAE,KAAK;EAC3BjD,IAAI,EAAE,SAAS;EACfC,qBAAqB,EAAEA,CAAA,KAAM,KAAK;EAClCC,sBAAsB,EAAEA,CAAA,KAAM,CAAE,CAAC;EACjCgD,mBAAmB,EAAEA,CAAA,KAAM,CAAE,CAAC;EAC9BiB,oBAAoB,EAAEA,CAAA,KAAM,CAAE;AAClC,CAAC;AACD;AACA;AACA;AACA,SAAS7F,gBAAgBA,CAACM,IAAI,EAAE;EAC5B,IAAI2E,mBAAmB,EAAE;IACrB,MAAM,IAAIpD,KAAK,CAAC,OAAOX,SAAS,KAAK,WAAW,IAAIA,SAAS,GACvD,wDAAwD,GACxD,EAAE,CAAC;EACb;EACA,IAAI8D,cAAc,KAAK,IAAI,EAAE;IACzB;IACA;EACJ;EACAA,cAAc,CAACa,oBAAoB,CAACvF,IAAI,CAAC;EACzC;EACA,MAAMwF,GAAG,GAAGd,cAAc,CAACU,iBAAiB,EAAE;EAC9CK,kBAAkB,CAACf,cAAc,CAAC;EAClC,IAAIc,GAAG,GAAGd,cAAc,CAACO,YAAY,CAACS,MAAM,IAAIhB,cAAc,CAACO,YAAY,CAACO,GAAG,CAAC,KAAKxF,IAAI,EAAE;IACvF;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI2F,cAAc,CAACjB,cAAc,CAAC,EAAE;MAChC,MAAMkB,aAAa,GAAGlB,cAAc,CAACO,YAAY,CAACO,GAAG,CAAC;MACtDK,iCAAiC,CAACD,aAAa,EAAElB,cAAc,CAACS,mBAAmB,CAACK,GAAG,CAAC,CAAC;MACzF;MACA;IACJ;EACJ;EACA,IAAId,cAAc,CAACO,YAAY,CAACO,GAAG,CAAC,KAAKxF,IAAI,EAAE;IAC3C;IACA0E,cAAc,CAACO,YAAY,CAACO,GAAG,CAAC,GAAGxF,IAAI;IACvC;IACA;IACA0E,cAAc,CAACS,mBAAmB,CAACK,GAAG,CAAC,GAAGG,cAAc,CAACjB,cAAc,CAAC,GAClEoB,uBAAuB,CAAC9F,IAAI,EAAE0E,cAAc,EAAEc,GAAG,CAAC,GAClD,CAAC;EACX;EACAd,cAAc,CAACQ,uBAAuB,CAACM,GAAG,CAAC,GAAGxF,IAAI,CAAC8B,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,sBAAsBA,CAAA,EAAG;EAC9BgC,KAAK,EAAE;AACX;AACA;AACA;AACA;AACA,SAAS7F,0BAA0BA,CAACiB,IAAI,EAAE;EACtC,IAAI2F,cAAc,CAAC3F,IAAI,CAAC,IAAI,CAACA,IAAI,CAACmB,KAAK,EAAE;IACrC;IACA;IACA;EACJ;EACA,IAAI,CAACnB,IAAI,CAACmB,KAAK,IAAInB,IAAI,CAACgF,cAAc,KAAKJ,KAAK,EAAE;IAC9C;IACA;IACA;IACA;EACJ;EACA,IAAI,CAAC5E,IAAI,CAACqB,qBAAqB,CAACrB,IAAI,CAAC,IAAI,CAACsC,8BAA8B,CAACtC,IAAI,CAAC,EAAE;IAC5E;IACA;IACAf,iBAAiB,CAACe,IAAI,CAAC;IACvB;EACJ;EACAA,IAAI,CAACsB,sBAAsB,CAACtB,IAAI,CAAC;EACjC;EACAf,iBAAiB,CAACe,IAAI,CAAC;AAC3B;AACA;AACA;AACA;AACA,SAAS6C,uBAAuBA,CAAC7C,IAAI,EAAE;EACnC,IAAIA,IAAI,CAACqF,gBAAgB,KAAK/E,SAAS,EAAE;IACrC;EACJ;EACA;EACA,MAAMqB,IAAI,GAAGgD,mBAAmB;EAChCA,mBAAmB,GAAG,IAAI;EAC1B,IAAI;IACA,KAAK,MAAMI,QAAQ,IAAI/E,IAAI,CAACqF,gBAAgB,EAAE;MAC1C,IAAI,CAACN,QAAQ,CAAC5D,KAAK,EAAE;QACjBgB,iBAAiB,CAAC4C,QAAQ,CAAC;MAC/B;IACJ;EACJ,CAAC,SACO;IACJJ,mBAAmB,GAAGhD,IAAI;EAC9B;AACJ;AACA;AACA;AACA;AACA;AACA,SAASmB,sBAAsBA,CAAA,EAAG;EAC9B,OAAO4B,cAAc,EAAEjB,yBAAyB,KAAK,KAAK;AAC9D;AACA,SAAStB,iBAAiBA,CAACnC,IAAI,EAAE;EAC7BA,IAAI,CAACmB,KAAK,GAAG,IAAI;EACjB0B,uBAAuB,CAAC7C,IAAI,CAAC;EAC7BA,IAAI,CAACsE,mBAAmB,GAAGtE,IAAI,CAAC;AACpC;AACA,SAASf,iBAAiBA,CAACe,IAAI,EAAE;EAC7BA,IAAI,CAACmB,KAAK,GAAG,KAAK;EAClBnB,IAAI,CAACgF,cAAc,GAAGJ,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrF,yBAAyBA,CAACS,IAAI,EAAE;EACrCA,IAAI,KAAKA,IAAI,CAACoF,iBAAiB,GAAG,CAAC,CAAC;EACpC,OAAOzF,iBAAiB,CAACK,IAAI,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,wBAAwBA,CAACO,IAAI,EAAEyB,YAAY,EAAE;EAClD9B,iBAAiB,CAAC8B,YAAY,CAAC;EAC/B,IAAI,CAACzB,IAAI,IACLA,IAAI,CAACiF,YAAY,KAAK3E,SAAS,IAC/BN,IAAI,CAACmF,mBAAmB,KAAK7E,SAAS,IACtCN,IAAI,CAACkF,uBAAuB,KAAK5E,SAAS,EAAE;IAC5C;EACJ;EACA,IAAIqF,cAAc,CAAC3F,IAAI,CAAC,EAAE;IACtB;IACA;IACA,KAAK,IAAI+F,CAAC,GAAG/F,IAAI,CAACoF,iBAAiB,EAAEW,CAAC,GAAG/F,IAAI,CAACiF,YAAY,CAACS,MAAM,EAAEK,CAAC,EAAE,EAAE;MACpEF,iCAAiC,CAAC7F,IAAI,CAACiF,YAAY,CAACc,CAAC,CAAC,EAAE/F,IAAI,CAACmF,mBAAmB,CAACY,CAAC,CAAC,CAAC;IACxF;EACJ;EACA;EACA;EACA;EACA,OAAO/F,IAAI,CAACiF,YAAY,CAACS,MAAM,GAAG1F,IAAI,CAACoF,iBAAiB,EAAE;IACtDpF,IAAI,CAACiF,YAAY,CAACe,GAAG,CAAC,CAAC;IACvBhG,IAAI,CAACkF,uBAAuB,CAACc,GAAG,CAAC,CAAC;IAClChG,IAAI,CAACmF,mBAAmB,CAACa,GAAG,CAAC,CAAC;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA,SAAS1D,8BAA8BA,CAACtC,IAAI,EAAE;EAC1CyF,kBAAkB,CAACzF,IAAI,CAAC;EACxB;EACA,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/F,IAAI,CAACiF,YAAY,CAACS,MAAM,EAAEK,CAAC,EAAE,EAAE;IAC/C,MAAME,QAAQ,GAAGjG,IAAI,CAACiF,YAAY,CAACc,CAAC,CAAC;IACrC,MAAMG,WAAW,GAAGlG,IAAI,CAACkF,uBAAuB,CAACa,CAAC,CAAC;IACnD;IACA;IACA,IAAIG,WAAW,KAAKD,QAAQ,CAACnE,OAAO,EAAE;MAClC,OAAO,IAAI;IACf;IACA;IACA;IACA/C,0BAA0B,CAACkH,QAAQ,CAAC;IACpC;IACA;IACA,IAAIC,WAAW,KAAKD,QAAQ,CAACnE,OAAO,EAAE;MAClC,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB;AACA;AACA;AACA;AACA,SAASM,eAAeA,CAACpC,IAAI,EAAE;EAC3ByF,kBAAkB,CAACzF,IAAI,CAAC;EACxB,IAAI2F,cAAc,CAAC3F,IAAI,CAAC,EAAE;IACtB;IACA,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/F,IAAI,CAACiF,YAAY,CAACS,MAAM,EAAEK,CAAC,EAAE,EAAE;MAC/CF,iCAAiC,CAAC7F,IAAI,CAACiF,YAAY,CAACc,CAAC,CAAC,EAAE/F,IAAI,CAACmF,mBAAmB,CAACY,CAAC,CAAC,CAAC;IACxF;EACJ;EACA;EACA/F,IAAI,CAACiF,YAAY,CAACS,MAAM,GACpB1F,IAAI,CAACkF,uBAAuB,CAACQ,MAAM,GAC/B1F,IAAI,CAACmF,mBAAmB,CAACO,MAAM,GAC3B,CAAC;EACb,IAAI1F,IAAI,CAACqF,gBAAgB,EAAE;IACvBrF,IAAI,CAACqF,gBAAgB,CAACK,MAAM,GAAG1F,IAAI,CAACsF,uBAAuB,CAACI,MAAM,GAAG,CAAC;EAC1E;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,uBAAuBA,CAAC9F,IAAI,EAAE+E,QAAQ,EAAEoB,WAAW,EAAE;EAC1DC,kBAAkB,CAACpG,IAAI,CAAC;EACxB,IAAIA,IAAI,CAACqF,gBAAgB,CAACK,MAAM,KAAK,CAAC,IAAIW,cAAc,CAACrG,IAAI,CAAC,EAAE;IAC5D;IACA,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/F,IAAI,CAACiF,YAAY,CAACS,MAAM,EAAEK,CAAC,EAAE,EAAE;MAC/C/F,IAAI,CAACmF,mBAAmB,CAACY,CAAC,CAAC,GAAGD,uBAAuB,CAAC9F,IAAI,CAACiF,YAAY,CAACc,CAAC,CAAC,EAAE/F,IAAI,EAAE+F,CAAC,CAAC;IACxF;EACJ;EACA/F,IAAI,CAACsF,uBAAuB,CAACgB,IAAI,CAACH,WAAW,CAAC;EAC9C,OAAOnG,IAAI,CAACqF,gBAAgB,CAACiB,IAAI,CAACvB,QAAQ,CAAC,GAAG,CAAC;AACnD;AACA;AACA;AACA;AACA,SAASc,iCAAiCA,CAAC7F,IAAI,EAAEwF,GAAG,EAAE;EAClDY,kBAAkB,CAACpG,IAAI,CAAC;EACxB,IAAI,OAAOY,SAAS,KAAK,WAAW,IAAIA,SAAS,IAAI4E,GAAG,IAAIxF,IAAI,CAACqF,gBAAgB,CAACK,MAAM,EAAE;IACtF,MAAM,IAAInE,KAAK,CAAC,0CAA0CiE,GAAG,wBAAwBxF,IAAI,CAACqF,gBAAgB,CAACK,MAAM,aAAa,CAAC;EACnI;EACA,IAAI1F,IAAI,CAACqF,gBAAgB,CAACK,MAAM,KAAK,CAAC,IAAIW,cAAc,CAACrG,IAAI,CAAC,EAAE;IAC5D;IACA;IACA;IACA,KAAK,IAAI+F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/F,IAAI,CAACiF,YAAY,CAACS,MAAM,EAAEK,CAAC,EAAE,EAAE;MAC/CF,iCAAiC,CAAC7F,IAAI,CAACiF,YAAY,CAACc,CAAC,CAAC,EAAE/F,IAAI,CAACmF,mBAAmB,CAACY,CAAC,CAAC,CAAC;IACxF;EACJ;EACA;EACA;EACA,MAAMQ,OAAO,GAAGvG,IAAI,CAACqF,gBAAgB,CAACK,MAAM,GAAG,CAAC;EAChD1F,IAAI,CAACqF,gBAAgB,CAACG,GAAG,CAAC,GAAGxF,IAAI,CAACqF,gBAAgB,CAACkB,OAAO,CAAC;EAC3DvG,IAAI,CAACsF,uBAAuB,CAACE,GAAG,CAAC,GAAGxF,IAAI,CAACsF,uBAAuB,CAACiB,OAAO,CAAC;EACzE;EACAvG,IAAI,CAACqF,gBAAgB,CAACK,MAAM,EAAE;EAC9B1F,IAAI,CAACsF,uBAAuB,CAACI,MAAM,EAAE;EACrC;EACA;EACA,IAAIF,GAAG,GAAGxF,IAAI,CAACqF,gBAAgB,CAACK,MAAM,EAAE;IACpC,MAAMc,WAAW,GAAGxG,IAAI,CAACsF,uBAAuB,CAACE,GAAG,CAAC;IACrD,MAAMT,QAAQ,GAAG/E,IAAI,CAACqF,gBAAgB,CAACG,GAAG,CAAC;IAC3CC,kBAAkB,CAACV,QAAQ,CAAC;IAC5BA,QAAQ,CAACI,mBAAmB,CAACqB,WAAW,CAAC,GAAGhB,GAAG;EACnD;AACJ;AACA,SAASG,cAAcA,CAAC3F,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACqE,oBAAoB,IAAI,CAACrE,IAAI,EAAEqF,gBAAgB,EAAEK,MAAM,IAAI,CAAC,IAAI,CAAC;AACjF;AACA,SAASD,kBAAkBA,CAACzF,IAAI,EAAE;EAC9BA,IAAI,CAACiF,YAAY,KAAK,EAAE;EACxBjF,IAAI,CAACmF,mBAAmB,KAAK,EAAE;EAC/BnF,IAAI,CAACkF,uBAAuB,KAAK,EAAE;AACvC;AACA,SAASkB,kBAAkBA,CAACpG,IAAI,EAAE;EAC9BA,IAAI,CAACqF,gBAAgB,KAAK,EAAE;EAC5BrF,IAAI,CAACsF,uBAAuB,KAAK,EAAE;AACvC;AACA,SAASe,cAAcA,CAACrG,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACiF,YAAY,KAAK3E,SAAS;AAC1C;AACA,SAASxB,wBAAwBA,CAACkB,IAAI,EAAE;EACpC6E,qBAAqB,GAAG7E,IAAI,CAAC;AACjC;AACA,SAASgD,wBAAwBA,CAACK,EAAE,EAAE;EAClC,MAAM1B,IAAI,GAAGkD,qBAAqB;EAClCA,qBAAqB,GAAGxB,EAAE;EAC1B,OAAO1B,IAAI;AACf;;AAEA;AACA;AACA;AACA,SAASa,cAAcA,CAACnC,WAAW,EAAEE,KAAK,EAAE;EACxC,MAAMP,IAAI,GAAGC,MAAM,CAACC,MAAM,CAACuG,aAAa,CAAC;EACzCzG,IAAI,CAACK,WAAW,GAAGA,WAAW;EAC9B,IAAIE,KAAK,KAAKD,SAAS,EAAE;IACrBN,IAAI,CAACO,KAAK,GAAGA,KAAK;EACtB;EACA,MAAMmG,QAAQ,GAAGA,CAAA,KAAM;IACnB;IACA3H,0BAA0B,CAACiB,IAAI,CAAC;IAChC;IACAN,gBAAgB,CAACM,IAAI,CAAC;IACtB,IAAIA,IAAI,CAACS,KAAK,KAAKjB,OAAO,EAAE;MACxB,MAAMQ,IAAI,CAACU,KAAK;IACpB;IACA,OAAOV,IAAI,CAACS,KAAK;EACrB,CAAC;EACDiG,QAAQ,CAAC7H,MAAM,CAAC,GAAGmB,IAAI;EACvB,IAAI,OAAOY,SAAS,KAAK,WAAW,IAAIA,SAAS,EAAE;IAC/C,MAAMC,SAAS,GAAGb,IAAI,CAACa,SAAS,GAAG,IAAI,GAAGb,IAAI,CAACa,SAAS,GAAG,GAAG,GAAG,EAAE;IACnE6F,QAAQ,CAAC5F,QAAQ,GAAG,MAAM,YAAYD,SAAS,KAAKb,IAAI,CAACS,KAAK,GAAG;EACrE;EACA3B,wBAAwB,CAACkB,IAAI,CAAC;EAC9B,OAAO0G,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,MAAMtH,KAAK,GAAG,eAAgB0F,MAAM,CAAC,OAAO,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA,MAAMxF,SAAS,GAAG,eAAgBwF,MAAM,CAAC,WAAW,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA,MAAMtF,OAAO,GAAG,eAAgBsF,MAAM,CAAC,SAAS,CAAC;AACjD;AACA;AACA;AACA,MAAM2B,aAAa,GAAG,eAAgB,CAAC,MAAM;EACzC,OAAO;IACH,GAAGtH,aAAa;IAChBsB,KAAK,EAAErB,KAAK;IACZ+B,KAAK,EAAE,IAAI;IACXT,KAAK,EAAE,IAAI;IACXH,KAAK,EAAElB,aAAa;IACpB+B,IAAI,EAAE,UAAU;IAChBC,qBAAqBA,CAACrB,IAAI,EAAE;MACxB;MACA;MACA,OAAOA,IAAI,CAACS,KAAK,KAAKrB,KAAK,IAAIY,IAAI,CAACS,KAAK,KAAKnB,SAAS;IAC3D,CAAC;IACDgC,sBAAsBA,CAACtB,IAAI,EAAE;MACzB,IAAIA,IAAI,CAACS,KAAK,KAAKnB,SAAS,EAAE;QAC1B;QACA,MAAM,IAAIiC,KAAK,CAAC,OAAOX,SAAS,KAAK,WAAW,IAAIA,SAAS,GAAG,iCAAiC,GAAG,EAAE,CAAC;MAC3G;MACA,MAAMY,QAAQ,GAAGxB,IAAI,CAACS,KAAK;MAC3BT,IAAI,CAACS,KAAK,GAAGnB,SAAS;MACtB,MAAMmC,YAAY,GAAGlC,yBAAyB,CAACS,IAAI,CAAC;MACpD,IAAIgB,QAAQ;MACZ,IAAI2F,QAAQ,GAAG,KAAK;MACpB,IAAI;QACA3F,QAAQ,GAAGhB,IAAI,CAACK,WAAW,CAAC,CAAC;QAC7B;QACA;QACAV,iBAAiB,CAAC,IAAI,CAAC;QACvBgH,QAAQ,GACJnF,QAAQ,KAAKpC,KAAK,IACdoC,QAAQ,KAAKhC,OAAO,IACpBwB,QAAQ,KAAKxB,OAAO,IACpBQ,IAAI,CAACO,KAAK,CAACiB,QAAQ,EAAER,QAAQ,CAAC;MAC1C,CAAC,CACD,OAAOa,GAAG,EAAE;QACRb,QAAQ,GAAGxB,OAAO;QAClBQ,IAAI,CAACU,KAAK,GAAGmB,GAAG;MACpB,CAAC,SACO;QACJpC,wBAAwB,CAACO,IAAI,EAAEyB,YAAY,CAAC;MAChD;MACA,IAAIkF,QAAQ,EAAE;QACV;QACA;QACA3G,IAAI,CAACS,KAAK,GAAGe,QAAQ;QACrB;MACJ;MACAxB,IAAI,CAACS,KAAK,GAAGO,QAAQ;MACrBhB,IAAI,CAAC8B,OAAO,EAAE;IAClB;EACJ,CAAC;AACL,CAAC,EAAE,CAAC;AAEJ,SAAS8E,iBAAiBA,CAAA,EAAG;EACzB,MAAM,IAAIrF,KAAK,CAAC,CAAC;AACrB;AACA,IAAIsF,gCAAgC,GAAGD,iBAAiB;AACxD,SAASE,8BAA8BA,CAAC9G,IAAI,EAAE;EAC1C6G,gCAAgC,CAAC7G,IAAI,CAAC;AAC1C;AACA,SAASkD,iCAAiCA,CAACG,EAAE,EAAE;EAC3CwD,gCAAgC,GAAGxD,EAAE;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI0D,eAAe,GAAG,IAAI;AAC1B;AACA;AACA;AACA,SAAStE,YAAYA,CAACuE,YAAY,EAAEzG,KAAK,EAAE;EACvC,MAAMP,IAAI,GAAGC,MAAM,CAACC,MAAM,CAACqC,WAAW,CAAC;EACvCvC,IAAI,CAACS,KAAK,GAAGuG,YAAY;EACzB,IAAIzG,KAAK,KAAKD,SAAS,EAAE;IACrBN,IAAI,CAACO,KAAK,GAAGA,KAAK;EACtB;EACA,MAAMI,MAAM,GAAIA,CAAA,KAAMwC,WAAW,CAACnD,IAAI,CAAE;EACxCW,MAAM,CAAC9B,MAAM,CAAC,GAAGmB,IAAI;EACrB,IAAI,OAAOY,SAAS,KAAK,WAAW,IAAIA,SAAS,EAAE;IAC/C,MAAMC,SAAS,GAAGb,IAAI,CAACa,SAAS,GAAG,IAAI,GAAGb,IAAI,CAACa,SAAS,GAAG,GAAG,GAAG,EAAE;IACnEF,MAAM,CAACG,QAAQ,GAAG,MAAM,UAAUD,SAAS,KAAKb,IAAI,CAACS,KAAK,GAAG;EACjE;EACA3B,wBAAwB,CAACkB,IAAI,CAAC;EAC9B,MAAMiH,GAAG,GAAIjG,QAAQ,IAAKhC,WAAW,CAACgB,IAAI,EAAEgB,QAAQ,CAAC;EACrD,MAAMkG,MAAM,GAAIC,QAAQ,IAAKjI,cAAc,CAACc,IAAI,EAAEmH,QAAQ,CAAC;EAC3D,OAAO,CAACxG,MAAM,EAAEsG,GAAG,EAAEC,MAAM,CAAC;AAChC;AACA,SAASjE,kBAAkBA,CAACI,EAAE,EAAE;EAC5B,MAAM1B,IAAI,GAAGoF,eAAe;EAC5BA,eAAe,GAAG1D,EAAE;EACpB,OAAO1B,IAAI;AACf;AACA,SAASwB,WAAWA,CAACnD,IAAI,EAAE;EACvBN,gBAAgB,CAACM,IAAI,CAAC;EACtB,OAAOA,IAAI,CAACS,KAAK;AACrB;AACA,SAASzB,WAAWA,CAACgB,IAAI,EAAEgB,QAAQ,EAAE;EACjC,IAAI,CAAC8B,sBAAsB,CAAC,CAAC,EAAE;IAC3BgE,8BAA8B,CAAC9G,IAAI,CAAC;EACxC;EACA,IAAI,CAACA,IAAI,CAACO,KAAK,CAACP,IAAI,CAACS,KAAK,EAAEO,QAAQ,CAAC,EAAE;IACnChB,IAAI,CAACS,KAAK,GAAGO,QAAQ;IACrBoG,kBAAkB,CAACpH,IAAI,CAAC;EAC5B;AACJ;AACA,SAASd,cAAcA,CAACc,IAAI,EAAEkB,OAAO,EAAE;EACnC,IAAI,CAAC4B,sBAAsB,CAAC,CAAC,EAAE;IAC3BgE,8BAA8B,CAAC9G,IAAI,CAAC;EACxC;EACAhB,WAAW,CAACgB,IAAI,EAAEkB,OAAO,CAAClB,IAAI,CAACS,KAAK,CAAC,CAAC;AAC1C;AACA,SAASsC,kBAAkBA,CAAC/C,IAAI,EAAE;EAC9B+G,eAAe,GAAG/G,IAAI,CAAC;AAC3B;AACA;AACA;AACA;AACA,MAAMuC,WAAW,GAAG,eAAgB,CAAC,MAAM;EACvC,OAAO;IACH,GAAGpD,aAAa;IAChBoB,KAAK,EAAElB,aAAa;IACpBoB,KAAK,EAAEH,SAAS;IAChBc,IAAI,EAAE;EACV,CAAC;AACL,CAAC,EAAE,CAAC;AACJ,SAASgG,kBAAkBA,CAACpH,IAAI,EAAE;EAC9BA,IAAI,CAAC8B,OAAO,EAAE;EACdc,sBAAsB,CAAC,CAAC;EACxBC,uBAAuB,CAAC7C,IAAI,CAAC;EAC7B+G,eAAe,GAAG/G,IAAI,CAAC;AAC3B","sources":["./node_modules/@angular/core/fesm2022/untracked-DmD_2MlC.mjs","./node_modules/@angular/core/fesm2022/weak_ref-BaIq-pgY.mjs","./node_modules/@angular/core/fesm2022/primitives/signals.mjs","./node_modules/@angular/core/fesm2022/signal-nCiHhWf6.mjs"],"sourcesContent":["/**\n * @license Angular v20.0.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer } from './signal-nCiHhWf6.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n    const node = Object.create(LINKED_SIGNAL_NODE);\n    node.source = sourceFn;\n    node.computation = computationFn;\n    if (equalityFn != undefined) {\n        node.equal = equalityFn;\n    }\n    const linkedSignalGetter = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    const getter = linkedSignalGetter;\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n    producerUpdateValueVersion(node);\n    signalSetFn(node, newValue);\n    producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n    producerUpdateValueVersion(node);\n    signalUpdateFn(node, updater);\n    producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'linkedSignal',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                const newSourceValue = node.source();\n                const prev = oldValue === UNSET || oldValue === ERRORED\n                    ? undefined\n                    : {\n                        source: node.sourceValue,\n                        value: oldValue,\n                    };\n                newValue = node.computation(newSourceValue, prev);\n                node.sourceValue = newSourceValue;\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked };\n","/**\n * @license Angular v20.0.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\nexport { setAlternateWeakRefImpl };\n","/**\n * @license Angular v20.0.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { consumerMarkDirty, SIGNAL, REACTIVE_NODE, consumerDestroy, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from '../signal-nCiHhWf6.mjs';\nexport { SIGNAL_NODE, createComputed, createSignal, defaultEquals, getActiveConsumer, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn } from '../signal-nCiHhWf6.mjs';\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked } from '../untracked-DmD_2MlC.mjs';\nexport { setAlternateWeakRefImpl } from '../weak_ref-BaIq-pgY.mjs';\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n                ? 'Schedulers cannot synchronously execute watches while scheduling.'\n                : '');\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };\n","/**\n * @license Angular v20.0.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer)\n            ? producerAddLiveConsumer(node, activeConsumer, idx)\n            : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node ||\n        node.producerNode === undefined ||\n        node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n    // benchmarking has shown that individual pop operations are faster.\n    while (node.producerNode.length > node.nextProducerIndex) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length =\n        node.producerLastReadVersion.length =\n            node.producerIndexOfThis.length =\n                0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n    }\n    if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n    return node.producerNode !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n    postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n    const prev = postProducerCreatedFn;\n    postProducerCreatedFn = fn;\n    return prev;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => signalGetFn(node));\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    const set = (newValue) => signalSetFn(node, newValue);\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\n    return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn(node) {\n    producerAccessed(node);\n    return node.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n    postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.(node);\n}\n\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n"],"names":["SIGNAL","runPostProducerCreatedFn","producerUpdateValueVersion","signalSetFn","producerMarkClean","signalUpdateFn","REACTIVE_NODE","UNSET","defaultEquals","COMPUTING","consumerBeforeComputation","ERRORED","consumerAfterComputation","producerAccessed","setActiveConsumer","createLinkedSignal","sourceFn","computationFn","equalityFn","node","Object","create","LINKED_SIGNAL_NODE","source","computation","undefined","equal","linkedSignalGetter","value","error","getter","ngDevMode","debugName","toString","linkedSignalSetFn","newValue","linkedSignalUpdateFn","updater","dirty","kind","producerMustRecompute","producerRecomputeValue","Error","oldValue","prevConsumer","newSourceValue","prev","sourceValue","err","version","untracked","nonReactiveReadsFn","setAlternateWeakRefImpl","impl","consumerMarkDirty","consumerDestroy","isInNotificationPhase","consumerPollProducersForChange","SIGNAL_NODE","createComputed","createSignal","getActiveConsumer","isReactive","producerIncrementEpoch","producerNotifyConsumers","producerUpdatesAllowed","runPostSignalSetFn","setPostProducerCreatedFn","setPostSignalSetFn","setThrowInvalidWriteToSignalError","signalGetFn","createWatch","fn","schedule","allowSignalWrites","WATCH_NODE","consumerAllowSignalWrites","registerOnCleanup","cleanupFn","isWatchNodeDestroyed","destroyWatchNode","NOOP_CLEANUP_FN","run","hasRun","ref","notify","cleanup","destroy","consumerIsAlwaysLive","consumerMarkedDirty","a","b","is","activeConsumer","inNotificationPhase","epoch","postProducerCreatedFn","Symbol","consumer","lastCleanEpoch","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerOnSignalRead","idx","assertConsumerNode","length","consumerIsLive","staleProducer","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","i","pop","producer","seenVersion","indexOfThis","assertProducerNode","isConsumerNode","push","lastIdx","idxProducer","COMPUTED_NODE","computed","wasEqual","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","postSignalSetFn","initialValue","set","update","updateFn","signalValueChanged"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2,3]}